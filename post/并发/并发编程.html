<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        玲辰书斋
        12312
    </title>
    <meta name="description" content= 嘿，我是刘训灼～这是我的子站，用于展示写的Hexo主题：Coder。欢迎访问！ >
    <meta name="keywords" content= Blog,Hexo,Theme,刘训灼,LiuXunzhuo >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            并发编程
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h2 id="基础的概念"><a href="#基础的概念" class="headerlink" title="基础的概念"></a>基础的概念</h2><h3 id="什么是并发操作？"><a href="#什么是并发操作？" class="headerlink" title="什么是并发操作？"></a>什么是并发操作？</h3><p>利用多核CPU去完成任务，类似于使用影分身去完成不同的作业，这肯定比我一个人一个个写要快的多</p>
<h3 id="什么时候可以使用并发？"><a href="#什么时候可以使用并发？" class="headerlink" title="什么时候可以使用并发？"></a>什么时候可以使用并发？</h3><p>当有多核CPU时。如果只有一个CPU，那并发实际上只是线程的不断切换，好比我在数学作业上先写点儿，再到语文上再写点儿，因为处理的很快，给人的感觉是同时操作的。但实际上只会比原来更慢。</p>
<h3 id="如何使用并发编程？"><a href="#如何使用并发编程？" class="headerlink" title="如何使用并发编程？"></a>如何使用并发编程？</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BasicLearn</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 无返回值</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 有返回值</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token string">" a "</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>实现Runnable或Callable接口，从写run方法。</li>
<li>继承Thread类，从写run方法</li>
</ol>
<h3 id="实现Runnable-和-继承Thread有什么区别"><a href="#实现Runnable-和-继承Thread有什么区别" class="headerlink" title="实现Runnable 和 继承Thread有什么区别"></a>实现Runnable 和 继承Thread有什么区别</h3><ol>
<li>Java是单继承结构，如果继承Thread，无法继承其他的类，接口更灵活</li>
<li>继承Thread开销会大一些，如果我们只要求可运行</li>
</ol>
<h3 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h3><ol>
<li><p>普通线程，就是我们上面所讲的内容</p>
</li>
<li><p>守护线程，也叫做<code>Daemon</code>，当所有非守护线程结束后，守护线程就会被回收。比如说垃圾回收就是守护线程</p>
<ol>
<li>```java<br>// 注意守护线程不能操作重要的数据，因为无法保证可以执行完后，守护线程才停止。<br>public static void main(String[] args) {<pre><code>Thread thread = new Thread(new MyRunnable());
thread.setDaemon(true);
</code></pre>
}<pre class="line-numbers language-none"><code class="language-none">
### 线程的状态

1. New ：创建好，但还未启动
2. Runable ：Runable本身是两个状态，一个是Runable表示等待CPU时间片的线程，一个是Running表示正在使用时间片的线程
3. Blocked ：阻塞住的线程 
4. Waiting  ：一直等待线程，直到被唤醒
5. Time Waiting ：有时间的等待，到时间自己醒了
6. terminted ：线程结束

### 线程的中断

​	听起来线程的中断有点儿像人家正好好干活，你突然把人家赶走了。但实际上是这个线程在 Blocked 或 Waiting 时，我们将其打断，让他别等了。

​	我们常用：&#96;interrupt() &#96; 来打断线程，打断后会抛出 InterruptedException，从而提前结束该线程。但是**不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞**。也是比较好判断的就是你看方法的调用是否有InterruptedException,如果有说明可以被打断。

​	如果该线程好好干活，我们是无法将其打断的。调用 &#96;interrupt()&#96;，只会是将其内部状态作为修改，通过 &#96;interrupted()&#96; 我们可以看这个线程是否被打断过，在 &#96;while（true）中我们可以通过使用 interrupted() 来判断是否跳出循环 &#96;

​	在使用 Executor 去管理多个线程任务时，有方法 &#96;shutdown() 和 shutdownNow()&#96;，区别是 shutdown() 是等所有线程执行完后进行结束。而shutdownNow()表示现在就可以结束了。

### 多线程的缺点

​	一旦涉及到多线程，总是面临着数据安全的问题，如果一组操作没有原子性，那在多线程的情况下就会出现数据安全的问题。所以为了数据的安全性，我们引出了锁的概念，线程去抢同一把锁，谁抢到了谁去操作数据，其他人就在外面等着（阻塞），直到锁被之前持有的线程释放。锁的实现分为很多种，我们下面会介绍。

### 线程各个操作导致的状态

​	这里我们常在使用锁的情况下来描述，比方说多个线程抢同一把锁，如果使用 &#96;Thread.sleep() 或 Thread.yield() &#96;是否会放回锁。

&#96;&#96;&#96;java
&#x2F;&#x2F; 线程进入Runable，但未释放锁资源
Thread.yield();
&#x2F;&#x2F; 线程进入Blocked，但未释放锁资源
Thread.sleep();
&#x2F;&#x2F; 线程进入Waiting状态，释放锁资源
objectLock.wait();
&#x2F;&#x2F; 底层实际用的wait(), 释放锁资源
Thread.join();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
</ol>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>这里有个小问题：<code>objectLock.notify() 与 objectLock.notifyall() </code> 有什么区别？</p></blockquote>
<p>notify是释放一个线程去抢锁，notifyall是释放所有等待的去抢锁，但只有一个能抢到。这看起来感觉不到区别。</p>
<p>实际上每个对象底层有两个池：锁池 和 等待池</p>
<ol>
<li>在锁池的是阻塞状态，当锁被释放，所有在锁池的对象都有机会获得锁</li>
<li>在等待池的是等待状态，是没有资格去抢锁的，只能被人唤醒</li>
</ol>
<p>​    当A线程抢到锁后，B线程没抢到就进入了锁池，A线程虽然抢到了，但是需要的资源没到位，使用了wait，进入的是等待池。这时候B就可以获取锁，并执行业务了，但A因为在等待池，所以即便是锁没被占用，自己仍无法操作，直到被唤醒。</p>
<p>​    notify() 是将等待池的一个线程加入锁池，而notifyall() 是将等待池中的所有线程加入锁池。</p>
<h3 id="当一个线程需要等待另一个线程的资源"><a href="#当一个线程需要等待另一个线程的资源" class="headerlink" title="当一个线程需要等待另一个线程的资源"></a>当一个线程需要等待另一个线程的资源</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> start <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Object</span> objectLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objectLock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        objectLock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ReentrantLock</span> reentrantLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Condition</span> condition <span class="token operator">=</span> reentrantLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        condition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>比如我们主线程需要等待一个启动线程返回的结果，我们可以直接使用<code>Thread.join()</code>,等待该线程将资源返回，但这种方式必须要等到线程结束，主线程才能去获取，非常不灵活。因此我们常使用 <code>Object.wait() 与 Object.notify()</code>  方法可以更加主动的去等待与被通知。但有什么缺陷呢？</p>
<ol>
<li> 必须在静态代码块儿中使用，负责会抛出异常，这一点在 <code>condition.wait() 与condition.signal() </code>也存在</li>
<li>必须先<code>wait() 再 notify()</code> 否则会报错，因此我们常用：<code>LockSupport.park();</code></li>
</ol>
<p>LockSupport.park(); 底层使用的Unsafe类，它是可以操作线程和内存的，所以说不安全，要规范使用，在Atomic类中底层调用的也是它。而且它不能被直接获取，只能通过反射来获取。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">UnsafeAccessor</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token class-name">Unsafe</span> unsafe<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">Field</span> theUnsafe <span class="token operator">=</span> <span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            theUnsafe<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            unsafe <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Unsafe</span><span class="token punctuation">)</span> theUnsafe<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchFieldException</span> <span class="token operator">|</span> <span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">static</span> <span class="token class-name">Unsafe</span> <span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>这里设计线程的工作内存与主内存数据的交互，为什么有工作内存，就是因为CPU对寄存器的操作远远超出了对内存的操作，所以线程是工作内存拷贝主内存，来使得CPU操作工作内存更快速，</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>禁止指令重排</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8faeik83zj30u70ifgnm.jpg" alt="image-20221123193040531"></p>
<h3 id="ReentrantLock-源码解读"><a href="#ReentrantLock-源码解读" class="headerlink" title="ReentrantLock 源码解读"></a>ReentrantLock 源码解读</h3><h3 id="活锁，死锁，哲学家问题"><a href="#活锁，死锁，哲学家问题" class="headerlink" title="活锁，死锁，哲学家问题"></a>活锁，死锁，哲学家问题</h3><p>活锁： 两个线程互相影响彼此依赖的变量</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestLiveLock</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 期望减到 0 退出循环</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                count<span class="token operator">--</span><span class="token punctuation">;</span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"count: &#123;&#125;"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 期望超过 20 退出循环</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"count: &#123;&#125;"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>死锁：程序需要获取两把锁才能向下执行，两个线程各拿到了一把锁，等待另一把，导致双方都进入阻塞。</p>
<p>哲学家问题就是死锁问题的一种形式。</p>
<h2 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h2><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>Java对象头</p>
<p>普通对象：</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8faus1kkwj30kw04ljrt.jpg" alt="image-20221123194620216"></p>
<p>数组对象：</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8fav2bu47j30rt04t3z6.jpg" alt="image-20221123194636687"></p>
<p>其中Mark Wordd的内部结构（32位虚拟机）</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8favja6noj30on0bwtal.jpg" alt="image-20221123194704096"></p>
<p>64位虚拟机</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8faw6ikyrj30sh0bjwgm.jpg" alt="image-20221123194741408"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当<code>synchronized 对对象加入重量级锁时，Mark Work中就会有指向Monitor对象的指针</code>，下面我们看看Monitor的结构</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8fb7t8hbdj30uq0cf0u9.jpg" alt="image-20221123195851860"></p>
<p>WaitSet 就是等待队列</p>
<p>EntryList 就是阻塞队列</p>
<p>Owner 就是当前获取锁的线程</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>​    以前线程没有抢到锁，就会直接进入阻塞队列，但这代价太大了，所以JDK1.6后，因为了自旋锁，也就是抢不到锁后，没立刻阻塞，而是继续尝试获取锁，最后实在不行，就阻塞，因为也占用CPU资源。尝试几次是看之前获取几次来判断的，这也是自适应自旋锁的一个特点。</p>
<p>​    自旋会占用CPU，所以单核CPU自旋就是浪费，只有多核CPU才能提高性能</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>​    通过逃逸分析，发现一个虽然加锁了，但实际上数据是无法被外界影响的，就会把锁消除。</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>​    对一个对象反复的加锁解锁，性能影响很大，如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><ol>
<li>对使用者透明：<code>synchronized</code></li>
<li>多线程访问的时间是错开的，可用轻量级锁来优化</li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token comment">// 同步块 A</span>
 <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
 <span class="token comment">// 同步块 B</span>
 <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当遇到加锁操作时，线程的栈帧中会创建一个（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的解耦，内部存放锁定对象的Mark Word</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g07uvra5j30n00cl0ty.jpg" alt="image-20221124102353283"></p>
<ul>
<li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录。</p>
<ul>
<li>如果成功说明，锁当前没有被占用，01 代表无锁，00代表轻量级锁，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>
<li>如果失败说明，有竞争，进入锁膨胀过程</li>
<li>如果发现有竞争，但是可以通过Mark Word 判断加锁的线程是不是自己，如果是自己，则再添加一个Lock Record作为重入计数</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g0bqg2mpj30oy0e3abi.jpg" alt="image-20221124102736732"></p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g0ed5zh5j30p70ftmz3.jpg" alt="image-20221124103008743"></p>
<p>​    当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一。</p>
<p>​    当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p>
<ul>
<li><p>成功，则解锁成功</p>
</li>
<li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>
</li>
</ul>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>​    当发现线程竞争发生了直接冲突时，就会将Object中MarkWork指向Monitor，并且将状态改为10。10就是重量级锁。阻塞线程就进入Monitor的EntryList进行阻塞。</p>
<p>​    当持有轻量级锁的线程进行cas操作时，发现失败了，就说明现在已经是重量级锁了，则通过Monitor地址找到Monitor对象，将Owner设置为空，表示锁释放，然后通知EntryList阻塞线程唤醒。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g0o9wodtj30uz0b8dhe.jpg" alt="image-20221124103939951"></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是对轻量级锁的再次优化，之前使用轻量级锁方案时，每次获取锁都要和Object的对象头做CAS操作，即便是重入锁，也需要该操作。现在希望Object对象头上直接写占有锁的线程ID，这样只要比较，不进行CAS操作。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g111ax0wj30p70jqmz0.jpg" alt="image-20221124105155494"></p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g118jj14j30ov0dagmr.jpg" alt="image-20221124105207495"></p>
<p>查看对象头的信息</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.openjdk.jol<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jol-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.16<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
    // 这里需要注意，不用provided
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g1m9xer0j30sx0c276u.jpg" alt="image-20221124111220643"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> start <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span>  <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//        0x0000000000000001</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//        延迟显示，不延迟：-XX:BiasedLockingStartupDelay=0</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>适用范围：锁竞争少。</p>
<p>如果是多线程竞争，可以设置关闭偏向锁，默认是开启的，适用：<code>-XX:-UseBiasedLocking</code></p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>需要注意：当使用了对象的.hashcode()方法会变为不可偏向</p></blockquote>
<p>因为在偏向锁中对象头没有位置存储HashCode，所以转为轻量级锁或者重量级锁。每个对象最初的HashCode为0，第一次使用时，进行赋值。</p>
<h3 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h3><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8g22iaj76j30to06caam.jpg" alt="image-20221124112756210"></p>
<p>这里分为三类</p>
<ol>
<li><p>遗留的：HashTable（Map），Vector（List）</p>
</li>
<li><p>使用 Collections 装饰的线程安全集合，如：Collections.synchronizedCollection，可以将线程不安全的集合包装为线程安全的，底层实际上就是方法调用时包装类对原先方法加锁。  </p>
</li>
<li><p>JUC包下的类</p>
</li>
</ol>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: 秦思成 | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
