<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        玲辰书斋
        12312
    </title>
    <meta name="description" content= 嘿，我是刘训灼～这是我的子站，用于展示写的Hexo主题：Coder。欢迎访问！ >
    <meta name="keywords" content= Blog,Hexo,Theme,刘训灼,LiuXunzhuo >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            后端风云
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="后端风云"><a href="#后端风云" class="headerlink" title="后端风云"></a>后端风云</h1><p>​        本文简单概况了一下刘欣老师的《码农翻身》的后端风云章，这本书强烈推荐给大家，每看一遍都有不同的感觉，通俗易懂且知识面大而全。居家旅行，必备良药！！！</p>
<h2 id="早期初级阶段："><a href="#早期初级阶段：" class="headerlink" title="早期初级阶段："></a>早期初级阶段：</h2><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek1qz02j30ly0bcaal.jpg" alt="image-20220820220959059"></p>
<p>​        在我们早期学习 <code>javaWeb</code>阶段，将订单模块儿，购物车模块儿，支付模块儿都写在了一个项目中，并访问一个Mysql数据库，这在自己练手项目中是没问题的，但如果系统上线，有大量的用户同时访问该系统，Tomcat服务器首先需要考虑能不能支撑住大的并发量（默认150，当超过250时，就应该考虑的服务器的集群），其次是Mysql数据库,在高并发两三千也就差不多了，要知道Mysql数据库读取数据是很慢的操作，它本质是从硬盘中读取文件的。</p>
<h2 id="优化点1-使用缓存"><a href="#优化点1-使用缓存" class="headerlink" title="优化点1:使用缓存"></a>优化点1:使用缓存</h2><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejxz2vfj30kn06raaf.jpg" alt="image-20220820120628253"></p>
<p>可以看到我们给中间加了一个Redis中间件作为缓存，现在服务器需要获取数据，先到缓存中找数据，如果找不到再去Mysql中找数据，找到数据后再写回Redis中，这样下次请求数据可以直接在缓存中获取数据，那缓存的好处是啥，缓存是加载在内存中的，读取数据那肯定是快的多。这样就减轻Mysql数据库的压力。但是如果用户每次请求先去缓存找，如果都没找到，那请求还是落在了Mysql上，这个可能导致缓存击穿，缓存雪崩。</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>提问：如果数据库中数据修改了，但是缓存中还是之前的数据该怎么办？</p>
<p>为了保证数据的一致性下面的方案是否可行？</p>
<ol>
<li>先更新数据库中，再更新缓存</li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删缓存</li>
<li>数据设置过期时间</li>
</ol>
<p>这里参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/diweikang/article/details/94406186">https://blog.csdn.net/diweikang/article/details/94406186</a></p></blockquote>
<h2 id="优化点2-多台缓存"><a href="#优化点2-多台缓存" class="headerlink" title="优化点2:多台缓存"></a>优化点2:多台缓存</h2><p>之前我们在服务器与数据库中间加上一个缓存，来减轻数据库的压力，和提高数据读取速度，但如果只有一台缓存，后期也会因为内存用完而耗尽，缓存要是挂机了，又是数据库直面大量请求了，那我们多部署几个缓存服务器来分摊一下压力。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek34irtj30pc09ugmh.jpg" alt="image-20220820131146797"></p>
<p>当部署多个缓存服务器时，又出现问题了，我读取和存放数据的时候，我用哪个服务器啊，我们先不说具体用啥算法，我们先想想我们需要啥？</p>
<ol>
<li>我存的地方和我找的地方得一致，不能我存在缓存1，结果去缓存3找，那肯定是没数据</li>
<li>我存放数据的均匀的落在这三个缓存上，不能说饿的饿死，撑得撑死。</li>
</ol>
<h3 id="余数算法"><a href="#余数算法" class="headerlink" title="余数算法"></a>余数算法</h3><p>最简单：在找数据或者写数据时，先求Hash值，然后对Hash值进行取余，这样可以均匀的将请求落在三个缓存中。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek0ropij30i007z74w.jpg" alt="image-20220820162701218"></p>
<p>​        缺点也很明显：之前我用三个缓存好好的，数据存储的也没问题，现在要再加一个缓存，那现在读数据和写数据取余可就变成4了，之前的数据可就都访问不到了，请求一下子又干到数据库了</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejv7pnhj30n507qgmi.jpg" alt="image-20220820162729067"></p>
<h3 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h3><p>一致性Hash算法不能完全的解决这个问题，但是可以做到大部分数据可以照常工作</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek2n3qfj30j70c174f.jpg" alt="image-20220820163202097"></p>
<p>​        比方说我们在这个圆上标注 <code>0-2^32-1</code>个点，三台redis服务器均匀的落在这个图上，当有数据要查找或插入时，还是先取Hash值，使落在这个圆的范围上，如果超出了那就取余。比方说这是插入的这个点落在了A到B之前的位置，那就让它顺时针找它最近的那个服务器点，数据存放在那里，这时候就找到了B，如果是落在了C到A的范围，那还是顺时针走，走到A的位置。</p>
<p>​        假如说突然又添加了一个服务器D，假如插在了B和C之间。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek18qiqj30i70c374j.jpg" alt="image-20220820163842694"></p>
<p>​        那么现在要查询数据时，点位落在了B到C之前，原来是到C去读取数据，现在就看是不是在B和D之间了，如果在这之间那就去D找，如果落在了D到C之间，那还是去C找。这时候就发现到D找的数据肯定是找不到的，但是其他区域的数据都不会被影响到啊，这样就避免了全部缓存穿透导致的缓存雪崩。</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>这里的一个前提条件就是服务器经过Hash计算后需要均匀的落在这个区间内，否则就会有部分的缓存负责过高，有的负载过低，也就是<code>数据倾斜</code></p></blockquote>
<p>​        比方说我们个人开发的小项目，就用两个缓存服务器，那这么大的一个圆就放两个点，可能导致数据都集中到了一个服务器上，导致压力过大</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>解决这个问题的办法有：<code>虚拟服务器（虚拟节点映射）</code></p></blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejvpj1aj30lg0iemys.jpg" alt="image-20220820165011054"></p>
<p>就是将一个真实服务器看做成多态虚拟的服务器，均匀的分布到圆上。</p>
<p>保证数据均匀的存放在真实的缓存服务器上</p>
<h3 id="Hash槽算法"><a href="#Hash槽算法" class="headerlink" title="Hash槽算法"></a>Hash槽算法</h3><p>槽可以理解为分区，数据都是存放在分区中的，然后分区与机器进行动态绑定。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejyvqptj30m906sgm7.jpg" alt="image-20220820200524038"></p>
<p>​        比方说现在要存储(Key,Value),先对Key求Hash值，然后对16384求余数，看到余数落在那个槽位，就放到哪个服务器。是不是感觉第三种算法和余数算法和一致性Hash算法都有点儿像，类似于一个综合的算法</p>
<p>​        那假如我现在要新增一个节点怎么办，现在有三个服务器，假如再来一个服务器4，就从服务器1，服务器2，服务器3中各取出一部分槽和数据。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejyfi27j30ml0b5759.jpg" alt="image-20220820201220590"></p>
<p>​        那相应的我请求请求的时候选择哪个节点，这里客户端可以向任意一个节点发送请求，例如：get(key1)这个请求我发送给了服务器1，但是数据是在服务器2，则服务器会将请求重定向到服务器2。这也叫做<code>Redis Cluster</code></p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>为什么redis集群不采用一致性哈希算法？</p></blockquote>
<p>​        一个直观的区别就是一致性Hash，无法很好的控制数据的分布，比方说我是有几个服务器，但是各个硬件条件并不一样，想让配置比较好的多放一些数据，配置差点儿的就少部署一些，可以做到精确控制。</p>
<h2 id="优化点3-故障转移"><a href="#优化点3-故障转移" class="headerlink" title="优化点3:故障转移"></a>优化点3:故障转移</h2><p>​        比方说我原先有三个缓存服务器，每个服务器负责一部分Hash槽，假如这时候一个服务器挂了，那这部分数据就算丢失了，这部分的请求也就又干到数据库了，现在我们利用Redis提供的 <code>master-slave</code>功能，就是一个大哥带几个小弟，如果大哥被干掉了，小弟中一个人就去当大哥管事儿。大哥与小弟之前的数据是同步的，以确保小弟可以顺利的继位</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek4j9zfj30n50f00u4.jpg" alt="image-20220820205141078"></p>
<h2 id="优化点4-高可用的Tomcat"><a href="#优化点4-高可用的Tomcat" class="headerlink" title="优化点4:高可用的Tomcat"></a>优化点4:高可用的Tomcat</h2><p>​        在文章的最开始我们就说了Tomcat默认支持的并发量并不大，且如果它挂掉了，那完蛋了，服务直接用不了了，所以索性我们学习一下Redis，多部署几个Tomcat服务器，让请求均摊到各个Tomcat服务器之间，这样就可以有效的降压，如果有一个服务器挂了，其他的服务器还能继续干。</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>问题：Tomcat的Session信息是不能服务共享的，假如用户A在Tomcat服务器1上进行登陆了，并将登陆信息保存在Session中，现在用户又请求了，被轮训到了服务器2上，但是服务器2是没有该用户的Session信息的，这又得让用户去登陆</p></blockquote>
<p>可以使用Redis缓存来处理。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejzumt3j30f80a574n.jpg" alt="image-20220820211730816"></p>
<h2 id="优化点5-使用Nginx"><a href="#优化点5-使用Nginx" class="headerlink" title="优化点5:使用Nginx"></a>优化点5:使用Nginx</h2><p>其实在之前我一直对Nginx都是懵逼状态，明明可以直接访问Tomcat，为啥要中间加一个Nginx。我对Nginx最直观的使用就是通过端口去访问服务器静态文件，去做个人博客，但现在按照我们优化点4所说的部署多个Tomcat服务器，那前端到底访问哪个Tomcat呢？总不能写死到前端代码里去轮询吧，如果我们在中间加一个Nginx去做代理，就会舒服的多。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejx1jhgj30s00agdgt.jpg" alt="image-20220820212437837"></p>
<p>这里我就不说文绉绉的定义了，可以去官网上查</p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejw7k9mj30jm0eujsa.jpg" alt="image-20220820212745193"></p>
<p>​        这里说一个例子就行了，VPN翻墙，你想访问国外网址，但是电脑受国内管控，无法访问，那就需要一个代理，你请求代理，代理请求国外服务器，然后数据返回。</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek2729wj30jt0dmab1.jpg" alt="image-20220820213214154"></p>
<p>比方说我们现在上网搜索<a target="_blank" rel="noopener" href="http://www.baidu.com,我们只知道这个域名,但实际上它可能只是一个代理,真实的请求是转发到内部的其他服务,这样也可以保护真实的服务器.和正向代理的区别是,正向代理是知道我要找谁,反向代理是我也不知道谁真实的服务./">www.baidu.com,我们只知道这个域名，但实际上它可能只是一个代理，真实的请求是转发到内部的其他服务，这样也可以保护真实的服务器。和正向代理的区别是，正向代理是知道我要找谁，反向代理是我也不知道谁真实的服务。</a></p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>就是将请求均匀的发送到各个服务器间</p>
<p>其中有轮训方式</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek50a64j30h70by3z5.jpg" alt="image-20220820213520428"></p>
<p>有权重方式</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek3l5l8j30jx0d9dgq.jpg" alt="image-20220820213640770"></p>
<h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>很直观的，我们可以通过Nginx直接访问静态文件。那Tomcat也可以访问静态文件啊，但是低，且一般Tomcat是作为业务逻辑服务器的，如果将动态资源和静态资源都放在Tomcat中，就会消耗额外的一部分性能，</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejxhy9fj30k80c9mxr.jpg" alt="image-20220820214118620"></p>
<h3 id="高可用的Nginx"><a href="#高可用的Nginx" class="headerlink" title="高可用的Nginx"></a>高可用的Nginx</h3><p>​        我们已经发现如果一条链路中如果某个地方只有一个工作的，那一旦它挂机了，后续工作都无法进行了。所以按照之前的设计我们再部署一个Nginx服务器，但是与Tomcat不同的是，Nginx是直面客户端的，所以即使是多个服务，对外也只能暴露一个Ip地址，从外面看就只有一个服务，通过 <code>Keepalived</code>将多个Nginx服务形成<code>master-slave</code>关系，一个挂了，另一个补上，那我们的结构图又得更新了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejut0lgj30sm09ejsf.jpg" alt="image-20220820214735780"></p>
<h2 id="优化点6-数据库的读写分离"><a href="#优化点6-数据库的读写分离" class="headerlink" title="优化点6:数据库的读写分离"></a>优化点6:数据库的读写分离</h2><p>​        我们看上面的系统架构图后发现似乎就剩数据库是孤家寡人了，但如果把数据多部署几个，如果每个都可以进行读写操作，那服务之间的数据一致性就很难再确定了，而对数据库的大部分操作都是读操作，写操作相比要少的多。而且我们都知道数据库的共享锁和写锁互斥，这也是影响效率的，如果能分开的话，速度方面，安全方面肯定更稳健。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek0a4fcj30cu0c3gm3.jpg" alt="image-20220820215503380"></p>
<p>假如有一天master挂掉了，那在剩余的slave中选一个，是不是就发现，多服务部署的思想很多都是一样的。就是为了保证高可用性。</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>但是Tomcat可就犯难了，难倒我每次请求前都判断一下是读操作还是写操作，再根据不同的类型，发送不同的数据库吗？</p></blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejwlg47j30gs09i3z1.jpg" alt="image-20220820215954215"></p>
<h3 id="使用MySQL-Proxy"><a href="#使用MySQL-Proxy" class="headerlink" title="使用MySQL Proxy"></a>使用MySQL Proxy</h3><p>发挥我们抽象的大脑，只要有这种不属于我们应该管的事，我们就把活儿抛出去，我们再增加一个抽象层。将这些脏活累活统一交给Mysql Proxy去管理</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hejzd2b8j30h60dzt9l.jpg" alt="image-20220820220324413"></p>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>我们的系统已经可见性的复杂的多了，但为了保证服务不会突然挂掉了，这些也是必须的。至于后期还有更多的优化，例如ES，MQ，熔断降级，分布式注册中心，配合中心，等各种骚操作后面再不断加呗，一口吃不成胖子。</p>
<p><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h8hek414svj30jr0f4gmy.jpg" alt="image-20220820220832414"></p>

    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: 秦思成 | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
