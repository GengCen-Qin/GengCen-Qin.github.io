<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Ruby元编程 | 玲辰书斋</title><meta name="author" content="庚辰"><meta name="copyright" content="庚辰"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文需要在了解Ruby基本语法的前提下，进行学习  元编程是什么？​    元编程是编写能在运行时操作语言构件的代码 ​    在我们使用编辑器编写代码后，代码按照我们所写的内容进行编译，运行。在启动后我们无权再对代码进行干涉，而在一些业务场景中，我们想在不修改源代码的前提下，对一个类进行增强，这在Java中也是一个成熟的技术，例如反射，动态代理。但是Java所能给予的操作相比Ruby，就显得格外">
<meta property="og:type" content="article">
<meta property="og:title" content="Ruby元编程">
<meta property="og:url" content="http://www.chengling.cloud/post/Ruby/Ruby%E5%85%83%E7%BC%96%E7%A8%8B.html">
<meta property="og:site_name" content="玲辰书斋">
<meta property="og:description" content="本文需要在了解Ruby基本语法的前提下，进行学习  元编程是什么？​    元编程是编写能在运行时操作语言构件的代码 ​    在我们使用编辑器编写代码后，代码按照我们所写的内容进行编译，运行。在启动后我们无权再对代码进行干涉，而在一些业务场景中，我们想在不修改源代码的前提下，对一个类进行增强，这在Java中也是一个成熟的技术，例如反射，动态代理。但是Java所能给予的操作相比Ruby，就显得格外">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.chengling.cloud/img/default_top_img.jpg">
<meta property="article:published_time" content="2023-01-02T02:30:12.000Z">
<meta property="article:modified_time" content="2023-03-13T09:42:35.368Z">
<meta property="article:author" content="庚辰">
<meta property="article:tag" content="元编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.chengling.cloud/img/default_top_img.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.chengling.cloud/post/Ruby/Ruby%E5%85%83%E7%BC%96%E7%A8%8B"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ruby元编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-13 17:42:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/myHead.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">玲辰书斋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Ruby元编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-02T02:30:12.000Z" title="发表于 2023-01-02 10:30:12">2023-01-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-13T09:42:35.368Z" title="更新于 2023-03-13 17:42:35">2023-03-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Ruby/">Ruby</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Ruby元编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><pre><code>本文需要在了解Ruby基本语法的前提下，进行学习
</code></pre>
<h2 id="元编程是什么？"><a href="#元编程是什么？" class="headerlink" title="元编程是什么？"></a>元编程是什么？</h2><p>​    元编程是编写能在运行时操作语言构件的代码</p>
<p>​    在我们使用编辑器编写代码后，代码按照我们所写的内容进行编译，运行。在启动后我们无权再对代码进行干涉，而在一些业务场景中，我们想在不修改源代码的前提下，对一个类进行增强，这在Java中也是一个成熟的技术，例如反射，动态代理。但是Java所能给予的操作相比Ruby，就显得格外的严格且复杂。</p>
<p>​    Ruby是一门可以在运行时操作语言构建的工具。语言构建就是我们代码中的各个成员（对象，类，模块儿，实例变量等）。通俗来说可以使用Ruby在运行时对已有的类进行灵活的修改，例如修改一个方法的定义。实例变量的定义，甚至我们可以在运行时创建一个没有的类。下面我们使用一些伪代码来进行演示。</p>
<p>​    我们想对数据库进行操作，最初我们的想法就是写一个Entity基类，然后由子类继承</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Entity</span>
  <span class="token comment"># 提供访问器</span>
	attr_accessor <span class="token symbol">:table</span><span class="token punctuation">,</span><span class="token symbol">:id</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span> table<span class="token punctuation">,</span>id
		<span class="token variable">@table</span> <span class="token operator">=</span> table
		<span class="token variable">@id</span> <span class="token operator">=</span> id
		Database<span class="token punctuation">.</span>sql <span class="token string-literal"><span class="token string">"insert into </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@able</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> 'id' values </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@id</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">&#125;"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">set</span></span><span class="token punctuation">(</span>col<span class="token punctuation">,</span>val<span class="token punctuation">)</span>
		Database<span class="token punctuation">.</span>sql <span class="token string-literal"><span class="token string">"update </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@table</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> set </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">col</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> = </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">val</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> where id = </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@id</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get</span></span><span class="token punctuation">(</span>col<span class="token punctuation">)</span>
		Database<span class="token punctuation">.</span>sql <span class="token string-literal"><span class="token string">"select </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">col</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> from </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@table</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> where id = </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@id</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">Movie</span> <span class="token operator">&lt;</span> Entity
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span> id
		<span class="token keyword">super</span> <span class="token string-literal"><span class="token string">'movies'</span></span><span class="token punctuation">,</span>id
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">title</span></span>
		get <span class="token string-literal"><span class="token string">"title"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">title</span></span><span class="token operator">=</span> value
		set <span class="token string-literal"><span class="token string">"title"</span></span><span class="token punctuation">,</span>value
	<span class="token keyword">end</span>
  
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">article</span></span>
		get <span class="token string-literal"><span class="token string">"article"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">article</span></span><span class="token operator">=</span> value
		set <span class="token string-literal"><span class="token string">"article"</span></span><span class="token punctuation">,</span>value
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># --------------------------------</span>
<span class="token comment"># 插入一条数据，简单且方便</span>
movie <span class="token operator">=</span> <span class="token class-name">Movie</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
movie<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"猫捉老鼠"</span></span>
movie<span class="token punctuation">.</span>article <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"相当不错"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    上面的代码看起来是可以解决问题，但如果一张表的字段特别多，我都需要定义到Movie类中吗？能不能用更少的代码解决问题？我们使用<code>Active Record</code>类库操作：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Movie</span> <span class="token operator">&lt;</span> ActiveRecord<span class="token double-colon punctuation">::</span>Base
<span class="token keyword">end</span>
<span class="token comment"># --------------------------------</span>
<span class="token comment"># 插入一条数据，简单且方便</span>
movie <span class="token operator">=</span> <span class="token class-name">Movie</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
movie<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"猫捉老鼠"</span></span>
movie<span class="token punctuation">.</span>article <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"相当不错"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    我们看到这次在Movie继承<code>ActiveRecord::Base</code>后，没有指定是哪个数据表，没有写SQL，没有定义像上面一样的操作方法，我们就可以轻松插入数据。这底层到底是干了什么？</p>
<p>​    实际上是ActiveRecord在运行期，通过内省机制查看类的名字，通过Movies推断出表名为<code>movies</code>,并在在读取数据表时，发现有title,article两个字段，动态的定义了两个同名的属性和相应的访问器。也是就动态的生成了 <code>Movie#title 和 Movie#title=</code> 这样的方法。</p>
<p>​    这就是Ruby的特点，也是我们要学习的元编程的一种表现形式，我们后面将试着分析和学习它。</p>
<h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><p>​    现在我们有一个需求，将给定的字符串，添加一个后缀，我们可以定义一个函数</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">appendTxt</span></span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> 
	content <span class="token operator">=</span> content <span class="token operator">+</span> <span class="token string-literal"><span class="token string">".txt"</span></span>
<span class="token keyword">end</span>

p appendTxt <span class="token string-literal"><span class="token string">"alibaba"</span></span>  <span class="token comment"># => "alibaba.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    但这不填符合我们面向对象的方法，应该将这个函数封装到一个具体类中，定义它的职责。如果我们因此封装一个<code>ApendTxtString</code>类，会不会导致类太多了，能不能让原本Ruby中的String具有新的行为,答案是可以的。我们可以直接修改Ruby原先定义的标准类。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 这里相当于从新打开String的上下文，添加一个新的方法</span>
<span class="token keyword">class</span> <span class="token class-name">String</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">appendTxt</span></span>
		to_s <span class="token operator">+</span> <span class="token string-literal"><span class="token string">".txt"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span> 
<span class="token comment"># 我们使原先的String具有了新的行为</span>
p <span class="token string-literal"><span class="token string">"alibaba"</span></span><span class="token punctuation">.</span>appendTxt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    class更像是一个作用域操作符，当你第一次使用class时，会判断是否有这个类，如果没有进行创建，如果有则带回到类的上下文中，可以修改以往的方法，实例等等，这带给开发者很大的灵活性。</p>
<p>​    但如果使用不当，也会导致很大的问题，比如原本String拥有appendTxt方法，而很多地方都应用这个函数，而你一旦从新定义，就会导致全局的bug，而且不容易排查，所以使用前一定要检查是否有重名方法。这种简单粗暴的修改在Ruby中也称为：<code>猴子补丁：Monkeypatch</code>，后面我们也有一些其他办法来替代猴子补丁，如<code>细化（Refinement）</code>，来将发生bug的可能降到最低</p>
<h3 id="类的真相"><a href="#类的真相" class="headerlink" title="类的真相"></a>类的真相</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 我们定义了一个类</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
    <span class="token comment"># 定义实例变量</span>
		<span class="token variable">@v</span> <span class="token operator">=</span> <span class="token number">10</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 创建实例</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
<span class="token comment"># 输出当前对象是哪个类的实例</span>
obj<span class="token punctuation">.</span><span class="token keyword">class</span>   <span class="token comment"># => MyClass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    如果可以用Ruby解释器查看obj对象内部，我们可以发现什么？ 内部只有一个@v实例变量，而且仅属于obj对象</p>
<h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">obj<span class="token punctuation">.</span>my_method
p obj<span class="token punctuation">.</span>instance_variables <span class="token comment"># => [:@v]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​    与Java不同，Ruby中对象所属类和对象的实例变量没有任何关系，当你赋值创建一个实例变量时，它就出现了，如果你不使用<code>obj.my_method</code>，这个对象就没有<code>@v</code>这个实例变量</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 查看实例拥有哪些方法，因为每个类实例都是继承了Object类，所以会继承很多的方法</span>
p obj<span class="token punctuation">.</span>methods
<span class="token comment"># 这里用正则筛选一下</span>
p obj<span class="token punctuation">.</span>methods<span class="token punctuation">.</span>grep<span class="token punctuation">(</span><span class="token regex-literal"><span class="token regex">/my/</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    一个对象内部其实只包含了自身的实例变量和对自身类的引用，方法并不在对象中，而在类中。这就是同一类的实例共享方法，但不共享实例变量的原因。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># String实例的方法</span>
p <span class="token builtin">String</span><span class="token punctuation">.</span>instance_methods
<span class="token comment"># String实例方法+类方法</span>
p <span class="token builtin">String</span><span class="token punctuation">.</span>methods
<span class="token comment"># String忽略继承的方法</span>
p <span class="token builtin">String</span><span class="token punctuation">.</span>instance_methods<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    在上面，我们先查看对象拥有的实例方法：<code>obj.instance_methods</code>，后面我们又查看了类的实例方法：<code>String.instance_methods</code>,发现并没有报错，那看来对象和类都拥有自己的实例方法，那能不能推断：<code>类本身也是一个对象</code></p>
<h4 id="类的真相-1"><a href="#类的真相-1" class="headerlink" title="类的真相"></a>类的真相</h4><p>​    在Ruby中类本身其实也是对象，是另一个类的实例。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># String类实际上是Class类的一个实例</span>
p <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token comment"># => Class</span>
<span class="token comment"># 而Class类还是Class的实例</span>
p <span class="token builtin">Class</span><span class="token punctuation">.</span><span class="token keyword">class</span>   <span class="token comment"># => Class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    这确实是挺绕的。不过这么看来一个类所拥有的方法就是Class类的实例方法。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">p <span class="token builtin">Class</span><span class="token punctuation">.</span>instance_methods<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment"># => [:allocate, :superclass, :subclasses, :new]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    这里看到Class的实例方法有四个，其中new是我们最常用的，allocate是new方法的支撑方法，而superclass与我们Java中熟悉的继承有关，找到他的父类是谁？</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">p <span class="token builtin">String</span><span class="token punctuation">.</span>superclass  <span class="token comment"># String的父类：Object</span>
p <span class="token builtin">Object</span><span class="token punctuation">.</span>superclass  <span class="token comment"># Object的父类：BasicObject</span>
p BasicObject<span class="token punctuation">.</span>superclass <span class="token comment"># BasicObject的父类：nil 空  到头了</span>

p <span class="token builtin">Class</span><span class="token punctuation">.</span>superclass   <span class="token comment"># Class的父类是 Module</span>
p <span class="token builtin">Module</span><span class="token punctuation">.</span>superclass  <span class="token comment"># Module的父类是 Object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    可以看到Class是继承了Module，并自身定义了实例化的操作。所以类和模块儿使用上看起来那么像。</p>
<p>​    每个类最终继承于BasicObject，而每个类又是Class类的实例。</p>
<p><img src="../../typora-user-images/image-20230124214842752.png" alt="image-20230124214842752"></p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>​    任何大写字母开头的引用，都代表着常量，而常量一般指不会修改的东西，在Ruby中常亮也可以看做是变量，而当你修改，编译器会发出警告，但仍然会进行修改。常量与变量最大的区别在于作用域的不同。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
  <span class="token comment"># 外部的MyConstant</span>
	MyConstant <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Outer constant"</span></span>
	<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
    <span class="token comment"># 内部的MyConstant</span>
		MyConstant <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Inner constant"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p MyModule<span class="token double-colon punctuation">::</span>MyConstant
p MyModule<span class="token double-colon punctuation">::</span>MyClass<span class="token double-colon punctuation">::</span>MyConstant<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    我们以树形结构为例：</p>
<p><img src="../../typora-user-images/image-20230124220328845.png" alt="image-20230124220328845">    </p>
<p>​    这里内部的MyConstant和外部的MyConstant实际上处于两个作用域中，是完全不同的东西，而我们可以通过<code>::</code>来访问他们</p>
<p>​    如果处于模块儿较深的位置，想用绝对路径来访问外部的常量，可以使用 :: 表示路径的根位置。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token constant">Y</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"a root-level constant"</span></span>
<span class="token keyword">module</span> <span class="token class-name">M</span>
	<span class="token constant">Y</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"a constant in M"</span></span>
	<span class="token double-colon punctuation">::</span><span class="token constant">Y</span>  <span class="token comment"># => "a root-level constant"</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    <code>Module.constants</code>会返回当前范围内所有常量，这里需要注意一点，Module中定义class，其类名也是一个常量。如果想知道当前代码所在路径，则可以知道<code>Module.nesting</code>方法。</p>
<p>​    而我们一般会利用常量域的不同，作为名称空间，这样避免类名冲突</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M</span>
	<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hi</span></span>
			puts <span class="token string-literal"><span class="token string">"hello"</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
mc <span class="token operator">=</span> <span class="token constant">M</span><span class="token double-colon punctuation">::</span><span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
mc<span class="token punctuation">.</span>hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="对象和类的小结"><a href="#对象和类的小结" class="headerlink" title="对象和类的小结"></a>对象和类的小结</h3><blockquote>
<p>什么是对象？</p>
</blockquote>
<p>对象就是一组实例变量外加一个指向其类的引用</p>
<blockquote>
<p>什么是类？</p>
</blockquote>
<p>类就是一个对象（Class类的一个实例），外加一组实例方法和对其超类的引用。</p>
<h3 id="使用名称空间"><a href="#使用名称空间" class="headerlink" title="使用名称空间"></a>使用名称空间</h3><p>​    当我们自定义一个类时，如果在一个复杂系统中，很有可能发生命名冲突，最好使用一个业务模块儿将自定义的类进行封装，这样发生命名冲突的概率也就降低了。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 可能导致bug</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span>
<span class="token keyword">end</span>

<span class="token comment"># 通过 MyField::Test 来使用类，发生冲突的概率就降低了</span>
<span class="token keyword">module</span> <span class="token class-name">MyField</span>
  <span class="token keyword">class</span> <span class="token class-name">Test</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="调用方法时发生了什么？"><a href="#调用方法时发生了什么？" class="headerlink" title="调用方法时发生了什么？"></a>调用方法时发生了什么？</h3><ol>
<li>找到这个方法定义</li>
<li>执行这个方法，Ruby中需要借助<code>self</code>的东西</li>
</ol>
<h4 id="方法查找"><a href="#方法查找" class="headerlink" title="方法查找"></a>方法查找</h4><p>​    这里有两个概念：接收者和祖先链</p>
<p>​    比如说上面的代码 <code>mc.hi()</code> ,其中mc就是方法的接受者，在执行这个方法前需要先找到这个方法的定义，所以先到接收者中去找该方法，如果没有则找他的父类或者是引入的Module中寻找。而接收者，接受者内引入模块儿，父类共同构成了该对象的祖先链。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M1</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">m1_method</span></span>
		<span class="token string-literal"><span class="token string">"m1.method"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">module</span> <span class="token class-name">M2</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">m2_method</span></span>
		<span class="token string-literal"><span class="token string">"m2.method"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 引入M1，模块儿在祖先链中位置为自身类上面</span>
	<span class="token keyword">include</span> <span class="token constant">M1</span>  
	<span class="token comment"># 引入M2，模块儿在祖先链中位置为自身类下面</span>
	<span class="token keyword">prepend</span> <span class="token constant">M2</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">AC</span> <span class="token operator">&lt;</span> MyClass
<span class="token keyword">end</span>

<span class="token comment"># [AC, M2, MyClass, M1, Object, Kernel, BasicObject]</span>
p <span class="token constant">AC</span><span class="token punctuation">.</span>ancestors <span class="token comment"># 查看他的祖先链</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如果在祖先链中多次引入一个module，会怎么样？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M1</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
p <span class="token constant">M1</span><span class="token punctuation">.</span>ancestors  <span class="token comment"># => [M1]</span>
<span class="token keyword">module</span> <span class="token class-name">M2</span>
	<span class="token keyword">include</span> <span class="token constant">M1</span>
<span class="token keyword">end</span>
p <span class="token constant">M2</span><span class="token punctuation">.</span>ancestors  <span class="token comment"># => [M2, M1]</span>
<span class="token keyword">module</span> <span class="token class-name">M3</span>
	<span class="token keyword">prepend</span> <span class="token constant">M1</span>
	<span class="token keyword">include</span> <span class="token constant">M2</span>
<span class="token keyword">end</span>
p <span class="token constant">M3</span><span class="token punctuation">.</span>ancestors  <span class="token comment"># => [M1, M3, M2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Kernel模块儿"><a href="#Kernel模块儿" class="headerlink" title="Kernel模块儿"></a>Kernel模块儿</h4><p>​    在Ruby中我们常常使用<code>print</code>，就好像所有对象都有print方法一样。但实际上这些方法来着<code>Kernel</code>模块儿私有实例方法，因为Object引入了Kernel，所以每个对象都可以调用Kernel方法，也叫做内核方法，我们当然也可以加入自己的方法，这样所有的对象都拥有了新的方法 </p>
<h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><blockquote>
<p>当我们找到了该方法，如何去执行呢？</p>
</blockquote>
<p>比如我们现在找到了该方法：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span>
		<span class="token variable">@x</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
	  p <span class="token keyword">self</span>   <span class="token comment"># => #&lt;MyClass:0x000000010dcdb320 @x=1> self为obj</span>
	  temp <span class="token operator">=</span> <span class="token variable">@x</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 这里实例变量@x 也是访问self内定义的</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>my_method  <span class="token comment"># obj调用my_method时，obj为当前对象self</span>
p <span class="token keyword">self</span>         <span class="token comment"># => main , 在顶级作用域下，调用 p ,接受者为main对象，main为self</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>请问：@x是属于哪个对象的，my_method属于哪个对象？</p>
</blockquote>
<p>​    一般情况下，会将最初方法的接收者作为当前对象，也就是作为self，所有实例变量和方法都属于self，如果没有明确指定接受者的实际上都指向self，除非转而调用其他对象的方法，则self就会转为这个对象。</p>
<blockquote>
<p>​    Ruby中 private 修饰的方法，不能明确指定接受者来调用私有方法，只能通过隐性的接受者self调用。这与Java中对私有方法的定义是不同的</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hi</span></span>
		p <span class="token string-literal"><span class="token string">"Hi "</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">Hello</span></span>
		<span class="token comment"># 这里Hello 调用 私有方法hello ，使用的隐藏当前对象,也就是下面的obj</span>
		hello
	<span class="token keyword">end</span>

	<span class="token keyword">private</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hello</span></span> 
		p <span class="token string-literal"><span class="token string">"hello"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>hi     <span class="token comment"># 正常调用</span>
obj<span class="token punctuation">.</span>Hello  <span class="token comment"># 正常调用</span>
obj<span class="token punctuation">.</span>hello  <span class="token comment"># 无法调用，因为private方法不能指定接收者调用，只能隐性调用，也就是内部调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="顶层上下文"><a href="#顶层上下文" class="headerlink" title="顶层上下文"></a>顶层上下文</h4><blockquote>
<p>如果没有调用任何方法，那这时谁是self呢？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># main</span>
p <span class="token keyword">self</span>
<span class="token comment"># Object</span>
p <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token keyword">class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Ruby程序运行时，Ruby解释器创建一个名为main对象作为当前对象，这个对象有时被称为顶层上下文。此时处于调用堆栈的顶层</p>
<h3 id="类定于与self"><a href="#类定于与self" class="headerlink" title="类定于与self"></a>类定于与self</h3><p>​    在定义类或模块儿时（且在任何方法定义之外），self对象由这个类或模块儿本身担任</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
  <span class="token keyword">self</span>  <span class="token comment"># => MyClass</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="细化"><a href="#细化" class="headerlink" title="细化"></a>细化</h4><p>​    在前面我们使用了猴子补丁对原有的类进行修改，但这一操作是全局性的，如果把控不好，会导致许多隐性的Bug，所以Ruby又引入了<code>细化(refinement)</code>,起到同样的作用，但是可以限制作用域。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">StringAppend</span>
  <span class="token comment"># 细化 String 标准类库，传入一个Block</span>
	refine <span class="token builtin">String</span> <span class="token keyword">do</span>
    <span class="token comment"># 在Block内，定义一个append_txt方法，现在self转为String，相当于给String定义实例方法</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">append_txt</span></span>
			to_s <span class="token operator">+</span> <span class="token string-literal"><span class="token string">".txt"</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">module</span> <span class="token class-name">StringStuff</span>
	<span class="token comment"># 上面定义好，并未生效，需要主动启动 using</span>
	using StringAppend
	<span class="token comment"># 这里正常执行</span>
	p <span class="token string-literal"><span class="token string">"alibaba"</span></span><span class="token punctuation">.</span>append_txt
<span class="token keyword">end</span>
<span class="token comment"># 这里就会报错，因为跳回了顶层上下文，这里没有引入对String细化，</span>
<span class="token comment"># 所以通过细化，可以控制修改的访问范围，不会使全局都看到这个修改</span>
p <span class="token string-literal"><span class="token string">"taobao"</span></span><span class="token punctuation">.</span>append_txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    细化只在两种场合有效：</p>
<ol>
<li><code>refine</code>代码块内部</li>
<li><code>using</code>语句位置到模块儿结束，或者到文件结束（在顶层上下文使用using）</li>
</ol>
<h5 id="细化的陷阱"><a href="#细化的陷阱" class="headerlink" title="细化的陷阱"></a>细化的陷阱</h5><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		p <span class="token string-literal"><span class="token string">"old method"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">other_method</span></span>
		my_method
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">module</span> <span class="token class-name">MyClassRefinement</span>
	refine MyClass <span class="token keyword">do</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
			p <span class="token string-literal"><span class="token string">"new method"</span></span>
		<span class="token keyword">end</span>	
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token comment"># 在顶级上下文中使用using</span>
using MyClassRefinement

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
<span class="token comment"># 这里已经更新为细化后修改的内容</span>
obj<span class="token punctuation">.</span>my_method  <span class="token comment"># => new method</span>
<span class="token comment"># 这里仍维持原先的内容</span>
obj<span class="token punctuation">.</span>other_method <span class="token comment"># => old method</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里虽然使用了细化，但当其他实例方法调用细化方法，还是会调用之前定义的代码，如果直接调用细化方法，则修改为细化内容。需要注意：Ruby规定虽然可以在一个普通的模块儿中调用refine方法，但不能在类中调用这个方法</p>
<h3 id="对象模型总结"><a href="#对象模型总结" class="headerlink" title="对象模型总结"></a>对象模型总结</h3><ul>
<li>对象由一组实例变量和类的引用组成</li>
<li>对象的方法存在于对象所属的类中（对类来说是实例方法）</li>
<li>类本身是Class类的对象，类的名字只是一个常量</li>
<li>Class类是Module的子类，一个模块儿基本上就是由一组方法组成的包，类除了具有模块儿的特性以外，还可以被实例化（使用new方法），或者按照一定的层次结构来组织（使用superclass方法）</li>
<li>常量像文件系统一样，是按照树形结构组织的，其中模块儿和类的名字扮演目录的校色，其他普通常量扮演文件的校色</li>
<li>每个类都有一个祖先链，这个链从每个类自己开始（pretend Module会在类本身之前），向上直到BasicObject类结束</li>
<li>调用方法时，Ruby首先向右找到接受者所属的类，然后向上查找祖先链，直到找到该方法或达到链的顶端</li>
<li>在类中包含一个模块儿，使用<code>include</code>方法时，模块插入祖先链中，位置在类的正上方，使用prepend方法包含一个模块儿时，这个模块儿也会被插入祖先链中，位置在类的正下方</li>
<li>调用一个方法时，接受者会扮演self的对象</li>
<li>定义一个模块儿（或类）时，该模块儿扮演self对象</li>
<li>实例变量永远被认定为self的实例变量</li>
<li>没有明确指定接收者的方法调用，都被当做是调用self的方法</li>
<li>细化像是在原有的类上添加了一块儿补丁，并且会覆盖正常方法的方法查找，并且细化只在部分区域生效。 </li>
</ul>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>​    在Ruby这种动态语言中，方法的调用是极为灵活的，并不会在编译器就爆出各种错误，比方说我定义一个User类，我想调用hi方法，我并没有定义hi方法，但这并不妨碍我编写代码，运行期我去找hi方法，如果发现没有这个方法，最终我可以向这个类中添加我想要的方法在运行期间。这给了我们更多的操作空间，这将是我们要学习的。</p>
<blockquote>
<p>现在我们有一个老的系统需要我们重构，老板要求系统自动为超过99美金的开销天添加标记</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">DS</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span> <span class="token punctuation">;</span> <span class="token keyword">end</span><span class="token comment"># 连接数据源</span>

  <span class="token comment"># 原先设计的访问方法</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_cpu_info</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_cpu_price</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_mouse_info</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_mouse_price</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_keyBoard_info</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_keyBoard_price</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
<span class="token keyword">end</span>
ds <span class="token operator">=</span> <span class="token class-name">DS</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 获取信息</span>
ds<span class="token punctuation">.</span>get_cpu_info<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment"># 获取价格</span>
ds<span class="token punctuation">.</span>get_cpu_price<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们现在需要将数据源封装起来，每个computer为一个对象，并为每个组件定义通用的方法</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
  <span class="token comment"># data_source 就是上面的DS对象</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">mouse</span></span>
		info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>get_mouse_info<span class="token punctuation">(</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>get_mouse_price<span class="token punctuation">(</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Mouse: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">cpu</span></span>
		info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>get_cpu_info<span class="token punctuation">(</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>get_cpu_price<span class="token punctuation">(</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Cpu: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">end</span>

	<span class="token comment"># ... 类似操作</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    我们可以看到 mouse 和 cpu 就有大量的代码重复，如果后面还需要加其他的，则会让代码臃肿且冗余。</p>
<p>​    我们有两种办法进行重构优化：<code>动态方法 和 method_missing</code></p>
<h3 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h3><h4 id="动态调用方法"><a href="#动态调用方法" class="headerlink" title="动态调用方法"></a>动态调用方法</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method</span></span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>method <span class="token string-literal"><span class="token string">"Hello World"</span></span>
<span class="token comment"># 动态派发和上面普通调用的结果是一样的, 将 obj.method 替换为 obj.send(:method)</span>
obj<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token symbol">:method</span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"Hello World"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>为什么使用动态派发？</p>
</blockquote>
<p>​    因为可以在运行最后才决定具体调用哪个方法。而不是硬编码决定</p>
<blockquote>
<p>这里使用<code>:method</code>，而不是”method”，实际上是一样的</p>
</blockquote>
<p><code>obj.send(&quot;method&quot;,&quot;Hello World&quot;)</code></p>
<p>​    :method 表示的是一个Symbol符号</p>
<p>​    “method”则是一个String字符串，一般在元编程我们常常使用Symbol，因为Symbol是不可变的。字符串是可变的。</p>
<blockquote>
<p>符号与字符串是很容易相互转化的</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token string-literal"><span class="token string">"abc"</span></span><span class="token punctuation">.</span>to_sym <span class="token comment"># => :abc</span>
<span class="token symbol">:abc</span><span class="token punctuation">.</span>to_s    <span class="token comment"># => "abc"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="动态定义方法"><a href="#动态定义方法" class="headerlink" title="动态定义方法"></a>动态定义方法</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 这里就是定义了一个实例方法 将 def my_method 替换为 define_method :my_method，参数部分，通过Block传递</span>
	<span class="token keyword">define_method</span> <span class="token symbol">:my_method</span> <span class="token keyword">do</span> <span class="token operator">|</span>my_arg<span class="token operator">|</span>
		my_arg <span class="token operator">*</span> <span class="token number">3</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obj<span class="token punctuation">.</span>my_method <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    在运行时定义方法的技术称为<strong>动态方法</strong>。<code>Module#define_method</code></p>
<blockquote>
<p>为什么使用动态方法，而不是直接定义：def</p>
</blockquote>
<p>​    因为这样可以在运行最后决定方法名叫什么，和上面动态调用方法类似，我们想在运行期间再决定一些事情</p>
<h4 id="重构Computer类"><a href="#重构Computer类" class="headerlink" title="重构Computer类"></a>重构Computer类</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">mouse</span></span>
		companent <span class="token symbol">:mouse</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">cpu</span></span>
		companent <span class="token symbol">:cpu</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">companent</span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    <span class="token comment"># 这里使用了动态调用方法</span>
		info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_price"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">end</span>
	<span class="token comment"># ... 类似操作</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    我们使用动态派发的方式，抽离出一个公共组件，其他配件可以直接使用，代码量减少的多</p>
<p>​    我们再用<strong>动态定义方法</strong>去试着重构一下代码    </p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
	<span class="token keyword">end</span>

	<span class="token comment"># 这里定义一个类方法，这里的self指向的是Computer类常量</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">define_companent</span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> 
		<span class="token comment"># 根据传入的Symbol，创建相应的方法</span>
		<span class="token keyword">define_method</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">do</span>
			info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
			price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_price"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
			result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
			result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
			<span class="token keyword">return</span> result
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
	<span class="token comment">## 这里主动调用 并动态创建对应的方法</span>
	define_companent <span class="token symbol">:mouse</span>
	define_companent <span class="token symbol">:cpu</span>
	define_companent <span class="token symbol">:keyboard</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>现在Computer已经剩不了多少代码了，我们使用内省方式缩减代码</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
    <span class="token comment"># 主动根据DS中给定的访问方法，创建访问方法，而不需要我们再去手动控制</span>
		data_source<span class="token punctuation">.</span>methods<span class="token punctuation">.</span>grep<span class="token punctuation">(</span><span class="token operator">/</span><span class="token operator">^</span>get_<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span>_info$<span class="token operator">/</span> <span class="token operator">|</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment"># 被正则表达式匹配到的方法，会依次调用这里传递的块儿，并将内容封装到 $1 全局变量中</span>
			Computer<span class="token punctuation">.</span>define_companent $<span class="token number">1</span>
		<span class="token punctuation">&#125;</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">define_companent</span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
		<span class="token keyword">define_method</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">do</span>
			info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
			price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_price"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
			result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
			result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
			<span class="token keyword">return</span> result
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    我们在初始化方法中加入几场代码就可以让代码更加简洁。</p>
<h3 id="method-missing方法"><a href="#method-missing方法" class="headerlink" title="method_missing方法"></a>method_missing方法</h3><blockquote>
<p>你将学习幽灵方法和动态代理</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">User</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method_missing</span></span><span class="token punctuation">(</span>method<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
		puts <span class="token string-literal"><span class="token string">"You called: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">method</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">args<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">','</span></span><span class="token punctuation">)</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
    puts <span class="token string-literal"><span class="token string">"(You alse passed it a block)"</span></span> <span class="token keyword">if</span> block_given<span class="token operator">?</span>
    
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obj<span class="token punctuation">.</span>hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    在Ruby中我们可以随意调用一个方法，而这个方法可能根本不存在，当运行时在当前对象的继承链上都没有找到这个方法时，会去找当前对象的 method_missing 方法，它就好像每个无家可归的人最终的点，method_missing是<code>BasicObject</code>中定义的私有实例方法，所以每个子类都可以使用这个方法，而BasicObject中是直接抛出这个异常，所以需要我们自己去重写。<code>method_missing</code>也叫做幽灵方法。</p>
<blockquote>
<p>现在我们通过method_missing来重构我们的Computer类</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
	<span class="token keyword">end</span>
	<span class="token comment"># name 为 调用的方法名，args 表示参数 ，*表示接受所有的参数,封装为一个数组</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method_miss</span></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
		<span class="token comment"># 判断@data_source是否有这个方法？如果没有则调用super.method_miss,也就是未找到该方法</span>
		<span class="token keyword">super</span> <span class="token keyword">if</span> <span class="token operator">!</span><span class="token variable">@data_source</span><span class="token punctuation">.</span>respond_to<span class="token operator">?</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">)</span>
		<span class="token comment"># 如果有这个方法</span>
		info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_price"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    现在发现我们不需要再定义额外的方法了，直接通过幽灵方法来做判断与返回，这里方法：<code>respond_to?</code>表示该实例是否有目标方法，</p>
<p>​    如果方法返回值为Boolean，一般会在方法名定义时使用<code>?</code>,如：<code>def is_black?()</code>表示。</p>
<h4 id="respond-to-missing方法"><a href="#respond-to-missing方法" class="headerlink" title="respond_to_missing方法"></a>respond_to_missing方法</h4><blockquote>
<p>如何问Computer对象是否响应幽灵方法？ </p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">cmp <span class="token operator">=</span> <span class="token class-name">Computer</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token class-name">DS</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">)</span>
cmp<span class="token punctuation">.</span>respond_to<span class="token operator">?</span><span class="token punctuation">(</span><span class="token symbol">:mouse</span><span class="token punctuation">)</span>   <span class="token comment"># => false </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​    无法响应到，因为 :mouse是一个幽灵方法，我们需要重新定义<code>respond_to_missing()</code></p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">respond_to_missing</span></span><span class="token operator">?</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span>include_private<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token variable">@data_source</span><span class="token punctuation">.</span>respond_to<span class="token operator">?</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">method</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">super</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

cmp <span class="token operator">=</span> <span class="token class-name">Computer</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token class-name">DS</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">)</span>
cmp<span class="token punctuation">.</span>respond_to<span class="token operator">?</span><span class="token punctuation">(</span><span class="token symbol">:mouse</span><span class="token punctuation">)</span>   <span class="token comment"># => true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    所以正确的做法是每次覆写<code>method_missing</code>时，同时也覆写<code>respond_to_missing?</code>方法</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>​    通常，幽灵方法都是锦上添花的左右，不过有些对象的功能，几乎完全依赖于他，这些对象通常是一些封装对象，他们封装的可以是另一个对象，web服务或者其他语言写成的代码，这些对象通过method_missing方法收集方法调用，并把这些调用转发到被封装的对象上</p>
<h4 id="const-missing方法"><a href="#const-missing方法" class="headerlink" title="const_missing方法"></a>const_missing方法</h4><p>​    如果对于一个常量的引用发现找不到，则会默认调用<code>const_missing</code>方法，将常量名作为一个符号进行传递。</p>
<p>​    在Rake中就有使用，为了兼容老版本的Task和新版本的Rake::Task。 </p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">Rake</span>
  <span class="token keyword">class</span> <span class="token class-name">Task</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
  <span class="token keyword">class</span> <span class="token class-name">FileTask</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">Module</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">const_missing</span></span><span class="token punctuation">(</span>const_name<span class="token punctuation">)</span>
    <span class="token keyword">case</span> const_name
    <span class="token keyword">when</span> <span class="token symbol">:Task</span>
      p <span class="token string-literal"><span class="token string">"提示：原有的Task，已经移入，Rake名称空间，请使用 Rake::Task"</span></span>
      Rake<span class="token double-colon punctuation">::</span>Task
    <span class="token keyword">when</span> <span class="token symbol">:FileTask</span>
      p <span class="token string-literal"><span class="token string">"提示：原有的Task，已经移入，Rake名称空间，请使用 Rake::FileTask"</span></span>
      Rake<span class="token double-colon punctuation">::</span>FileTask
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># main是Object的实例，Object是Class的实例，Class的父类是Module，所以当我们使用猴子补丁修改</span>
<span class="token comment"># Module#const_missing时，main对象是继承到这个方法的。</span>
<span class="token comment"># 我们想要访问Task常量，发现并不存在，则触发了const_missing(const_name)</span>
p <span class="token class-name">Task</span><span class="token punctuation">.</span><span class="token keyword">new</span>
p <span class="token class-name">FileTask</span><span class="token punctuation">.</span><span class="token keyword">new</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="method-missing隐藏Bug"><a href="#method-missing隐藏Bug" class="headerlink" title="method_missing隐藏Bug"></a>method_missing隐藏Bug</h4><blockquote>
<p>我们设计一个按照人名，抽号码的小程序</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Roulette</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method_missing</span></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
		person <span class="token operator">=</span> name<span class="token punctuation">.</span>to_s<span class="token punctuation">.</span>capitalize
		<span class="token number">3.</span>times <span class="token keyword">do</span>
      <span class="token comment"># 这里在块儿内定义了number</span>
			number <span class="token operator">=</span> rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
			puts <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">number</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">..."</span></span>
		<span class="token keyword">end</span>
    <span class="token comment"># 这里又使用了number，因为作用域的不同，运行时找不到这个变量，所以默认会找 number这个方法，因为也没有这个方法，所以调用了method_missing方法，导致不断的重入</span>
		<span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> got </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">number</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
number_of <span class="token operator">=</span> <span class="token class-name">Roulette</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
p number_of<span class="token punctuation">.</span>bob	
p number_of<span class="token punctuation">.</span>Jack	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>不知道你是否可以看出来？当程序运行时会不断方法重入，直到栈溢出。所以我们需要进行改良。</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Roulette</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method_missing</span></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
		person <span class="token operator">=</span> name<span class="token punctuation">.</span>to_s<span class="token punctuation">.</span>capitalize
		<span class="token comment"># 判断是否名字是否存在，如果不存在，直接报错</span>
		<span class="token keyword">super</span> <span class="token keyword">unless</span> <span class="token string-literal"><span class="token string">%w[Bob Frank Bill]</span></span><span class="token punctuation">.</span><span class="token keyword">include</span><span class="token operator">?</span> person
    <span class="token comment"># 将局部变量作用域移出</span>
		number <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token number">3.</span>times <span class="token keyword">do</span>
			number <span class="token operator">=</span> rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
			puts <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">number</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">..."</span></span>
		<span class="token keyword">end</span>
		<span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> got </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">number</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
number_of <span class="token operator">=</span> <span class="token class-name">Roulette</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
p number_of<span class="token punctuation">.</span>Bob	
p number_of<span class="token punctuation">.</span>Frank	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="白板类"><a href="#白板类" class="headerlink" title="白板类"></a>白板类</h3><blockquote>
<p>​    比如说上面的 number_of.display 我们希望实际调用 method_missing 方法，但实际上可能调用了Object.display方法，这是因为我们从Object类中继承了大量的方法，所以时常导致<strong>幽灵方法与继承方法的重复</strong>。</p>
</blockquote>
<p>​    如果实例存在继承方法，则幽灵方法是失效的。我们有两个办法：</p>
<ol>
<li>删除继承来的方法</li>
<li>写一个白板类，也就是很干净了的类，没有继承的方法</li>
</ol>
<h4 id="白班类-：-BasicObject"><a href="#白班类-：-BasicObject" class="headerlink" title="白班类 ： BasicObject"></a>白班类 ： BasicObject</h4><p>​    BasicObject是Object的父类，其中定义的实例方法很少，所以我们可以让现有的类继承BasicObject，从而可以避免继承Object类的方法，这是最简单的白板类实现方法</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># [:__send__, :!, :instance_eval, :==, :instance_exec, :!=, :equal?, :__id__]</span>
p BasicObject<span class="token punctuation">.</span>instance_methods<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><ol>
<li>Module#undef_method  删除所有的方法，包括继承的</li>
<li>Module#remove_method 只删除接受者自己的方法</li>
</ol>
<p>所以我们最终可以选择让<code>Roulette 继承 BasicObject</code>，或者删除指定方法</p>
<h4 id="对比动态方法与幽灵方法"><a href="#对比动态方法与幽灵方法" class="headerlink" title="对比动态方法与幽灵方法"></a>对比动态方法与幽灵方法</h4><p>​    幽灵方法更容易出现隐性Bug，所以能使用动态方法，尽量使用动态方法，除非不得不使用时，才去使用，记住如果重写 response_to? ，也要重新 response_to_missing?</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><blockquote>
<p>学习路线</p>
</blockquote>
<ul>
<li>代码块的基础知识</li>
<li>作用域的基础知识：用代码块携带变量穿越作用域</li>
<li>通过传递块给<code>instance_eval</code>方法来控制作用域</li>
<li>怎么把块转换为Proc和Lambda这样的可调用对象，供以后调用</li>
</ul>
<h3 id="代码块基础知识"><a href="#代码块基础知识" class="headerlink" title="代码块基础知识"></a>代码块基础知识</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">a_method</span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> 
  a<span class="token operator">+</span> <span class="token keyword">yield</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>
<span class="token keyword">end</span>
a_method<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">|</span>x<span class="token punctuation">,</span>y<span class="token operator">|</span> <span class="token punctuation">(</span>x<span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    代码块可以用大括号定义，也可以使用<code>do...end</code>关键字定义，通常如果一行的块使用大括号，而多行的块使用<code>do...end</code></p>
<p>​    块可以有自己的参数，比如上面的例子中的x和y，可以像调用方法那样为块提供参数，</p>
<p>​    可以通过<code>Kernel#block_given?</code>查看是否传达快，如果没有，调用yield则会报错</p>
<h3 id="代码块是闭包"><a href="#代码块是闭包" class="headerlink" title="代码块是闭包"></a>代码块是闭包</h3><blockquote>
<p>代码块可以把变量带出原来的作用域</p>
<p>代码块不能孤立的运行，它需要一个执行环境：局部变量，实例变量，self等</p>
<p>可以运行的代码由两部分组成：代码本身  和   一组绑定</p>
<p>当我们定义一个block时，它将获取到环境中的绑定，当block被传给一个方法时，他会带着这些绑定一起进入该方法</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
  x <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Good"</span></span>
  <span class="token keyword">yield</span> <span class="token string-literal"><span class="token string">"cruel"</span></span>
<span class="token keyword">end</span>

x <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Bad"</span></span>
my_method <span class="token punctuation">&#123;</span><span class="token operator">|</span>y<span class="token operator">|</span> p <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">x</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> , </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">y</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> World"</span></span><span class="token punctuation">&#125;</span>  <span class="token comment"># => "Bad , cruel World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里我们调用my_method时，创建了一个block，并获取顶层上下文中的x变量，而my_method中定义的x变量对于block是不可见的，也可以在block中定义额外的绑定，但这些绑定在block结束时就消失了。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">just_yield</span></span>
  <span class="token keyword">yield</span>
<span class="token keyword">end</span>

top_leval_var <span class="token operator">=</span> <span class="token number">1</span>

just_yield <span class="token keyword">do</span>
  top_leval_var <span class="token operator">+=</span> <span class="token number">1</span>
  local_to_block <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">end</span>

p top_leval_var     <span class="token comment"># => 2</span>
p local_to_block    <span class="token comment"># => error!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    基于这些特性，人们喜欢把代码块称为<strong>闭包</strong>，换句话说：代码块可以获取局部绑定，并一直带着他们</p>
<blockquote>
<p>如何使用闭包呢？</p>
</blockquote>
<p>​    这里我们需要了解绑定寄居的地方——作用域，需要判断程序在哪里切换了作用域，作用域的作用有哪些？</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>​    不论是Java，Python，Ruby都会有作用域的概念，就好像是单独的一个作用空间，一个领地，在这里有专属的局部变量</p>
<h3 id="切换作用域"><a href="#切换作用域" class="headerlink" title="切换作用域"></a>切换作用域</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">v1 <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 顶层作用域</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>  <span class="token comment"># 类作用域</span>
	v2 <span class="token operator">=</span> <span class="token number">2</span>
	p local_variables  <span class="token comment"># => [:v2]</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>  <span class="token comment"># 方法作用域</span>
		v3 <span class="token operator">=</span> <span class="token number">3</span>
		p local_variables  <span class="token comment"># => [:v3]</span>
	<span class="token keyword">end</span>
	p local_variables  <span class="token comment"># => [:v2]</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obj<span class="token punctuation">.</span>my_method
obj<span class="token punctuation">.</span>my_method
p local_variables  <span class="token comment"># => [:v1, :obj]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最初在顶层作用域 定义 v1 = 1</p>
<p>定义class MyClass，切换作用域，一旦切换作用域，绑定也会修改，v1对于MyClass内部域是不可见的，在其内部定义了一个方法和变量，当执行到实例方法内部，作用域再次切换</p>
<p>当MyClass定义完毕，再次切换回顶级作用域。</p>
<blockquote>
<p>全局变量与顶级实例变量</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token variable">$var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">incre</span></span>
		<span class="token variable">$var</span> <span class="token operator">+=</span> <span class="token number">1</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p <span class="token variable">$var</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obj<span class="token punctuation">.</span>incre
p <span class="token variable">$var</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里定义了全局变量var，发现在所有作用域都可以访问并操作到，所以一旦出现问题，很难排查。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token variable">@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
	<span class="token variable">@var</span> <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">end</span>
p <span class="token variable">@var</span>
my_method
p <span class="token variable">@var</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里定义一个顶级上下文中的实例变量，当main对象扮演self的角色，就可以访问到顶级实例变量，但如果进入其他对象作为self，则无法访问到</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token variable">@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
    <span class="token variable">@var</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"this is not top level @var"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span> 
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
p obj<span class="token punctuation">.</span>my_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>顶级实例变量 要比 全局变量 有限的安全</p>
<p>这里我们想弄清楚作用域是如何切换，绑定是如何切换的，需要了解作用域门</p>
<h3 id="作用域门"><a href="#作用域门" class="headerlink" title="作用域门"></a>作用域门</h3><p>程序一般会在三个地方，关闭之前的作用域，打开新的作用域，分别为：</p>
<ol>
<li>方法 def</li>
<li>类定义 class</li>
<li>模块儿定义 module</li>
</ol>
<p>每个关键字对应一个作用域门，各个作用域中的变量相互隔离</p>
<blockquote>
<p>现在看到每个作用域有独立的空间，如果想要变量在作用域之间传递，该如何操作？</p>
</blockquote>
<h3 id="扁平化作用域"><a href="#扁平化作用域" class="headerlink" title="扁平化作用域"></a>扁平化作用域</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">var <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Success"</span></span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 这里想访问到var</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		<span class="token comment"># 这里想访问到var</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p> 一旦切换作用域局部变量就会失效，如何能让var穿越两个作用域被访问到？</p>
</blockquote>
<p>Ruby是非常灵活的，它为一种实现提供了多种方法，上面知道了<code>class module def</code>三个关键字为作用域门，那我们使用其他方式来实现相同的结果，这样就可以避免切换作用域了</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">var <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Success"</span></span>
<span class="token comment"># 使用Class.new 切换 class关键字，避免切换作用域</span>
MyClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token keyword">do</span> 
	p var
  <span class="token comment"># 使用动态定义方法，替换def关键字，避免切换作用域</span>
	<span class="token keyword">define_method</span> <span class="token symbol">:my_method</span> <span class="token keyword">do</span>
		p var
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obg <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obg<span class="token punctuation">.</span>my_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    如果两个作用域挤压在一起，我们通常简称为 扁平作用域</p>
<h3 id="共享作用域"><a href="#共享作用域" class="headerlink" title="共享作用域"></a>共享作用域</h3><blockquote>
<p>​    如果想在一组方法之间共享一个变量，但又不想别的方法访问到这个变量，就可以把这些方法定义在该变量所在的扁平作用域</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
  <span class="token comment"># 这里是一个局部变量，希望仅被几个方法访问到</span>
	share <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment"># 使用内核方法，调用 define_method 来定义函数，而又不用切换域，这样这几个方法就可以访问到变量</span>
  <span class="token comment"># 也可以只用 define_method :counter do</span>
	Kernel<span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:counter</span> <span class="token keyword">do</span>
		share
	<span class="token keyword">end</span>
	Kernel<span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:inc</span> <span class="token keyword">do</span> <span class="token operator">|</span>x<span class="token operator">|</span>
		share <span class="token operator">+=</span> x
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">other_method</span></span>
  <span class="token comment"># 这里则无法再访问到share</span>
  share
<span class="token keyword">end</span>
my_method
p counter   <span class="token comment"># => 0</span>
inc <span class="token number">4</span>
p counter   <span class="token comment"># => 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="上下文探针（instance-eval）"><a href="#上下文探针（instance-eval）" class="headerlink" title="上下文探针（instance_eval）"></a>上下文探针（instance_eval）</h3><p>这里我们学习一个新的方法：<code>BasicObject#instance_eval</code>,它在一个对象的上下文中执行block，运行时，代码块的接收者将会成为self</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span>
		<span class="token variable">@v</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 这里self切换为obj</span>
obj<span class="token punctuation">.</span>instance_eval <span class="token keyword">do</span>
	p <span class="token keyword">self</span>
  <span class="token comment"># 输出的实例变量也是属于self的</span>
	p <span class="token variable">@v</span>
<span class="token keyword">end</span>
<span class="token comment"># 上下文探针结束后，self又变回了 main </span>
<span class="token comment"># 这里 下面三行代码都处在扁平作用域，所以Block可以使用局部变量v，并访问到obj中的实例变量</span>
v <span class="token operator">=</span> <span class="token number">2</span>
obj<span class="token punctuation">.</span>instance_eval <span class="token punctuation">&#123;</span><span class="token variable">@v</span> <span class="token operator">=</span> v<span class="token punctuation">&#125;</span>
obj<span class="token punctuation">.</span>instance_eval <span class="token punctuation">&#123;</span>p <span class="token variable">@v</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>这里需要注意一个点：instance_eval会将接收者变为当前对象self。而调用者的<strong>实例变量</strong>就落在作用域范围外，如果不了解，就会出现Bug，例如：</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">C</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span>
		<span class="token variable">@x</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">D</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">twisted_method</span></span>
    <span class="token comment"># 如果这里 @y 改为 y ，即可被访问到</span>
		<span class="token variable">@y</span> <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token comment"># 在执行下面代码之前，self为D.new，一旦执行下面的代码，C.new为self，@x在C.new中定义了，@y则没有</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>instance_eval <span class="token punctuation">&#123;</span><span class="token string-literal"><span class="token string">"@x : </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@x</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> , @y : </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@y</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">&#125;</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p <span class="token class-name">D</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>twisted_method  <span class="token comment"># => "@x : 1 , @y : "</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    这里输出发现，@y并未访问到， 可是上面的调用代码在同一个扁平作用域，原来是因为instance_eval将C.new对象变为当前对象self，调用者的实例变量就落在了作用域外了，所以访问不到为：nil。</p>
<blockquote>
<p>这里使用 instance_exec 来解决传递参数的问题</p>
</blockquote>
<h4 id="instance-exec"><a href="#instance-exec" class="headerlink" title="instance_exec"></a>instance_exec</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">D</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">twisted_method</span></span>
		<span class="token variable">@y</span> <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token comment"># 这里主动将 @y传递到块儿中</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>instance_exec<span class="token punctuation">(</span><span class="token variable">@y</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">|</span>y<span class="token operator">|</span><span class="token string-literal"><span class="token string">"@x : </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@x</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> , @y : </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">y</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">&#125;</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="洁净室"><a href="#洁净室" class="headerlink" title="洁净室"></a>洁净室</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">CleanRoom</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">current_temp</span></span>
    <span class="token number">18</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
clean_room <span class="token operator">=</span> <span class="token class-name">CleanRoom</span><span class="token punctuation">.</span><span class="token keyword">new</span>
clean_room<span class="token punctuation">.</span>instance_eval <span class="token keyword">do</span>
  <span class="token keyword">if</span> current_temp <span class="token operator">&lt;</span> <span class="token number">20</span>
    p <span class="token string-literal"><span class="token string">"wear a jacket"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    洁净室只是一个用来执行块的环境，它提供若干有用的方法供代码块调用，比如本例中的<code>current_temperature</code>方法，然而一个理想的洁净室应该是没有实例变量和方法的，因为这可能与block从环境中带来的名字冲突，因此BasicObject的实例往往用来充当洁净室，因为它是白板类，几乎没什么方法。</p>
<h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><p>​    目前我们使用的Block是直接执行的，我们需要让Block变为对象，可以进行打包传递，调用，我们看一下有哪些打包代码的方式。</p>
<ol>
<li>proc , 将Block转为Proc对象</li>
<li>lambda ，属于proc的变种</li>
<li>使用方法</li>
</ol>
<h4 id="Proc对象"><a href="#Proc对象" class="headerlink" title="Proc对象"></a>Proc对象</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 将Block打包为Proc</span>
inc <span class="token operator">=</span> <span class="token class-name">Proc</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">&#123;</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
<span class="token comment"># 主动调用Block</span>
p inc<span class="token punctuation">.</span>call <span class="token number">2</span>

inc_ <span class="token operator">=</span> proc <span class="token punctuation">&#123;</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
p inc<span class="token punctuation">.</span>call <span class="token number">2</span>

obj <span class="token operator">=</span> lambda <span class="token punctuation">&#123;</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
p obj<span class="token punctuation">.</span>call <span class="token number">2</span>

obj_ <span class="token operator">=</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
p obj_<span class="token punctuation">.</span>call <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="amp-操作符"><a href="#amp-操作符" class="headerlink" title="&amp;操作符"></a>&amp;操作符</h4><p>​    在调用方法时，我们为其传递一个Block，可通过yield进行执行，但是如果我们想将这个Block封装起来，延迟调用，该如何操作</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 这里&amp;block将Block封装为Proc</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token operator">&amp;</span>block<span class="token punctuation">)</span>
	p name
  <span class="token comment"># 这里对其调用</span>
	block<span class="token punctuation">.</span>call
<span class="token keyword">end</span>
<span class="token comment"># 传递Block时，不需要再参数后面加 , </span>
my_method <span class="token string-literal"><span class="token string">"qsc"</span></span> <span class="token keyword">do</span> p <span class="token string-literal"><span class="token string">"Hello World"</span></span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如果想把 Proc 再转为 Block 该怎么操作</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span>
	p <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">greeting</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> , </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token keyword">yield</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">&#125;"</span></span>
<span class="token keyword">end</span>
my_proc <span class="token operator">=</span> proc <span class="token punctuation">&#123;</span><span class="token string-literal"><span class="token string">"Bill"</span></span><span class="token punctuation">&#125;</span>
my_method<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Hello"</span></span><span class="token punctuation">,</span><span class="token operator">&amp;</span>my_proc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    现在就可以将Block与Proc相互转化了</p>
<h4 id="Lambda-和-Proc的区别"><a href="#Lambda-和-Proc的区别" class="headerlink" title="Lambda 和 Proc的区别"></a>Lambda 和 Proc的区别</h4><ol>
<li>参数校验不同</li>
<li>return定义不同</li>
</ol>
<p>​    参数校验是指：Lambda中定义两个入参，如果你没传递，或者传递多了，则会报错，如果是Proc定义两个入参，如果没传递，则变量为nil，如果传递多了，多余部分也不会使用。Lambda更严格一些</p>
<p>​    return定义不同：Lambda中使用return，表示从Lambda表达式中返回，而Proc表示从定义Proc的作用域中返回</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
  <span class="token comment"># 这里block在my_method中定义，一旦执行return就会从my_method中退出</span>
	p <span class="token operator">=</span> <span class="token class-name">Proc</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">&#125;</span>
	result <span class="token operator">=</span> p<span class="token punctuation">.</span>call  <span class="token comment"># 这里调用完，就退出定义p的作用域，所以下面执行不到</span>
	<span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span>  <span class="token comment"># 这里实际上是不可到达的</span>
<span class="token keyword">end</span>

p my_method <span class="token comment"># => 10 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
	p <span class="token operator">=</span> lambda <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">&#125;</span>
	result <span class="token operator">=</span> p<span class="token punctuation">.</span>call
	<span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span>  
<span class="token keyword">end</span>

p my_method <span class="token comment"># => 20 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Lambda和Proc对比"><a href="#Lambda和Proc对比" class="headerlink" title="Lambda和Proc对比"></a>Lambda和Proc对比</h4><p>​    整体而言，Lambda更直观，它更像一个方法，对参数数量校验严格，在调用return时，只是从代码中返回。</p>
<h4 id="Method对象"><a href="#Method对象" class="headerlink" title="Method对象"></a>Method对象</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span>
		<span class="token variable">@v</span> <span class="token operator">=</span> <span class="token number">100</span>
	<span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		<span class="token variable">@v</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 通过Kernel#method方法，将obj中的方法转为一个Method对象 ！！！ </span>
mobj <span class="token operator">=</span> obj<span class="token punctuation">.</span>method <span class="token symbol">:my_method</span>

p mobj<span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token comment"># => Method</span>
<span class="token comment"># 主动调用</span>
p mobj<span class="token punctuation">.</span>call
mobj<span class="token punctuation">.</span>to_proc  <span class="token comment"># 将Method转为Proc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Method和Proc有什么区别？</p>
</blockquote>
<p>lambda 在定义它的作用域执行，block是一个闭包</p>
<p>Method 对象会在自身所在的对象的作用域执行，因为Method是所属对象的</p>
<h4 id="自由方法"><a href="#自由方法" class="headerlink" title="自由方法"></a>自由方法</h4><p>​    听名字感觉是一个脱离类，模块儿的一个方法，可以使用<code>Module#unbind</code>将一个方法转为自由方法，也可以使用<code>Module#instance_method</code>获取一个自由方法</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		<span class="token number">42</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
unbound <span class="token operator">=</span> MyModule<span class="token punctuation">.</span>instance_method<span class="token punctuation">(</span><span class="token symbol">:my_method</span><span class="token punctuation">)</span>
p unbound<span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token comment"># => UnboundMethod</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    自由方法并不能脱离对象执行，所以我们可以把他再绑定到一个对象中，使之再次成为Method对象，可以使用<code>UnboundMethod#bind</code>进行绑定，从某个类中分离出来的UnboundMethod，只能绑定在该类或者子类的对象上，模块儿中分离的自由方法则可以自由处置。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		<span class="token number">42</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
unbound <span class="token operator">=</span> MyModule<span class="token punctuation">.</span>instance_method<span class="token punctuation">(</span><span class="token symbol">:my_method</span><span class="token punctuation">)</span>
p unbound<span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token comment"># => UnboundMethod</span>
<span class="token comment"># 这里在String中定义新的方法，以前我们会传递一个Block，这里我们直接像参数一眼进行传递</span>
<span class="token builtin">String</span><span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:another_method</span><span class="token punctuation">,</span>unbound
p <span class="token string-literal"><span class="token string">"abc"</span></span><span class="token punctuation">.</span>another_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="编写领域专属语言（DSL）"><a href="#编写领域专属语言（DSL）" class="headerlink" title="编写领域专属语言（DSL）"></a>编写领域专属语言（DSL）</h3><blockquote>
<p>编写一个监视工具，如果发生不正常状况，进行消息通知，比如：</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 定义一个事件，传达一个事件描述，如果传递的代码块为true，则进行事件描述通知，如果为false，则不通知</span>
event <span class="token string-literal"><span class="token string">"we're earning wade of money"</span></span> <span class="token keyword">do</span>
    <span class="token comment"># 这里从数据库中获取数据</span>
    recent_orders <span class="token operator">=</span> <span class="token number">10000</span>
    recent_orders <span class="token operator">></span> <span class="token number">5000</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="第一个领域专用语言"><a href="#第一个领域专用语言" class="headerlink" title="第一个领域专用语言"></a>第一个领域专用语言</h4><blockquote>
<p>我们进行第一版的设计，只要让这个程序每隔几分钟运行一次</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 这里需要将加载路径添加，否则load会报错</span>
<span class="token variable">$LOAD_PATH</span><span class="token punctuation">.</span>unshift<span class="token punctuation">(</span><span class="token builtin">File</span><span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>__FILE__<span class="token punctuation">)</span><span class="token punctuation">)</span> 

<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">event</span></span><span class="token punctuation">(</span>description<span class="token punctuation">)</span>
    p description <span class="token keyword">if</span> <span class="token keyword">yield</span>
<span class="token keyword">end</span>
<span class="token comment"># 加载后，所有事件将会执行</span>
load <span class="token string-literal"><span class="token string">'events.rb'</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 这个文件就定义所有的事件</span>
event <span class="token string-literal"><span class="token string">"i am test can i get the right result: false"</span></span> <span class="token keyword">do</span>
    <span class="token boolean">false</span>
<span class="token keyword">end</span>
event <span class="token string-literal"><span class="token string">"i am test can i get the right result: true"</span></span> <span class="token keyword">do</span>
    <span class="token boolean">true</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="共享事件"><a href="#共享事件" class="headerlink" title="共享事件"></a>共享事件</h4><blockquote>
<p>共享事件：是否能让两个独立的事件访问同一个变量？ （使用<strong>扁平作用域</strong>）</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">monthly_sales</span></span>
    <span class="token number">100</span>  <span class="token comment"># 从数据库获取的</span>
<span class="token keyword">end</span>

target_sales <span class="token operator">=</span> <span class="token number">101</span> 

event <span class="token string-literal"><span class="token string">"monthly sales are suspiciously"</span></span> <span class="token keyword">do</span>
    monthly_sales <span class="token operator">></span> target_sales
<span class="token keyword">end</span>

event <span class="token string-literal"><span class="token string">"monthly sales are abysmally low"</span></span> <span class="token keyword">do</span>
    monthly_sales <span class="token operator">&lt;</span> target_sales
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="改良的DSL"><a href="#改良的DSL" class="headerlink" title="改良的DSL"></a>改良的DSL</h4><blockquote>
<p>这里我们将方法和临时变量直接定义在顶级作用域中，这是不合适的，应该进行封装与优化，希望是下面的效果</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">setup <span class="token keyword">do</span>
    puts <span class="token string-literal"><span class="token string">"Setting up sky"</span></span>
    <span class="token variable">@sky_height</span> <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">end</span>

setup <span class="token keyword">do</span>
    puts <span class="token string-literal"><span class="token string">"Setting up mountains"</span></span>
    <span class="token variable">@mountains_height</span> <span class="token operator">=</span> <span class="token number">200</span>
<span class="token keyword">end</span>

event <span class="token string-literal"><span class="token string">"the sky is falling"</span></span> <span class="token keyword">do</span>
    <span class="token variable">@sky_height</span> <span class="token operator">&lt;</span> <span class="token number">200</span>
<span class="token keyword">end</span>

event <span class="token string-literal"><span class="token string">"its getting closer"</span></span> <span class="token keyword">do</span>
    <span class="token variable">@sky_height</span> <span class="token operator">&lt;</span> <span class="token variable">@mountains_height</span>
<span class="token keyword">end</span>

event <span class="token string-literal"><span class="token string">"whoops ... too late"</span></span> <span class="token keyword">do</span>
    <span class="token variable">@sky_height</span> <span class="token operator">&lt;</span> <span class="token number">0</span>
<span class="token keyword">end</span>

<span class="token comment"># 我们可以自由的混合事件和setup代码块，DSL还是会检测事件，在每次执行事件前都会运行所有的setup，我们希望运行后的结果为：</span>
<span class="token string-literal"><span class="token string">"Setting up sky"</span></span>
<span class="token string-literal"><span class="token string">"Setting up mountains"</span></span>

<span class="token string-literal"><span class="token string">"the sky is falling"</span></span>

<span class="token string-literal"><span class="token string">"Setting up sky"</span></span>
<span class="token string-literal"><span class="token string">"Setting up mountains"</span></span>

<span class="token string-literal"><span class="token string">"its getting closer"</span></span>

<span class="token string-literal"><span class="token string">"Setting up sky"</span></span>
<span class="token string-literal"><span class="token string">"Setting up mountains"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>setup应该给@开头的变量赋值，事件可以读取这些变量，这样后面写代码就会干净的多</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">p <span class="token string-literal"><span class="token string">"main对象的实例变量：</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token keyword">self</span><span class="token punctuation">.</span>instance_variables</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>

<span class="token variable">$LOAD_PATH</span><span class="token punctuation">.</span>unshift<span class="token punctuation">(</span><span class="token builtin">File</span><span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>__FILE__<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">event</span></span><span class="token punctuation">(</span>description<span class="token punctuation">)</span>
    <span class="token comment"># 每次执行block前，先load数据获取文件，我们在其中定义一些实例变量，当加载后，该实例变量归属于main对象，这里是扁平作用域，所以可以被事件感知到</span>
    load <span class="token string-literal"><span class="token string">'setup.rb'</span></span>
    p description <span class="token keyword">if</span> <span class="token keyword">yield</span>
<span class="token keyword">end</span>

<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">setup</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span>
<span class="token keyword">end</span>

load <span class="token string-literal"><span class="token string">'events.rb'</span></span>
<span class="token comment"># 在 load 后，加载文件中</span>
p <span class="token string-literal"><span class="token string">"main对象的实例变量：</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token keyword">self</span><span class="token punctuation">.</span>instance_variables</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>专门在一个文件中定义实例数据</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">setup <span class="token keyword">do</span>
    puts <span class="token string-literal"><span class="token string">"Setting up sky"</span></span>
    <span class="token variable">@sky_height</span> <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">end</span>

setup <span class="token keyword">do</span>
    puts <span class="token string-literal"><span class="token string">"Setting up mountains"</span></span>
    <span class="token variable">@mountains_height</span> <span class="token operator">=</span> <span class="token number">200</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>新需求：要求按照特定的顺序执行块和事件</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token variable">$LOAD_PATH</span><span class="token punctuation">.</span>unshift<span class="token punctuation">(</span><span class="token builtin">File</span><span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>__FILE__<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">setup</span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>block<span class="token punctuation">)</span>
    <span class="token variable">@setups</span> <span class="token operator">&lt;&lt;</span> block
<span class="token keyword">end</span>

<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">event</span></span><span class="token punctuation">(</span>description<span class="token punctuation">,</span><span class="token operator">&amp;</span>block<span class="token punctuation">)</span>
    <span class="token variable">@events</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">&#123;</span><span class="token symbol">:description</span><span class="token operator">=></span>description<span class="token punctuation">,</span><span class="token symbol">:condition</span><span class="token operator">=></span>block<span class="token punctuation">&#125;</span>
<span class="token keyword">end</span>

<span class="token variable">@setups</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token variable">@events</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment"># 这里所有的event已经被保存，所有的setup也保存好了</span>
load <span class="token string-literal"><span class="token string">'events.rb'</span></span>

<span class="token variable">@events</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>event<span class="token operator">|</span>
    <span class="token variable">@setups</span><span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>setup<span class="token operator">|</span>
        setup<span class="token punctuation">.</span>call
    <span class="token keyword">end</span>
    puts <span class="token string-literal"><span class="token string">"ALERT: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">event<span class="token punctuation">[</span><span class="token symbol">:description</span><span class="token punctuation">]</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> <span class="token keyword">if</span> event<span class="token punctuation">[</span><span class="token symbol">:condition</span><span class="token punctuation">]</span><span class="token punctuation">.</span>call
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="消除全局变量"><a href="#消除全局变量" class="headerlink" title="消除全局变量"></a>消除<strong>全局</strong>变量</h4><blockquote>
<p>新需求：@events 和 @setups 为顶级实例变量，但其实也是全局变量的变形，安全性有限，我们能不能消除他们，这里我们使用共享作用域</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">lambda <span class="token punctuation">&#123;</span>
    setups <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    events <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    Kernel<span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:setup</span> <span class="token keyword">do</span> <span class="token operator">|</span><span class="token operator">&amp;</span>block<span class="token operator">|</span>
        setups <span class="token operator">&lt;&lt;</span> block
    <span class="token keyword">end</span>

    Kernel<span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:event</span> <span class="token keyword">do</span> <span class="token operator">|</span>description<span class="token punctuation">,</span><span class="token operator">&amp;</span>block<span class="token operator">|</span>
        events <span class="token operator">&lt;&lt;</span> <span class="token punctuation">&#123;</span><span class="token symbol">:description</span><span class="token operator">=></span>description<span class="token punctuation">,</span><span class="token symbol">:condition</span><span class="token operator">=></span>block<span class="token punctuation">&#125;</span>
    <span class="token keyword">end</span>

    Kernel<span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:each_setup</span> <span class="token keyword">do</span> <span class="token operator">|</span><span class="token operator">&amp;</span>block<span class="token operator">|</span>
        setups<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>setup<span class="token operator">|</span>
            block<span class="token punctuation">.</span>call setup
        <span class="token keyword">end</span>
    <span class="token keyword">end</span>

    Kernel<span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:each_event</span> <span class="token keyword">do</span> <span class="token operator">|</span><span class="token operator">&amp;</span>block<span class="token operator">|</span>
        events<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>event<span class="token operator">|</span>
            block<span class="token punctuation">.</span>call event
        <span class="token keyword">end</span>
    <span class="token keyword">end</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">.</span>call

load <span class="token string-literal"><span class="token string">"events.rb"</span></span>

each_event <span class="token keyword">do</span> <span class="token operator">|</span>event<span class="token operator">|</span>
    each_setup <span class="token keyword">do</span> <span class="token operator">|</span>setup<span class="token operator">|</span>
        setup<span class="token punctuation">.</span>call
    <span class="token keyword">end</span>
    puts <span class="token string-literal"><span class="token string">"ALERT: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">event<span class="token punctuation">[</span><span class="token symbol">:description</span><span class="token punctuation">]</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> <span class="token keyword">if</span> event<span class="token punctuation">[</span><span class="token symbol">:condition</span><span class="token punctuation">]</span><span class="token punctuation">.</span>call
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    这里我们使用lambda来定义一个block，在内部定义setups 和 events，在Kernel中定义方法，这些方法能访问到block中的代码块，而其他方法则无法访问到，这样就可以保证，消除全局变量，但代码看起来更复杂了似乎</p>
<h4 id="添加一个洁净室"><a href="#添加一个洁净室" class="headerlink" title="添加一个洁净室"></a>添加一个洁净室</h4><blockquote>
<p>在目前的版本中，事件可以修改其他事件共享的顶层实例变量，我们需要在setup中定义共享变量，而不是在事件中</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">event <span class="token string-literal"><span class="token string">"define a shared variable"</span></span> <span class="token keyword">do</span>
    <span class="token variable">@x</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">end</span>

event <span class="token string-literal"><span class="token string">"define a shared variable"</span></span> <span class="token keyword">do</span>
    <span class="token variable">@x</span> <span class="token operator">=</span> <span class="token variable">@x</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>改进方案，使用Object作为白板类，使用上线文探针执行block，这样每个event都是独立的，这里我们没有使用BasicObject充当白板类，因为里面缺少一些基本的方法：puts</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">each_event <span class="token keyword">do</span> <span class="token operator">|</span>event<span class="token operator">|</span>
    env <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">new</span>
    each_setup <span class="token keyword">do</span> <span class="token operator">|</span>setup<span class="token operator">|</span>
        env<span class="token punctuation">.</span>instance_eval <span class="token operator">&amp;</span>setup
    <span class="token keyword">end</span>
    puts <span class="token string-literal"><span class="token string">"ALERT: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">event<span class="token punctuation">[</span><span class="token symbol">:description</span><span class="token punctuation">]</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> <span class="token keyword">if</span> env<span class="token punctuation">.</span>instance_eval <span class="token operator">&amp;</span><span class="token punctuation">(</span>event<span class="token punctuation">[</span><span class="token symbol">:condition</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>作用域门 和 Ruby管理作用域的方式</li>
<li>利用扁平作用域 和共享作用域 让绑定穿越作用域</li>
<li>在对象的作用域中执行代码（通过instance_eval 或者 instance_exec） ，在洁净室中执行代码</li>
<li>在代码块和对象之间相互转化</li>
<li>在方法和对象之间相互转换</li>
<li>可调用对象（代码块，Proc，Lambda及普通方法）的区别</li>
<li>编写自己的领域专属语言</li>
</ul>
<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>​    在类定义中，Java与Ruby有着极大的不同，在Java中类定义就好像你对编译器说：这是我希望对象的行为，但在对象创建前或者使用方法前，什么也不会发生。而Ruby的类定义不仅仅是规定对象的行为方式，实际上也是运行代码。</p>
<p>​    这种思想催生出两种法术：<strong>类宏</strong>可以来修改类，<strong>环绕别名</strong>可以在其他方法前后封装额外的代码，为了最大程度使用这些法术，我们将介绍<strong>单件类</strong></p>
<p>​    学习之前我们需要提醒，类不过是增强的模块，所有关于类定义的，对模块也同样适用</p>
<h3 id="深入类定义"><a href="#深入类定义" class="headerlink" title="深入类定义"></a>深入类定义</h3><blockquote>
<p>​    类中不仅能定义方法，也可以放入任何代码进行执行</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
  puts <span class="token string-literal"><span class="token string">"Hello"</span></span>  <span class="token comment"># => Hello</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>和方法和块类似，类定义也会返回最后一条语句的值</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">result <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">self</span>
<span class="token keyword">end</span>
p result  <span class="token comment"># => MyClass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    定义类或模块儿时，类本身充当当前对象self的角色，因为类和模块儿也是对象，所以可以充当self，这里我们引入一个相关的概念：<strong>当前类</strong></p>
<h3 id="当前类"><a href="#当前类" class="headerlink" title="当前类"></a>当前类</h3><blockquote>
<p>至今为止，有几个概念混杂在一起，当前对象，当前类，当前作用域</p>
</blockquote>
<p>​    无论程序在哪个位置，都会有一个当前对象self，同样也总是有一个当前类或模块儿的存在，定义一个方法时，这个方法将成为当前类的一个实例方法。</p>
<p>​    self可以获取当前对象，但是Ruby中并没有相应的方法获取当前类的引用，我们这里有几个规则</p>
<ol>
<li>在程序的顶层，当前类为Object，这是main对象所属的类(这就是在顶层定义方法会成为Object实例方法的原因)</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 这里定义的是private实例方法，当前类为Object，所以子类也会继承到这个方法</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">say_hello</span></span>
	p <span class="token string-literal"><span class="token string">"Hello World"</span></span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">User</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hi</span></span>
		say_hello
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 这里是可以调用成功的</span>
obj<span class="token punctuation">.</span>hi  
say_hello
obj<span class="token punctuation">.</span>send <span class="token symbol">:say_hello</span>
<span class="token comment"># 这里无法调用</span>
obj<span class="token punctuation">.</span>say_hello  <span class="token comment"># 因为say_hello是一个私有方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>在一个方法中，当前类就是当前对象的类，比如我们在一个函数中定义另一个函数，这个内部定义的函数属于当前对象的类</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">User</span>
	<span class="token comment"># 这里一旦执行，当前类为User</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span> 
		<span class="token comment"># 这里定义的函数生效，并属于User，</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">two</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>one
p User<span class="token punctuation">.</span>instance_methods<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token comment"># => [:one, :two]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>当使用class或者module打开一个类时，这个类成为当前类</li>
</ol>
<blockquote>
<p>如果我们想将类为参数，动态的给类添加一个实例方法，我们该如何操作</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_method_to</span></span><span class="token punctuation">(</span>a_class<span class="token punctuation">)</span>
  <span class="token comment"># TODO : 在 a_class上定义方法 m()</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里我们引入class_eval方法</p>
<h4 id="class-eval方法"><a href="#class-eval方法" class="headerlink" title="class_eval方法"></a>class_eval方法</h4><p><strong>Module#class_eval</strong>方法会在一个已存在类的上下文中执行一个块儿。这听起来和<code>obj.instance_eval</code>很像。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_method_to</span></span><span class="token punctuation">(</span>a_class<span class="token punctuation">)</span>
  a_class<span class="token punctuation">.</span>class_eval <span class="token keyword">do</span>
    <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">m</span></span><span class="token punctuation">;</span> <span class="token string-literal"><span class="token string">'Hello'</span></span><span class="token punctuation">;</span> <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
add_method_to <span class="token builtin">String</span>
<span class="token string-literal"><span class="token string">"abc"</span></span><span class="token punctuation">.</span>m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li><p>Module#class_eval 会同时修改self和当前类，所以可以定义类的实例方法</p>
</li>
<li><p>Object#instance_eval 只修改self（这并不绝对的，我们后面会讲）</p>
</li>
</ol>
<p>​    <code>Module#class_eval</code>功能和<code>class关键字</code>类似，但更强大，因为class关键字传入 常量，而Module#class_eval，只要是代表类的变量即可使用。比我们想在运行期决定具体的类</p>
<p>​    <code>class</code>也是作用域门，会切换作用域，而<code>Module#class_eval</code>则是扁平作用域可以引入外部变量</p>
<blockquote>
<p>Module#class_eval 也有 class_exec 可以接收额外的代码块作为参数</p>
</blockquote>
<h4 id="instance-eval-和-class-eval-方法该如何选择"><a href="#instance-eval-和-class-eval-方法该如何选择" class="headerlink" title="instance_eval 和 class_eval 方法该如何选择"></a>instance_eval 和 class_eval 方法该如何选择</h4><p>​    这取决于两者的特点，instance_eval 方法打开非类的对象，而用 class_eval 方法打开类的定义，然后使用def定义方法</p>
<h3 id="类实例变量"><a href="#类实例变量" class="headerlink" title="类实例变量"></a>类实例变量</h3><blockquote>
<p>Ruby解释器假定所有的实例变量都属于当前对象self，在类定义时也是这样</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
  <span class="token variable">@my_var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>​    这里在MyClass中定义@my_var，self为MyClass，所以@my_var归属MyClass，也就是<strong>类实例变量</strong></p>
<blockquote>
<p>这里需要声明，类实例变量 和 类实例化对象的实例变量是不同的</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 这里当前类为MyClass，self也为MyClass，这里定义@my_var实例变量，所属MyClass</span>
	<span class="token variable">@my_var</span> <span class="token operator">=</span> <span class="token number">100</span>
	<span class="token comment"># 定义MyClass的read方法，一个指向MyClass的类方法，访问@my_var是可以的</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read</span></span><span class="token punctuation">;</span> <span class="token variable">@my_var</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token comment"># 定义MyClass的实例方法write，这里的@my_var 和 外面的@my_var 并不是一个变量，作用域不同</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">write</span></span><span class="token punctuation">;</span> <span class="token variable">@my_var</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token comment"># 这里一样，是访问不到外部的@my_var,除非调用write方法，给类的对象创建一个@my_var</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">read</span></span><span class="token punctuation">;</span> <span class="token variable">@my_var</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
p obj<span class="token punctuation">.</span>read  <span class="token comment"># nil</span>
obj<span class="token punctuation">.</span>write <span class="token comment"># 定义 @my_var = 2</span>
p obj<span class="token punctuation">.</span>read  <span class="token comment"># @my_var = 2</span>
p MyClass<span class="token punctuation">.</span>read <span class="token comment"># @my_var = 100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    Ruby解释器假定所有的实例变量都属于当前对象self，在类定义时也如此。</p>
<blockquote>
<p>一个类实例变量只可以被类本身所访问，而不能被类的实例或子类所访问到</p>
</blockquote>
<h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>​    如果想在类中定义变量，可被子类或者实例对象访问到，可以使用类变量，它更像是Java中的静态变量.</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">C</span>
	<span class="token variable">@@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">&lt;</span> <span class="token constant">C</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hi</span></span>
	 	<span class="token variable">@@var</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">D</span><span class="token punctuation">.</span><span class="token keyword">new</span>
p obj<span class="token punctuation">.</span>hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>需要注意一点，盲目的使用类变量也会有问题</p>
</blockquote>
<p>​    不允许在顶级上下文中定义类变量，因为main对象所属Object类，定义类变量，则所有Object子类都会继承这个类变量，也就有修改类变量的可能，在最新的Ruby编译器中已经对这个行为禁止，并爆出错误</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token variable">@@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">class</span> <span class="token class-name">User</span>
	<span class="token variable">@@var</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">end</span>
p <span class="token variable">@@var</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>这里再回顾一下Ruby中的操作符</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">p <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token boolean">true</span>  <span class="token comment"># 一个为真则为真</span>
p <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span>  <span class="token comment"># 一个为假都为假</span>
p <span class="token keyword">nil</span> <span class="token operator">||</span> <span class="token string-literal"><span class="token string">"a"</span></span>     <span class="token comment"># 除了 nil 和 false，其他都为真</span>
p <span class="token string-literal"><span class="token string">"a"</span></span> <span class="token operator">||</span> <span class="token keyword">nil</span>     <span class="token comment"># || 遇到真则返回</span>
p <span class="token string-literal"><span class="token string">"a"</span></span> <span class="token operator">||</span> <span class="token string-literal"><span class="token string">'b'</span></span>

p <span class="token keyword">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token string-literal"><span class="token string">"a"</span></span>     <span class="token comment"># &amp;&amp; 遇到假则返回</span>
p <span class="token string-literal"><span class="token string">"a"</span></span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">nil</span>
p <span class="token string-literal"><span class="token string">"a"</span></span> <span class="token operator">&amp;&amp;</span> <span class="token string-literal"><span class="token string">"b"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>类对象是否可以访问到类实例变量？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 这里@var 属于 MyClass，因为MyClass也是一个对象</span>
	<span class="token variable">@var</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get</span></span>
		<span class="token comment"># 这里访问，self为MyClass.new，作用域分离</span>
		<span class="token variable">@var</span>
	<span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">get</span></span>
		<span class="token variable">@var</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>get  <span class="token comment"># 无法访问到</span>
p MyClass<span class="token punctuation">.</span>get      <span class="token comment"># 正常输出 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>obj.instance.eval 改变obj为self，如果在Block内定义实例变量，则该实例变量属于obj</p>
<p>Class.class_eval 改变Class为self，同时改变当前类，定义实例变量属于这个类</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">get</span></span>
		<span class="token variable">@var</span> 
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get</span></span>
		<span class="token variable">@var</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

MyClass<span class="token punctuation">.</span>class_eval <span class="token keyword">do</span> 
	<span class="token variable">@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">end</span>

p MyClass<span class="token punctuation">.</span>get  <span class="token comment"># => 1</span>
p <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>get  <span class="token comment"># => nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="单件方法"><a href="#单件方法" class="headerlink" title="单件方法"></a>单件方法</h3><blockquote>
<p>我们现在想要修改一个类的实例方法有三种办法</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
<span class="token comment"># 1.0 猴子补丁</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 2.0 细化</span>
<span class="token keyword">module</span> <span class="token class-name">MyClass_Plus</span>
  refine MyClass <span class="token keyword">do</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">two</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 3.0 单件方法</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token class-name">obj</span><span class="token punctuation">.</span><span class="token function">tree</span></span>
  <span class="token comment"># 方法体</span>
<span class="token keyword">end</span>
obj<span class="token punctuation">.</span>tree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    单件方法我们可以看到是在对象上操作， 定义的函数也只针对这个对象，其他对象并没有这个方法，所以叫做单件方法，语法：<code>def obj.method_name</code></p>
<h4 id="类方法的真相"><a href="#类方法的真相" class="headerlink" title="类方法的真相"></a>类方法的真相</h4><p>​    类方法的实质是一个类的单件方法，因为类也是一个对象，给类定义单件方法，就是类方法。</p>
<h4 id="类宏"><a href="#类宏" class="headerlink" title="类宏"></a>类宏</h4><p>​    Ruby中的对象是没有属性的，对外只提供方法。所以在最初我们访问对象的实例变量时，可以写get，set方法，但是这会很麻烦，所以我们使用<code>Module#attr_accessor :var</code>访问器，这也叫做<strong>类宏</strong>，所属于<code>Module#attr_*</code>，类宏看起来很像关键字，实际上只是普通的方法，只不过可以在类定义中使用</p>
<h3 id="使用类宏"><a href="#使用类宏" class="headerlink" title="使用类宏"></a>使用类宏</h3><blockquote>
<p>我们原有的Book类中有名为：<code>GetTitle , title2 , LEND_TO_USER</code>，但是按照Ruby的惯例，他们应该分别命名为：<code>get_title,title.lend_to_user</code>，不过其他项目也在使用Book类，而我们不能修改那些项目，如果简单修改方法名，就会破坏其他的调用者</p>
<p>我们可以使用类宏声明这些旧方法名已被弃用，这样就可以修改方法名了</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Book</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">title</span></span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">subtitle</span></span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
  
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">deprecate</span></span><span class="token punctuation">(</span>old_method<span class="token punctuation">,</span>new_method<span class="token punctuation">)</span>
    <span class="token keyword">define_method</span><span class="token punctuation">(</span>old_method<span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">&amp;</span>block<span class="token operator">|</span>
      warn <span class="token string-literal"><span class="token string">"Warning: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">old_method</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> is deprecated , Use </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">new_method</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
      send<span class="token punctuation">(</span>new_method<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">&amp;</span>block<span class="token punctuation">)</span>
    <span class="token keyword">end</span>
  <span class="token keyword">end</span>

  deprecate <span class="token symbol">:GetTitle</span><span class="token punctuation">,</span> <span class="token symbol">:title</span>
  deprecate <span class="token symbol">:LENT_TO_USER</span><span class="token punctuation">,</span> <span class="token symbol">:lent_to</span>
  deprecate <span class="token symbol">:title2</span><span class="token punctuation">,</span> <span class="token symbol">:subtitle</span>
<span class="token keyword">end</span>

b <span class="token operator">=</span> <span class="token class-name">Book</span><span class="token punctuation">.</span><span class="token keyword">new</span>
b<span class="token punctuation">.</span><span class="token constant">LENT_TO_USER</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Bill"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="单件类"><a href="#单件类" class="headerlink" title="单件类"></a>单件类</h3><blockquote>
<p>提问：单件方法，类方法的信息是保存在哪里？</p>
</blockquote>
<p>​    首先不在对象中，因为只有类和模块儿可以定义方法</p>
<p>​    其次也不在类中，因为无法在类的对象中共享，它们就好像是一个独立个体，存在与某个与当前类有关的地方，这个地方就是<strong>单件类</strong>，负责存储单件方法。</p>
<blockquote>
<p>那我们该如何访问到单间类内？如何看到它？</p>
</blockquote>
<p>两种方式：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
single_class <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token operator">&lt;&lt;</span> obj
	<span class="token comment"># 返回单件类</span>
	<span class="token keyword">self</span>
<span class="token keyword">end</span>
p single_class  <span class="token comment"># => #&lt;Class:#&lt;MyClass:0x0000000108beb5c8>></span>
p single_class<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token comment"># => Class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 访问对象所属单件类，每个对象的单件类都不同</span>
<span class="token comment"># #&lt;Class:#&lt;MyClass:0x00000001051f3a78>></span>
p obj<span class="token punctuation">.</span>singleton_class
other <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># #&lt;Class:#&lt;MyClass:0x00000001051f3578>></span>
p other<span class="token punctuation">.</span>singleton_class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    单件类只有一个实例，且无法被继承，单件方法就定义在单件类中</p>
<h3 id="补充方法查找"><a href="#补充方法查找" class="headerlink" title="补充方法查找"></a>补充方法查找</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">C</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">a_method</span></span>
    <span class="token string-literal"><span class="token string">'C#a_method'</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">&lt;</span> <span class="token constant">C</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">D</span><span class="token punctuation">.</span><span class="token keyword">new</span>
p obj<span class="token punctuation">.</span>a_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们画出obj一起祖先链的图，先不考虑单件类和模块</p>
<img src="../../typora-user-images/image-20230127215743350.png" alt="image-20230127215743350" style="zoom:67%;" />

<h4 id="单件类-和-方法查找"><a href="#单件类-和-方法查找" class="headerlink" title="单件类 和 方法查找"></a>单件类 和 方法查找</h4><blockquote>
<p>单件类的超类是什么？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># #&lt;Class:#&lt;MyClass:0x00000001051f3a78>></span>
p obj<span class="token punctuation">.</span>singleton_class
<span class="token comment"># 对象的单件类的超类 就是 对象的所属类</span>
p obj<span class="token punctuation">.</span>singleton_class<span class="token punctuation">.</span>superclass  <span class="token comment"># => MyClass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>单件类是否在祖先链中，因为这涉及到方法的查找</p>
</blockquote>
<p>​    单件类是存在于祖先链中的，而且单件类的超类为对象的所属类，所以在祖先链中排在当前类之右边。方法查找也是按照这个顺序进行查找的。所以对象访问方法时，是先在单件类中访问，然后再去当前类中访问。</p>
<blockquote>
<p>类的单件类的超类就是超类的单件类</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">D</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">E</span> <span class="token operator">&lt;</span> <span class="token constant">D</span>
<span class="token keyword">end</span>

p <span class="token constant">D</span><span class="token punctuation">.</span>singleton_class   <span class="token comment"># => #&lt;Class:D></span>
p <span class="token constant">E</span><span class="token punctuation">.</span>singleton_class   <span class="token comment"># => #&lt;Class:E></span>
p <span class="token constant">D</span><span class="token punctuation">.</span>singleton_class<span class="token punctuation">.</span>superclass  <span class="token comment"># => #&lt;Class:Object></span>
p <span class="token constant">E</span><span class="token punctuation">.</span>singleton_class<span class="token punctuation">.</span>superclass  <span class="token comment"># => #&lt;Class:D></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>上面的定义看起来有点儿绕，Ruby为何这样设计？</p>
</blockquote>
<p>​    因为这样就可以在子类中调用父类的类方法</p>
<p>​    <img src="../../typora-user-images/image-20230103164540176.png" alt="image-20230103164540176" style="zoom:80%;" /></p>
<blockquote>
<p>我们再来画一下有了单件类后的祖先链和方法查找</p>
</blockquote>
<img src="../../typora-user-images/image-20230127220319776.png" alt="image-20230127220319776" style="zoom:67%;" />

<h4 id="七条规则"><a href="#七条规则" class="headerlink" title="七条规则"></a>七条规则</h4><ol>
<li>对象：要么是普通对象，要么是模块儿</li>
<li>模块：可以是普通模块，一个类或一个单件类</li>
<li>方法：存在与一个模块中，通常定义在类中</li>
<li>对象都有自己真正的类，要么是普通类，要么是单件类</li>
<li>除了BasicObject没有超类，其他的类都有一个祖先</li>
<li>一个对象的单件类的超类，就是这对象的类</li>
<li>一个类的单件类的超类，就是这个类的超类的单件类</li>
<li>调用一个方法时，Ruby先找到接收者真的类，再向上进入祖先链</li>
</ol>
<h4 id="类方法的语法"><a href="#类方法的语法" class="headerlink" title="类方法的语法"></a>类方法的语法</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
<span class="token comment"># 1</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token function">one</span></span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
<span class="token comment"># 2</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">two</span></span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 3</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">class</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">self</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">three</span></span> <span class="token punctuation">;</span><span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="单件类-和-instance-eval-方法"><a href="#单件类-和-instance-eval-方法" class="headerlink" title="单件类 和 instance_eval 方法"></a>单件类 和 instance_eval 方法</h4><p>​    之前我们说<code>instance_eval</code>修改self，实际上也修改当前类为接收者的单件类。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">s1 <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"abc"</span></span>

s1<span class="token punctuation">.</span>instance_eval <span class="token keyword">do</span>
  <span class="token comment"># 这里的swooh！self对象为“abc”的单件方法</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">swoosh</span></span><span class="token operator">!</span>
		reverse
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

p s1<span class="token punctuation">.</span>swoosh<span class="token operator">!</span>   <span class="token comment"># => cba</span>
s2 <span class="token operator">=</span> <span class="token string-literal"><span class="token string">'qsc'</span></span>  
p s2<span class="token punctuation">.</span>respond_to<span class="token operator">?</span><span class="token punctuation">(</span><span class="token symbol">:swoosh!</span><span class="token punctuation">)</span>  <span class="token comment"># => false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><blockquote>
<p>我们知道，使用<code>Module#attr_accessor</code>可以为对象创建属性</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	attr_accessor <span class="token symbol">:name</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"张三"</span></span>
p obj<span class="token punctuation">.</span>name <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如果我们想给类创建对象怎么办？可以在Class中定义类宏，每个类实际上是Class的实例对象，这样也就拥有了自己的属性</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">Class</span>
	attr_accessor <span class="token symbol">:name</span>
<span class="token keyword">end</span>

MyClass<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"张三"</span></span>
p MyClass<span class="token punctuation">.</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>但是这样每个类都拥有了属性，我们只希望MyClass中拥有属性</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">class</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">self</span>
		attr_accessor <span class="token symbol">:name</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

MyClass<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"张三"</span></span>
p MyClass<span class="token punctuation">.</span>name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="模块儿的麻烦"><a href="#模块儿的麻烦" class="headerlink" title="模块儿的麻烦"></a>模块儿的麻烦</h3><blockquote>
<p>我们试图在模块中定义模块的类方法，然后在一个类中引用该模块，试图将模块的类方法转为类的类方法</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">my_method</span></span><span class="token punctuation">;</span> <span class="token string-literal"><span class="token string">"Hello"</span></span> <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">include</span> MyModule
<span class="token keyword">end</span>

MyClass<span class="token punctuation">.</span>my_method  <span class="token comment"># => 报错，因为MyModule中的my_method为一个单件方法，不能被触碰</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>我们看看我们能解决这个问题吗？将模块中的方法，转为类的类方法</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">;</span> <span class="token string-literal"><span class="token string">"Hello"</span></span> <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">class</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">self</span>
		<span class="token keyword">include</span> MyModule
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

MyClass<span class="token punctuation">.</span>my_method  <span class="token comment"># => "Hello"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    my_method方法是MyClass的单件类的一个实例方法，这样也就是MyClass的类方法，这种技巧叫做<strong>类扩展</strong>，同样的技巧也适用于对象，毕竟类也是一个对象</p>
<h4 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		p <span class="token string-literal"><span class="token string">"Hello World"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token keyword">class</span> <span class="token operator">&lt;&lt;</span> obj
	<span class="token comment"># 单件类所属obj，所以引入的方法，会作为对象的单件方法</span>
	<span class="token keyword">include</span> MyModule
<span class="token keyword">end</span>
obj<span class="token punctuation">.</span>my_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    这称为<strong>对象扩展</strong></p>
<h4 id="Object-extend"><a href="#Object-extend" class="headerlink" title="Object#extend"></a>Object#extend</h4><blockquote>
<p>类扩展，对象扩展 因为用的很多，所以Ruby提供了<code>Object#extend</code>方法</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		p <span class="token string-literal"><span class="token string">"Hello World"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">extend</span> MyModule
<span class="token keyword">end</span>
MyClass<span class="token punctuation">.</span>my_method

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span><span class="token keyword">extend</span> MyModule
obj<span class="token punctuation">.</span>my_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="方法包装器"><a href="#方法包装器" class="headerlink" title="方法包装器"></a>方法包装器</h3><blockquote>
<p>如何在原有函数不修改的前提下，对方法做增强，在此之前我们介绍一些新的东西</p>
</blockquote>
<h4 id="方法别名"><a href="#方法别名" class="headerlink" title="方法别名"></a>方法别名</h4><p>​    <code>alias_method :new_method_name , :old_method_name</code> 对方法起一个别名</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span>
		p <span class="token string-literal"><span class="token string">"Hello one"</span></span>
	<span class="token keyword">end</span>
	alias_method <span class="token symbol">:two</span><span class="token punctuation">,</span><span class="token symbol">:one</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>one  <span class="token comment"># => “Hello one”</span>
obj<span class="token punctuation">.</span>two  <span class="token comment"># => “Hello one”</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    别名在Ruby中几乎随处可见，例如<code>String#size 就是 String#length</code>方法的别名，Inteager 有一个方法有至少五种别名</p>
<blockquote>
<p>如果先给一个方法起别名，又重新定义这个方法，我们看看会发生什么？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span>
		p <span class="token string-literal"><span class="token string">"Hello one"</span></span>
	<span class="token keyword">end</span>
	alias_method <span class="token symbol">:two</span><span class="token punctuation">,</span><span class="token symbol">:one</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span>
		p <span class="token string-literal"><span class="token string">"good morning"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>one  <span class="token comment"># => "good morning"</span>
obj<span class="token punctuation">.</span>two  <span class="token comment"># => "Hello one"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​        重定义方法时，并不是修改这个方法，而是定义一个新的方法，并将之前存在的方法名从新绑定，只要老方法还存在一个绑定，就仍可调用，这种先定义别名再重新定义方法的思想是一种有趣技巧的基础，我们举例说明</p>
<h4 id="环绕别名-类似于动态代理的效果"><a href="#环绕别名-类似于动态代理的效果" class="headerlink" title="环绕别名(类似于动态代理的效果)"></a>环绕别名(类似于动态代理的效果)</h4><ol>
<li>给方法定义一个别名</li>
<li>重定义这个方法</li>
<li>新方法中调用老的方法</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_users</span></span>
		p <span class="token string-literal"><span class="token string">"从数据库中获取数据"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 现在我们想对 MyClass#get_users做一些增强处理</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	alias_method <span class="token symbol">:get_users_origin</span><span class="token punctuation">,</span><span class="token symbol">:get_users</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_users</span></span>
		p <span class="token string-literal"><span class="token string">"检查用户权限"</span></span>
		p <span class="token string-literal"><span class="token string">"开启事务"</span></span>
		get_users_origin
		p <span class="token string-literal"><span class="token string">"提交事务"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>get_users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>环绕别名的一个缺点在于它污染了你的类，添加了一个额外的名字，如果想解决这个问题，可以在添加别名之后，想办法把老版本的方法变成私有的，Ruby中 公有 和 私有 实际上是针对的方法名，而不是方法本身</p>
<p>环绕别名的另一个缺点与加载有关，不要尝试加载（load）两次环绕别名，这里留给你自己思考</p>
<p>环绕别名的最主要的问题在于它是一种猴子补丁，它有可能破坏已有的代码，Ruby2.0增加了两种额外的方式来为已有方法保证新的功能</p>
</blockquote>
<h4 id="更多方法包装器"><a href="#更多方法包装器" class="headerlink" title="更多方法包装器"></a>更多方法包装器</h4><blockquote>
<p> 细化：使用细化，可以从新定义方法，如果定义重名方法，使用super则可调用到原先的内容，叫做：<strong>细化封装器</strong></p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_users</span></span>
		p <span class="token string-literal"><span class="token string">"从数据库中获取数据"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 现在我们想对 MyClass#get_users做一些增强处理</span>
<span class="token keyword">module</span> <span class="token class-name">MyClassRefinement</span>
	refine MyClass <span class="token keyword">do</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_users</span></span>
			p <span class="token string-literal"><span class="token string">"检查用户权限"</span></span>
			p <span class="token string-literal"><span class="token string">"开启事务"</span></span>
			<span class="token keyword">super</span>
			p <span class="token string-literal"><span class="token string">"提交事务"</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

using MyClassRefinement

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>get_users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Module#prepend：因为会将引入module放入当前类的祖父链位置的前面，所以也会覆盖掉当前类中定义的方法，使用super则可调用到原先的内容，这种技术称为：<strong>下包含包装器</strong></p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_users</span></span>
		p <span class="token string-literal"><span class="token string">"从数据库中获取数据"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 现在我们想对 MyClass#get_users做一些增强处理</span>
<span class="token keyword">module</span> <span class="token class-name">ExplicitMyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_users</span></span>
		p <span class="token string-literal"><span class="token string">"检查用户权限"</span></span>
		p <span class="token string-literal"><span class="token string">"开启事务"</span></span>
		<span class="token keyword">super</span>
		p <span class="token string-literal"><span class="token string">"提交事务"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">prepend</span> ExplicitMyClass
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>get_users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="测试：打破数据规律"><a href="#测试：打破数据规律" class="headerlink" title="测试：打破数据规律"></a>测试：打破数据规律</h3><blockquote>
<p>让 1 + 1 = 3</p>
</blockquote>
<p>绝大部分Ruby操作符实际上是方法， 例如整数的+只是名为Fixnum#+方法的语法糖，编写1+1时。实际上为：<code>1.+(1)</code>。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Fixnum</span>
	alias_method <span class="token symbol">:old_plus</span> <span class="token punctuation">,</span> <span class="token operator">:</span><span class="token operator">+</span>

	<span class="token keyword">def</span> <span class="token operator">+</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
		<span class="token keyword">self</span><span class="token punctuation">.</span>old_plus<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span>old_plus<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p <span class="token number">1</span><span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>务必要慎用这种能力，实际上我们发现Ruby中的规则简单，小巧，易操作</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>类定义对self和当前类的影响</li>
<li>熟悉<strong>单件方法</strong>和<strong>单件类</strong>，重新认识对象模型和方法查找</li>
<li>学习了类实例变量，类宏和下包含包装器</li>
</ul>
<p>这些规则同时适用于类和模块</p>
<h2 id="编写代码的代码"><a href="#编写代码的代码" class="headerlink" title="编写代码的代码"></a>编写代码的代码</h2><h3 id="Kernel-eval"><a href="#Kernel-eval" class="headerlink" title="Kernel#eval"></a>Kernel#eval</h3><p>​    前面我们学习了：<code>instance_eval , class_eval</code>,现在我要学习<code>Kernel#eval</code>方法，它的作用是执行一段<strong>代码字符串</strong></p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 执行 "p 123" 这段字符串，p 123表示输出 123 </span>
eval <span class="token string-literal"><span class="token string">"p 123"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​    代码字符串也可以访问局部变量</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">var <span class="token operator">=</span> <span class="token number">1</span>
eval <span class="token string-literal"><span class="token string">"p var"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="Binding-绑定对象"><a href="#Binding-绑定对象" class="headerlink" title="Binding 绑定对象"></a>Binding 绑定对象</h3><p>​    Binding是用一个对象表示完整的作用域，可以使用eval方法在这个Binding对象所携带的作用域中执行代码，Kernel#binding方法可以用来常见Binding对象</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_thod</span></span>
    <span class="token variable">@x</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token comment"># 返回binding</span>
    binding
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>my_thod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    可以把Binding对象看作是一个闭包，它只包含作用域而不包含代码，对于eval方法，可以传递一个Binding对象作为额外参数，代码可以在这个Binding对象所携带的作用域中执行</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">eval <span class="token string-literal"><span class="token string">"p @x"</span></span> <span class="token punctuation">,</span> obj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    Ruby还定义了一个预定义常量<code>TOPLEVEL_BINDING</code>,它表示顶级作用域的Binding对象。可以在程序任务地方访问到。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">eval <span class="token string-literal"><span class="token string">"self"</span></span><span class="token punctuation">,</span><span class="token constant">TOPLEVEL_BINDING</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    其中在我们最早使用Ruby时都使用过<code>irb</code>,其实就是解析控制台或者文件输入，再把每一行代码传递给eval方法执行，这种类型的程序有时被称为<code>代码处理器</code></p>
<p>​    eval方法后面三个为可选参数，statement代表执行语句，@binding表示所在作用域，file表示文件，line表示执行行号,这对于查找问题时比较方便</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">eval<span class="token punctuation">(</span>statement<span class="token punctuation">,</span><span class="token variable">@binding</span><span class="token punctuation">,</span>file<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="对比代码字符串-与-块"><a href="#对比代码字符串-与-块" class="headerlink" title="对比代码字符串 与 块"></a>对比代码字符串 与 块</h3><p>eval 只能执行代码字符串</p>
<p>Instance_eval，class_eval 可以执行Block，也能执行代码字符串</p>
<p>一般能使用Block，就使用Block</p>
<h4 id="eval麻烦"><a href="#eval麻烦" class="headerlink" title="eval麻烦"></a>eval麻烦</h4><ol>
<li>不能利用编辑器的功能特性，例如高亮</li>
<li>难以阅读与修改</li>
<li>错误隐藏到执行期</li>
<li>安全性！！！</li>
</ol>
<h4 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h4><p>​    这里用Java操作SQL时，遇到的SQL注入问题为例，就是我们在执行SQL前，如果SQL使用字符串拼接，如果用户传递恶意参数，就会导致SQL注入问题，代码注入也是类似的。</p>
<h4 id="防止代码注入"><a href="#防止代码注入" class="headerlink" title="防止代码注入"></a>防止代码注入</h4><p>​    有些人会禁用eval方法，毕竟可以找到替换的方式，Ruby也提供了更安全的方法</p>
<h4 id="污染对象和安全级别"><a href="#污染对象和安全级别" class="headerlink" title="污染对象和安全级别"></a>污染对象和安全级别</h4><p>​    Ruby会自动把不安全对象标记为污染对象，比如：Web表单，文件，命令行读取，可以通过<code>obj.tainted?</code> 来判断</p>
<h4 id="安全级别"><a href="#安全级别" class="headerlink" title="安全级别"></a>安全级别</h4><p>​    可以通过给$SAFE全局变量赋值来实现，一共有四个级别</p>
<p>0 ： 随意操作</p>
<p>1 ： 拒绝执行污染字符串</p>
<p>2 ： 禁止绝大多数与文件相关的操作</p>
<p>3 ： 每个创建对象都为被污染</p>
<p>​    为了谨慎使用安全级别，可以为eval方法创建一个可控环境，也称为<strong>沙盒</strong>，比如在一个块儿内，执行eval方法。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​    写一个attr_accessor类宏类似的方法，attr_checked，与访问器类似，但是会对属性进行校验，attr_checked 可以接受属性名和代码块，代码块用来进行校验，如果是对属性赋值，判断Block中是否为true，如果为false则报错。需求通过一组代码进行展示</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 这里是一个测试gem ，使用 gem install test-unit</span>
<span class="token keyword">require</span> <span class="token string-literal"><span class="token string">"test/unit"</span></span>
<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">;</span><span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">TestCheckedAttribute</span> <span class="token operator">&lt;</span> Test<span class="token double-colon punctuation">::</span>Unit<span class="token double-colon punctuation">::</span>TestCase
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">setup</span></span>
    <span class="token comment"># 在Person类中，加入 age 的读写方法，并对age的写操作进行校验</span>
		add_checked_attribute<span class="token punctuation">(</span>Person<span class="token punctuation">,</span><span class="token symbol">:age</span><span class="token punctuation">)</span>
		<span class="token variable">@bob</span> <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">new</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test_accept_vaild_values</span></span>
		<span class="token variable">@bob</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span>
		assert_equal <span class="token number">20</span><span class="token punctuation">,</span><span class="token variable">@bob</span><span class="token punctuation">.</span>age
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test_refuses_nil_values</span></span>
		assert_raises RuntimeError<span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">do</span>
			<span class="token variable">@bob</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token keyword">nil</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test_refuses_false_values</span></span>
		assert_raises RuntimeError<span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">do</span>
			<span class="token variable">@bob</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token boolean">false</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 这里是我们负责编写的代码 ， klass表示一个类对象，attribute表示需要给该类加入属性</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_checked_attribute</span></span><span class="token punctuation">(</span>klass<span class="token punctuation">,</span>attribute<span class="token punctuation">)</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ol>
<li>使用eval进行快速的单元测试</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 先定义一个函数，利用eval方法执行字符串代码</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_checked_attribute</span></span><span class="token punctuation">(</span>klass<span class="token punctuation">,</span>attribute<span class="token punctuation">)</span>
	eval "
	  <span class="token comment"># 打开类</span>
		<span class="token keyword">class</span> <span class="token comment">#&#123;klass&#125;</span>
			<span class="token comment"># 根据参数生成，get，set方法</span>
			<span class="token keyword">def</span> <span class="token comment">#&#123;attribute&#125;=(value)</span>
				<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">'Invalid attribute'</span></span> <span class="token keyword">unless</span> value
				@<span class="token comment">#&#123;attribute&#125; = value</span>
			<span class="token keyword">end</span>

			<span class="token keyword">def</span> <span class="token comment">#&#123;attribute&#125;()</span>
				@<span class="token comment">#&#123;attribute&#125;</span>
			<span class="token keyword">end</span>
		<span class="token keyword">end</span>
	"
<span class="token keyword">end</span>
<span class="token comment"># 这里对String添加属性my_attr</span>
add_checked_attribute<span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span><span class="token symbol">:my_attr</span><span class="token punctuation">)</span>
obj <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"a"</span></span>
obj<span class="token punctuation">.</span>my_attr <span class="token operator">=</span> <span class="token number">123</span>
p obj<span class="token punctuation">.</span>my_attr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>重构add_checked_attribute方法，把eval方法使用Ruby方法替换掉</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_checked_attribute</span></span><span class="token punctuation">(</span>klass<span class="token punctuation">,</span>attribute<span class="token punctuation">)</span>
	<span class="token comment"># 这里使用class_eval打开类的作用域，替换eval，因为替换后无法使用class，因为class关键字无法接受使用参数作为类名</span>
	klass<span class="token punctuation">.</span>class_eval <span class="token keyword">do</span>
		<span class="token comment"># 使用扁平作用域，使用define_method 替换 def，因为这里方法名也是动态的</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">="</span></span> <span class="token keyword">do</span> <span class="token operator">|</span>value<span class="token operator">|</span>
			<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">unless</span> value
      <span class="token comment"># 这里通过Object#instance_variable_* 方法来操作实例比变量</span>
			instance_variable_set<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>value<span class="token punctuation">)</span>
		<span class="token keyword">end</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> <span class="token keyword">do</span>
			instance_variable_get<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
add_checked_attribute<span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span><span class="token symbol">:my_attr</span><span class="token punctuation">)</span>
obj <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"a"</span></span>
obj<span class="token punctuation">.</span>my_attr <span class="token operator">=</span> <span class="token number">123</span>
p obj<span class="token punctuation">.</span>my_attr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>完成通过一个Block来校验属性，</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_checked_attribute</span></span><span class="token punctuation">(</span>klass<span class="token punctuation">,</span>attribute<span class="token punctuation">,</span><span class="token operator">&amp;</span>validation<span class="token punctuation">)</span>
	klass<span class="token punctuation">.</span>class_eval <span class="token keyword">do</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">=&#125;"</span></span> <span class="token keyword">do</span> <span class="token operator">|</span>value<span class="token operator">|</span>
			<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">unless</span> validation<span class="token punctuation">.</span>call<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
			instance_variable_set <span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>value
		<span class="token keyword">end</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> <span class="token keyword">do</span>
			instance_variable_get <span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li>内核方法改造成一个类宏，让它对所有的类定义中都可用，我们试着在class或module中定义，并且我们不需要再指类对象，通过self即可读取到</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Class</span>
  <span class="token comment"># 这样所有对象都有拥有这个方法了</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">attr_checked</span></span><span class="token punctuation">(</span>attribute<span class="token punctuation">,</span><span class="token operator">&amp;</span>validation<span class="token punctuation">)</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">="</span></span> <span class="token keyword">do</span> <span class="token operator">|</span>value<span class="token operator">|</span>
			<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">unless</span> validation<span class="token punctuation">.</span>call<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
			instance_variable_set<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>value<span class="token punctuation">)</span>
		<span class="token keyword">end</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> 
			instance_variable_get<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h4><p>​    也就是在代码运行中，有各种事件，我们可以利用事件进行操作，这个就叫做钩子方法</p>
<ol>
<li>类被继承时触犯</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">String</span>
  <span class="token comment"># inherited方法为Class的实例方法，我们可以进行覆写操作</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">inherited</span></span><span class="token punctuation">(</span>subclass<span class="token punctuation">)</span>
    p <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token keyword">self</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> was inherited by </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">subclass</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>模块儿被引入</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M1</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">included</span></span><span class="token punctuation">(</span>othermod<span class="token punctuation">)</span>
    p <span class="token string-literal"><span class="token string">"M1 was included into </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">othermod</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">module</span> <span class="token class-name">M2</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">prepended</span></span><span class="token punctuation">(</span>othermod<span class="token punctuation">)</span>
    p <span class="token string-literal"><span class="token string">"M2 was prepended to </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">othermod</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">C</span>
  <span class="token keyword">include</span> <span class="token constant">M1</span>
  <span class="token keyword">prepend</span> <span class="token constant">M2</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>模块儿新增方法事件</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">method_added</span></span><span class="token punctuation">(</span>method<span class="token punctuation">)</span>
    p <span class="token string-literal"><span class="token string">"New method: M#</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">method</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
  <span class="token keyword">end</span>
  
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">;</span><span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>我们现在需要保证，引入CheckedAttributes的类才运行使用<code>attr_checked</code></p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">CheckedAttributes</span>
	<span class="token comment"># 当类include CheckedAttributes 时被触发</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">included</span></span><span class="token punctuation">(</span>base<span class="token punctuation">)</span>
		<span class="token comment"># 将类extend ClassMethods，也就是转为base类的类方法</span>
		base<span class="token punctuation">.</span><span class="token keyword">extend</span> ClassMethods
	<span class="token keyword">end</span>

	<span class="token keyword">module</span> <span class="token class-name">ClassMethods</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">attr_checked</span></span><span class="token punctuation">(</span>attribute<span class="token punctuation">,</span><span class="token operator">&amp;</span>validation<span class="token punctuation">)</span>
			<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">="</span></span> <span class="token keyword">do</span> <span class="token operator">|</span>value<span class="token operator">|</span>
				<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">unless</span> validation<span class="token punctuation">.</span>call<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
				instance_variable_set<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>value<span class="token punctuation">)</span>
			<span class="token keyword">end</span>
			<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> 
				instance_variable_get<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
			<span class="token keyword">end</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>​    这里我们编写了自己的类宏，并使用了钩子方法。我们已经可以所使用的对象为所欲为，剩下的就交给我们不断的实践。后面我们将开启Rails之旅。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.chengling.cloud">庚辰</a></span></div><!--.post-copyright__type--><!--  span.post-copyright-meta= _p('post.copyright.link') + ": "--><!--  span.post-copyright-info--><!--    a(href=url_for(url))= theme.post_copyright.decode ? decodeURI(url) : url--><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.chengling.cloud" target="_blank">玲辰书斋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%83%E7%BC%96%E7%A8%8B/">元编程</a></div><div class="post_share"><div class="social-share" data-image="/img/default_top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/Linux/shell%E7%9A%84%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8.html"><img class="prev-cover" src="/img/default_top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Shell的常规使用</div></div></a></div><div class="next-post pull-right"><a href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E6%BC%94%E5%8C%96%E8%BF%87%E7%A8%8B.html"><img class="next-cover" src="/img/default_top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">查找算法的演化过程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/myHead.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">庚辰</div><div class="author-info__description">要么读书，要么旅行，身体和心灵总有一个要在路上.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">元编程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">对象模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%9C%9F%E7%9B%B8"><span class="toc-number">2.1.</span> <span class="toc-text">类的真相</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">实例变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%9C%9F%E7%9B%B8-1"><span class="toc-number">2.1.3.</span> <span class="toc-text">类的真相</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">常量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%9A%84%E5%B0%8F%E7%BB%93"><span class="toc-number">2.2.</span> <span class="toc-text">对象和类的小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4"><span class="toc-number">2.3.</span> <span class="toc-text">使用名称空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">调用方法时发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE"><span class="toc-number">2.4.1.</span> <span class="toc-text">方法查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel%E6%A8%A1%E5%9D%97%E5%84%BF"><span class="toc-number">2.4.2.</span> <span class="toc-text">Kernel模块儿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">执行方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.4.4.</span> <span class="toc-text">顶层上下文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%BA%8E%E4%B8%8Eself"><span class="toc-number">2.5.</span> <span class="toc-text">类定于与self</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E5%8C%96"><span class="toc-number">2.5.1.</span> <span class="toc-text">细化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%86%E5%8C%96%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">细化的陷阱</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">对象模型总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">动态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">动态调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">动态定义方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%9E%84Computer%E7%B1%BB"><span class="toc-number">3.1.3.</span> <span class="toc-text">重构Computer类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#method-missing%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">method_missing方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#respond-to-missing%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">respond_to_missing方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const-missing%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">const_missing方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#method-missing%E9%9A%90%E8%97%8FBug"><span class="toc-number">3.2.4.</span> <span class="toc-text">method_missing隐藏Bug</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E6%9D%BF%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">白板类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BD%E7%8F%AD%E7%B1%BB-%EF%BC%9A-BasicObject"><span class="toc-number">3.3.1.</span> <span class="toc-text">白班类 ： BasicObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">删除方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B9%BD%E7%81%B5%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">对比动态方法与幽灵方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">4.</span> <span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">代码块基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">4.2.</span> <span class="toc-text">代码块是闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.3.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.4.</span> <span class="toc-text">切换作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%A8"><span class="toc-number">4.5.</span> <span class="toc-text">作用域门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E5%8C%96%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.6.</span> <span class="toc-text">扁平化作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.7.</span> <span class="toc-text">共享作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%8E%A2%E9%92%88%EF%BC%88instance-eval%EF%BC%89"><span class="toc-number">4.8.</span> <span class="toc-text">上下文探针（instance_eval）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#instance-exec"><span class="toc-number">4.8.1.</span> <span class="toc-text">instance_exec</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%81%E5%87%80%E5%AE%A4"><span class="toc-number">4.9.</span> <span class="toc-text">洁净室</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.10.</span> <span class="toc-text">可调用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Proc%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.10.1.</span> <span class="toc-text">Proc对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#amp-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.10.2.</span> <span class="toc-text">&amp;操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-%E5%92%8C-Proc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.3.</span> <span class="toc-text">Lambda 和 Proc的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E5%92%8CProc%E5%AF%B9%E6%AF%94"><span class="toc-number">4.10.4.</span> <span class="toc-text">Lambda和Proc对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Method%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.10.5.</span> <span class="toc-text">Method对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%94%B1%E6%96%B9%E6%B3%95"><span class="toc-number">4.10.6.</span> <span class="toc-text">自由方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E9%A2%86%E5%9F%9F%E4%B8%93%E5%B1%9E%E8%AF%AD%E8%A8%80%EF%BC%88DSL%EF%BC%89"><span class="toc-number">4.11.</span> <span class="toc-text">编写领域专属语言（DSL）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A2%86%E5%9F%9F%E4%B8%93%E7%94%A8%E8%AF%AD%E8%A8%80"><span class="toc-number">4.11.1.</span> <span class="toc-text">第一个领域专用语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.11.2.</span> <span class="toc-text">共享事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%89%AF%E7%9A%84DSL"><span class="toc-number">4.11.3.</span> <span class="toc-text">改良的DSL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">4.11.4.</span> <span class="toc-text">消除全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%B4%81%E5%87%80%E5%AE%A4"><span class="toc-number">4.11.5.</span> <span class="toc-text">添加一个洁净室</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.12.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">5.</span> <span class="toc-text">类定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">深入类定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">当前类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#class-eval%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">class_eval方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instance-eval-%E5%92%8C-class-eval-%E6%96%B9%E6%B3%95%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">5.2.2.</span> <span class="toc-text">instance_eval 和 class_eval 方法该如何选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">类实例变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text">类变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">单件方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%9C%9F%E7%9B%B8"><span class="toc-number">5.4.1.</span> <span class="toc-text">类方法的真相</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%AE%8F"><span class="toc-number">5.4.2.</span> <span class="toc-text">类宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%AE%8F"><span class="toc-number">5.5.</span> <span class="toc-text">使用类宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BB%B6%E7%B1%BB"><span class="toc-number">5.6.</span> <span class="toc-text">单件类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE"><span class="toc-number">5.7.</span> <span class="toc-text">补充方法查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BB%B6%E7%B1%BB-%E5%92%8C-%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE"><span class="toc-number">5.7.1.</span> <span class="toc-text">单件类 和 方法查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E6%9D%A1%E8%A7%84%E5%88%99"><span class="toc-number">5.7.2.</span> <span class="toc-text">七条规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.7.3.</span> <span class="toc-text">类方法的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BB%B6%E7%B1%BB-%E5%92%8C-instance-eval-%E6%96%B9%E6%B3%95"><span class="toc-number">5.7.4.</span> <span class="toc-text">单件类 和 instance_eval 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">5.8.</span> <span class="toc-text">类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%84%BF%E7%9A%84%E9%BA%BB%E7%83%A6"><span class="toc-number">5.9.</span> <span class="toc-text">模块儿的麻烦</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95"><span class="toc-number">5.9.1.</span> <span class="toc-text">对象扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-extend"><span class="toc-number">5.9.2.</span> <span class="toc-text">Object#extend</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">5.10.</span> <span class="toc-text">方法包装器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%88%AB%E5%90%8D"><span class="toc-number">5.10.1.</span> <span class="toc-text">方法别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E7%BB%95%E5%88%AB%E5%90%8D-%E7%B1%BB%E4%BC%BC%E4%BA%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%95%88%E6%9E%9C"><span class="toc-number">5.10.2.</span> <span class="toc-text">环绕别名(类似于动态代理的效果)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E6%96%B9%E6%B3%95%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">5.10.3.</span> <span class="toc-text">更多方法包装器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%EF%BC%9A%E6%89%93%E7%A0%B4%E6%95%B0%E6%8D%AE%E8%A7%84%E5%BE%8B"><span class="toc-number">5.11.</span> <span class="toc-text">测试：打破数据规律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">5.12.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">编写代码的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kernel-eval"><span class="toc-number">6.1.</span> <span class="toc-text">Kernel#eval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binding-%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.</span> <span class="toc-text">Binding 绑定对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%BB%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%B8%8E-%E5%9D%97"><span class="toc-number">6.3.</span> <span class="toc-text">对比代码字符串 与 块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eval%E9%BA%BB%E7%83%A6"><span class="toc-number">6.3.1.</span> <span class="toc-text">eval麻烦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="toc-number">6.3.2.</span> <span class="toc-text">代码注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="toc-number">6.3.3.</span> <span class="toc-text">防止代码注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%A1%E6%9F%93%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB"><span class="toc-number">6.3.4.</span> <span class="toc-text">污染对象和安全级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB"><span class="toc-number">6.3.5.</span> <span class="toc-text">安全级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">6.4.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.1.</span> <span class="toc-text">钩子方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">6.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97%20&amp;%20(%E4%B8%8E)%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8.html" title="位运算 &amp; (与)实际应用"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="位运算 &amp; (与)实际应用"/></a><div class="content"><a class="title" href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E8%BF%90%E7%AE%97%20&amp;%20(%E4%B8%8E)%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8.html" title="位运算 &amp; (与)实际应用">位运算 &amp; (与)实际应用</a><time datetime="2024-12-08T03:51:04.000Z" title="发表于 2024-12-08 11:51:04">2024-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E5%B7%A5%E5%85%B7/Zed%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2.html" title="Zed动态查询"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Zed动态查询"/></a><div class="content"><a class="title" href="/post/%E5%B7%A5%E5%85%B7/Zed%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2.html" title="Zed动态查询">Zed动态查询</a><time datetime="2024-12-03T00:00:00.000Z" title="发表于 2024-12-03 08:00:00">2024-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E5%B7%A5%E5%85%B7/Electron%E5%88%86%E4%BA%AB.html" title="Electron分享"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Electron分享"/></a><div class="content"><a class="title" href="/post/%E5%B7%A5%E5%85%B7/Electron%E5%88%86%E4%BA%AB.html" title="Electron分享">Electron分享</a><time datetime="2024-10-09T00:00:00.000Z" title="发表于 2024-10-09 08:00:00">2024-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E5%89%8D%E7%AB%AF/Promise%E5%BC%82%E6%AD%A5%E5%AD%A6%E4%B9%A0.html" title="Promise异步学习"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Promise异步学习"/></a><div class="content"><a class="title" href="/post/%E5%89%8D%E7%AB%AF/Promise%E5%BC%82%E6%AD%A5%E5%AD%A6%E4%B9%A0.html" title="Promise异步学习">Promise异步学习</a><time datetime="2024-08-25T02:57:12.000Z" title="发表于 2024-08-25 10:57:12">2024-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/Ruby/LSP.html" title="LSP探索"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LSP探索"/></a><div class="content"><a class="title" href="/post/Ruby/LSP.html" title="LSP探索">LSP探索</a><time datetime="2024-07-28T04:30:12.000Z" title="发表于 2024-07-28 12:30:12">2024-07-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 庚辰</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a><br>
<a href="https://beian.miit.gov.cn/"  style="color:#f72b07" target="_blank">陕ICP备2022014054号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="498210" data-server="netease" data-type="song" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>