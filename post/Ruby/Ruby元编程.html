<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Ruby元编程 | 玲辰书斋</title><meta name="author" content="庚辰"><meta name="copyright" content="庚辰"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文需要在了解Ruby基本语法的前提下，进行学习  元编程是什么？​    元编程是编写能在运行时操作语言构件的代码 ​    在我们使用编辑器编写代码后，代码按照我们所写的内容进行编译，运行。在启动后我们无权再对代码进行干涉，而在一些业务场景中，我们想在不修改源代码的前提下，对一个类进行增强，这在Java中也是一个成熟的技术，例如反射，动态代理。但是Java所能给予的操作相比Ruby，就显得格外">
<meta property="og:type" content="article">
<meta property="og:title" content="Ruby元编程">
<meta property="og:url" content="http://www.chengling.cloud/post/Ruby/Ruby%E5%85%83%E7%BC%96%E7%A8%8B.html">
<meta property="og:site_name" content="玲辰书斋">
<meta property="og:description" content="本文需要在了解Ruby基本语法的前提下，进行学习  元编程是什么？​    元编程是编写能在运行时操作语言构件的代码 ​    在我们使用编辑器编写代码后，代码按照我们所写的内容进行编译，运行。在启动后我们无权再对代码进行干涉，而在一些业务场景中，我们想在不修改源代码的前提下，对一个类进行增强，这在Java中也是一个成熟的技术，例如反射，动态代理。但是Java所能给予的操作相比Ruby，就显得格外">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.chengling.cloud/img/default_top_img.jpg">
<meta property="article:published_time" content="2023-01-02T02:30:12.000Z">
<meta property="article:modified_time" content="2023-01-11T23:40:41.511Z">
<meta property="article:author" content="庚辰">
<meta property="article:tag" content="元编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.chengling.cloud/img/default_top_img.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.chengling.cloud/post/Ruby/Ruby%E5%85%83%E7%BC%96%E7%A8%8B"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ruby元编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-12 07:40:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/gh/radium-bit/res@master/live2d/autoload.js" async></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">玲辰书斋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Ruby元编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-02T02:30:12.000Z" title="发表于 2023-01-02 10:30:12">2023-01-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-11T23:40:41.511Z" title="更新于 2023-01-12 07:40:41">2023-01-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Ruby/">Ruby</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Ruby元编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><pre><code>本文需要在了解Ruby基本语法的前提下，进行学习
</code></pre>
<h2 id="元编程是什么？"><a href="#元编程是什么？" class="headerlink" title="元编程是什么？"></a>元编程是什么？</h2><p>​    元编程是编写能在运行时操作语言构件的代码</p>
<p>​    在我们使用编辑器编写代码后，代码按照我们所写的内容进行编译，运行。在启动后我们无权再对代码进行干涉，而在一些业务场景中，我们想在不修改源代码的前提下，对一个类进行增强，这在Java中也是一个成熟的技术，例如反射，动态代理。但是Java所能给予的操作相比Ruby，就显得格外的严格。</p>
<p>​    Ruby是一门可以在运行时操作语言构建的工具。语言构建就是我们代码中的各个成员（变量，类，方法）。通俗来说可以使用Ruby在运行时对已有的类进行灵活的修改，例如修改一个方法的定义。实例变量的定义，甚至我们可以在运行时创建一个没有的类。下面我们使用一些伪代码来进行演示。</p>
<p>​    我们想对数据库进行操作，最初我们的想法就是写一个Entity基类，然后由子类继承</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Entity</span>
  <span class="token comment"># 提供访问器</span>
	attr_accessor <span class="token symbol">:table</span><span class="token punctuation">,</span><span class="token symbol">:id</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span> table<span class="token punctuation">,</span>id
		<span class="token variable">@table</span> <span class="token operator">=</span> table
		<span class="token variable">@id</span> <span class="token operator">=</span> id
		Database<span class="token punctuation">.</span>sql <span class="token string-literal"><span class="token string">"insert into </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@able</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> 'id' values </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@id</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">&#125;"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">set</span></span><span class="token punctuation">(</span>col<span class="token punctuation">,</span>val<span class="token punctuation">)</span>
		Database<span class="token punctuation">.</span>sql <span class="token string-literal"><span class="token string">"update </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@table</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> set </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">col</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> = </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">val</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> where id = </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@id</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get</span></span><span class="token punctuation">(</span>col<span class="token punctuation">)</span>
		Database<span class="token punctuation">.</span>sql <span class="token string-literal"><span class="token string">"select </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">col</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> from </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@table</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> where id = </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@id</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">Movie</span> <span class="token operator">&lt;</span> Entity
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span> id
		<span class="token keyword">super</span> <span class="token string-literal"><span class="token string">'movies'</span></span><span class="token punctuation">,</span>id
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">title</span></span>
		get <span class="token string-literal"><span class="token string">"title"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">title</span></span><span class="token operator">=</span> value
		set <span class="token string-literal"><span class="token string">"title"</span></span><span class="token punctuation">,</span>value
	<span class="token keyword">end</span>
  
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">article</span></span>
		get <span class="token string-literal"><span class="token string">"article"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">article</span></span><span class="token operator">=</span> value
		set <span class="token string-literal"><span class="token string">"article"</span></span><span class="token punctuation">,</span>value
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># --------------------------------</span>
<span class="token comment"># 插入一条数据，简单且方便</span>
movie <span class="token operator">=</span> <span class="token class-name">Movie</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
movie<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"猫捉老鼠"</span></span>
movie<span class="token punctuation">.</span>article <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"相当不错"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    上面的代码看起来是可以解决问题，但如果一张表的字段特别多，我都需要定义到Movie类中吗？能不能用更少的代码解决问题？我们使用<code>Active Record</code>类库操作：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Movie</span> <span class="token operator">&lt;</span> ActiveRecord<span class="token double-colon punctuation">::</span>Base
<span class="token keyword">end</span>
<span class="token comment"># --------------------------------</span>
<span class="token comment"># 插入一条数据，简单且方便</span>
movie <span class="token operator">=</span> <span class="token class-name">Movie</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
movie<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"猫捉老鼠"</span></span>
movie<span class="token punctuation">.</span>article <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"相当不错"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    我们看到这次在Movie继承<code>ActiveRecord::Base</code>后，没有指定是哪个数据表，没有写SQL，没有定义像上面一样的操作方法，我们就可以轻松插入数据。这底层到底是干了什么？</p>
<p>​    实际上是ActiveRecord在运行期，通过内省机制查看类的名字，通过Movies推断出表名为<code>movies</code>,并在在读取数据表时，发现有title,article两个字段，动态的定义了两个同名的属性和相应的访问器。也是就动态的生成了 <code>Movie#title 和 Movie#title=</code> 这样的方法。</p>
<p>​    这就是Ruby的特点，也是我们要学习的元编程的一种表现形式，我们后面将试着分析和学习它。</p>
<h2 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h2><p>​    现在我们有一个需求，将给定的字符串，添加一个后缀，我们可以定义一个函数</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">appendTxt</span></span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> 
	content <span class="token operator">=</span> content <span class="token operator">+</span> <span class="token string-literal"><span class="token string">".txt"</span></span>
<span class="token keyword">end</span>

p appendTxt <span class="token string-literal"><span class="token string">"alibaba"</span></span>  <span class="token comment"># => "alibaba.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    但这不填符合我们面向对象的方法，应该将这个函数封装到一个具体类中，定义它的职责。如果我们因此封装一个<code>ApendTxtString</code>类，会不会导致类太多了，能不能让原本Ruby中的String具有新的行为,答案是可以的。我们可以直接修改Ruby原先定义的标准类。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">String</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">appendTxt</span></span>
		to_s <span class="token operator">+</span> <span class="token string-literal"><span class="token string">".txt"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span> 
<span class="token comment"># 我们使原先的String具有了新的行为</span>
p <span class="token string-literal"><span class="token string">"alibaba"</span></span><span class="token punctuation">.</span>appendTxt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    class更像是一个作用域操作符，当你第一次使用class时，会判断是否有这个类，如果没有进行创建，如果有则带回到类的上下文中，可以修改以往的方法，实例等等，这带给开发者很大的灵活性，但如果使用不当，也会导致很大的问题，比如原本String拥有appendTxt方法，而很多地方都应用这个函数，而你一旦从新定义，就会导致全局的bug，而且不容易排查，所以使用前一定要检查是否有重名操作。这在Ruby中也称为：<code>猴子补丁：Monkeypatch</code>，后面我们也有一些其他办法来替代猴子补丁，如<code>细化（Refinement）</code></p>
<h3 id="类的真相"><a href="#类的真相" class="headerlink" title="类的真相"></a>类的真相</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 我们定义了一个类</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
    <span class="token comment"># 定义实例变量</span>
		<span class="token variable">@v</span> <span class="token operator">=</span> <span class="token number">10</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 创建实例</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
<span class="token comment"># 输出当前对象是哪个类的实例</span>
obj<span class="token punctuation">.</span><span class="token keyword">class</span>   <span class="token comment"># => MyClass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    如果可以用Ruby解释器查看obj对象内部，我们可以发现什么？ 内部只有一个@v实例变量，而且仅属于obj。my_method并不属于obj，而是在MyClass中定义，这也是为什么类实例可以共享类的实例方法的原因</p>
<h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">obj<span class="token punctuation">.</span>my_method
p obj<span class="token punctuation">.</span>instance_variables <span class="token comment"># => [:@v]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​    与Java不同，Ruby中对象所属类和对象的实例变量没有任何关系，当你赋值创建一个实例变量时，它就出现了，如果你不使用<code>obj.my_method</code>，这个对象就没有<code>@v</code></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 查看实例拥有哪些方法，因为每个类实例都是继承了Object类，所以会继承很多的方法</span>
p obj<span class="token punctuation">.</span>methods
<span class="token comment"># 这里用正则筛选一下</span>
p obj<span class="token punctuation">.</span>methods<span class="token punctuation">.</span>grep<span class="token punctuation">(</span><span class="token regex-literal"><span class="token regex">/my/</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    一个对象内部其实只包含了自身的实例变量和对自身类的引用，方法并不在对象中，而在类中。这就是同一类的实例共享方法，但不共享实例变量的原因。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># String实例的方法</span>
p <span class="token builtin">String</span><span class="token punctuation">.</span>instance_methods
<span class="token comment"># String实例方法+类方法</span>
p <span class="token builtin">String</span><span class="token punctuation">.</span>methods
<span class="token comment"># String忽略继承的方法</span>
p <span class="token builtin">String</span><span class="token punctuation">.</span>instance_methods<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    在上面，我们先查看对象拥有的实例方法：<code>obj.instance_variables</code>，后面我们又查看了类的实例方法：<code>String.instance_methods</code>,能否推测 类 也是一个对象？</p>
<h4 id="类的真相-1"><a href="#类的真相-1" class="headerlink" title="类的真相"></a>类的真相</h4><p>​    在Ruby中类本身其实也是对象，是另一个类的实例。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># String类实际上是Class类的一个实例</span>
p <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token comment"># => Class</span>
<span class="token comment"># 而Class类还是Class的实例</span>
p <span class="token builtin">Class</span><span class="token punctuation">.</span><span class="token keyword">class</span>   <span class="token comment"># => Class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    这确实是挺绕的。不过这么看来一个类的方法就是Class的实例方法。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">p <span class="token builtin">Class</span><span class="token punctuation">.</span>instance_methods<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment"># => [:allocate, :superclass, :subclasses, :new]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    这里看到Class的实例方法有四个，其中new是我们最常用的，allocate是new方法的支撑方法，而superclass与我们Java中熟悉的继承有关，找到他的父类是谁？</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">p <span class="token builtin">String</span><span class="token punctuation">.</span>superclass  <span class="token comment"># String的父类：Object</span>
p <span class="token builtin">Object</span><span class="token punctuation">.</span>superclass  <span class="token comment"># Object的父类：BasicObject</span>
p BasicObject<span class="token punctuation">.</span>superclass <span class="token comment"># BasicObject的父类：nil 空  到头了</span>

p <span class="token builtin">Class</span><span class="token punctuation">.</span>superclass   <span class="token comment"># Class的父类是 Module</span>
p <span class="token builtin">Module</span><span class="token punctuation">.</span>superclass  <span class="token comment"># Module的父类是 Object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    可以看到Class是继承了Module，并自身定义了实例化的操作。所以他们看起来那么像。</p>
<p>​    每个类最终继承于BasicObject，而每个类又是Class类的实例。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>​    任何大写字母开头的引用，都代表着常量，而常量一般指不会修改的东西，在Ruby中常亮也可以看做是变量，而当你修改，编译器会发出警告，但仍然会进行修改。常量与变量最大的区别在于作用域的不同。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
  <span class="token comment"># 外部的MyConstant</span>
	MyConstant <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Outer constant"</span></span>
	<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
    <span class="token comment"># 内部的MyConstant</span>
		MyConstant <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Inner constant"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p MyModule<span class="token double-colon punctuation">::</span>MyConstant
p MyModule<span class="token double-colon punctuation">::</span>MyClass<span class="token double-colon punctuation">::</span>MyConstant<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    这里内部的MyConstant和外部的MyConstant实际上处于两个作用域中，是完全不同的东西，而我们可以通过<code>::</code>来访问他们</p>
<p>​    如果处于模块儿较深的位置，想用绝对路径来访问外部的常量，可以使用 :: 表示路径的根位置。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token constant">Y</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"a root-level constant"</span></span>
<span class="token keyword">module</span> <span class="token class-name">M</span>
	<span class="token constant">Y</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"a constant in M"</span></span>
	<span class="token double-colon punctuation">::</span><span class="token constant">Y</span>  <span class="token comment"># => "a root-level constant"</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    <code>Module.constants</code>会返回当前范围内所有常量，这里需要注意一点，Module中定义class，其类名也是一个常量。如果想知道当前代码所在路径，则可以知道<code>Module.nesting</code>方法。</p>
<p>​    而我们一般会利用常量域的不同，作为名称空间，这样避免类名冲突</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M</span>
	<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hi</span></span>
			puts <span class="token string-literal"><span class="token string">"hello"</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
mc <span class="token operator">=</span> <span class="token constant">M</span><span class="token double-colon punctuation">::</span><span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
mc<span class="token punctuation">.</span>hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="方法查找"><a href="#方法查找" class="headerlink" title="方法查找"></a>方法查找</h4><p>​    这里有两个概念：接收者和祖先链</p>
<p>比如说上面的代码 mc.hi ,其中mc就是方法的接受者，在执行这个方法前需要先找到这个方法的定义，所以先到接收者中去找该方法，如果没有则找他的父类或者是引入的Module中寻找，而接收者，接受者内引入模块儿，父类共同构成了祖先链。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M1</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">m1_method</span></span>
		<span class="token string-literal"><span class="token string">"m1.method"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">module</span> <span class="token class-name">M2</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">m2_method</span></span>
		<span class="token string-literal"><span class="token string">"m2.method"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 引入M1，模块儿在祖先链中位置为自身类上面</span>
	<span class="token keyword">include</span> <span class="token constant">M1</span>  
	<span class="token comment"># 引入M2，模块儿在祖先链中位置为自身类下面</span>
	<span class="token keyword">prepend</span> <span class="token constant">M2</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">AC</span> <span class="token operator">&lt;</span> MyClass
<span class="token keyword">end</span>
<span class="token comment"># [AC, M2, MyClass, M1, Object, Kernel, BasicObject]</span>
p <span class="token constant">AC</span><span class="token punctuation">.</span>ancestors <span class="token comment"># 查看他的祖先链</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如果在祖先链中多次引入一个module，会怎么样？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M1</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
p <span class="token constant">M1</span><span class="token punctuation">.</span>ancestors  <span class="token comment"># => [M1]</span>
<span class="token keyword">module</span> <span class="token class-name">M2</span>
	<span class="token keyword">include</span> <span class="token constant">M1</span>
<span class="token keyword">end</span>
p <span class="token constant">M2</span><span class="token punctuation">.</span>ancestors  <span class="token comment"># => [M2, M1]</span>
<span class="token keyword">module</span> <span class="token class-name">M3</span>
	<span class="token keyword">prepend</span> <span class="token constant">M1</span>
	<span class="token keyword">include</span> <span class="token constant">M2</span>
<span class="token keyword">end</span>
p <span class="token constant">M3</span><span class="token punctuation">.</span>ancestors  <span class="token comment"># => [M1, M3, M2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Kernel模块儿"><a href="#Kernel模块儿" class="headerlink" title="Kernel模块儿"></a>Kernel模块儿</h4><p>​    在Ruby中我们常常使用<code>print</code>，就好像所有对象都有print方法一样。但实际上这些方法来着<code>Kernel</code>模块儿私有实例方法，因为Object引入了Kernel，所以每个对象都可以调用Kernel方法，也叫做内核方法，我们当然也可以自己加入自己的方法</p>
<blockquote>
<p>这里说明一下为什么，我们在顶级作用域下写的函数，代码可以直接运行？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">p <span class="token keyword">self</span>   <span class="token comment"># => main</span>
p <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token comment"># => Object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​    顶级作用域下，实际上是self指向main实例对象，main又是Object的子类，所以继承Object的实例方法，所以我们在顶级作用域下调用 print 方法，是调用Object::Kernel#print 方法。</p>
<h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><blockquote>
<p>当我们找到了该方法，如何去执行呢？</p>
</blockquote>
<p>比如我们现在找到了该方法：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span>
		<span class="token variable">@x</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
	  p <span class="token keyword">self</span>   <span class="token comment"># => #&lt;MyClass:0x000000010dcdb320 @x=1> self为obj</span>
	  temp <span class="token operator">=</span> <span class="token variable">@x</span> <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 这里实例变量@x 也是访问self内定义的</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>my_method  <span class="token comment"># obj调用my_method时，obj为当前对象self</span>
p <span class="token keyword">self</span>         <span class="token comment"># => main , 在顶级作用域下，调用 p ,接受者为main对象，main为self</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>请问：@x是属于哪个对象的，my_method属于哪个对象？</p>
</blockquote>
<p>​    一般情况下，会将最初方法的接收者作为当前对象，也就是作为self，所有实例变量和方法都属于self，如果没有明确指定接受者的实际上都指向self，除非转而调用其他对象的方法，则self就会转为这个对象。</p>
<blockquote>
<p>Ruby中 private 修饰的方法，不能明确指定接受者来调用私有方法，只能通过隐性的接受者self调用。</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hi</span></span>
		p <span class="token string-literal"><span class="token string">"Hi "</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">Hello</span></span>
		<span class="token comment"># 这里Hello 调用 私有方法hello ，使用的隐藏当前对象,也就是下面的obj</span>
		hello
	<span class="token keyword">end</span>

	<span class="token keyword">private</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hello</span></span> 
		p <span class="token string-literal"><span class="token string">"hello"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>hi     <span class="token comment"># 正常调用</span>
obj<span class="token punctuation">.</span>Hello  <span class="token comment"># 正常调用</span>
obj<span class="token punctuation">.</span>hello  <span class="token comment"># 无法调用，因为private方法不能指定接收者调用，只能隐性调用，也就是内部调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="顶层上下文"><a href="#顶层上下文" class="headerlink" title="顶层上下文"></a>顶层上下文</h4><blockquote>
<p>如果没有调用任何方法，那这时谁是self呢？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># main</span>
p <span class="token keyword">self</span>
<span class="token comment"># Object</span>
p <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token keyword">class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Ruby程序运行时，Ruby解释器创建一个名为main对象作为当前对象，这个对象有时被称为顶层上下文。</p>
<h4 id="细化"><a href="#细化" class="headerlink" title="细化"></a>细化</h4><p>​    在前面我们使用了猴子补丁对原有的类进行修改，但这一操作是全局性的，如果把控不好，会导致许多隐性的Bug，所以Ruby又引入了<code>细化(refinement)</code>,起到同样的作用，但是可以限制作用域。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">StringAppend</span>
  <span class="token comment"># 细化 String 标准类库，传入一个Block</span>
	refine <span class="token builtin">String</span> <span class="token keyword">do</span>
    <span class="token comment"># 在Block内，定义一个append_txt方法，现在self转为String，相当于给String定义实例方法</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">append_txt</span></span>
			to_s <span class="token operator">+</span> <span class="token string-literal"><span class="token string">".txt"</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">module</span> <span class="token class-name">StringStuff</span>
	<span class="token comment"># 上面定义好，并未生效，需要主动启动 using</span>
	using StringAppend
	<span class="token comment"># 这里正常执行</span>
	p <span class="token string-literal"><span class="token string">"alibaba"</span></span><span class="token punctuation">.</span>append_txt
<span class="token keyword">end</span>
<span class="token comment"># 这里就会报错，所以通过细化，可以控制修改的访问范围，不会使全局都看到这个修改</span>
p <span class="token string-literal"><span class="token string">"taobao"</span></span><span class="token punctuation">.</span>append_txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    细化只在两种场合有效：</p>
<ol>
<li>refine代码块内部</li>
<li>using语句位置到模块儿结束，或者到文件结束（在顶层上下文使用using）</li>
</ol>
<h5 id="细化的陷阱"><a href="#细化的陷阱" class="headerlink" title="细化的陷阱"></a>细化的陷阱</h5><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		p <span class="token string-literal"><span class="token string">"old method"</span></span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">other_method</span></span>
		my_method
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">module</span> <span class="token class-name">MyClassRefinement</span>
	refine MyClass <span class="token keyword">do</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
			p <span class="token string-literal"><span class="token string">"new method"</span></span>
		<span class="token keyword">end</span>	
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token comment"># 在顶级上下文中使用using</span>
using MyClassRefinement

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obj<span class="token punctuation">.</span>my_method  <span class="token comment"># => new method</span>
obj<span class="token punctuation">.</span>other_method <span class="token comment"># => old method</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里虽然使用了细化，但当其他实例方法调用细化方法，还是会调用之前定义的代码，如果直接调用细化方法，则修改为细化内容。</p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>​    在Ruby这种动态语言中，方法的调用是极为灵活的，并不会在编译器就爆出各种错误，比方说我定义一个User类，我想调用hi方法，我并没有定义hi方法，但这并不妨碍我编写代码，运行期我去找hi方法，如果发现没有这个方法，最终我可以向这个类中添加我想要的方法在运行期间。这给了我们更多的操作空间，这将是我们要学习的。</p>
<blockquote>
<p>现在我们有一个老的系统需要我们重构，老板要求系统自动为超过99美金的开销天添加标记</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">DS</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span> <span class="token punctuation">;</span> <span class="token keyword">end</span><span class="token comment"># 连接数据源</span>

  <span class="token comment"># 原先设计的访问方法</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_cpu_info</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_cpu_price</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_mouse_info</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_mouse_price</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_keyBoard_info</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get_keyBoard_price</span></span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
<span class="token keyword">end</span>
ds <span class="token operator">=</span> <span class="token class-name">DS</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 获取信息</span>
ds<span class="token punctuation">.</span>get_cpu_info<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment"># 获取价格</span>
ds<span class="token punctuation">.</span>get_cpu_price<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们现在需要将数据源封装起来，每个computer为一个对象，并为每个组件定义通用的方法</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
  <span class="token comment"># data_source 就是上面的DS对象</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">mouse</span></span>
		info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>get_mouse_info<span class="token punctuation">(</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>get_mouse_price<span class="token punctuation">(</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Mouse: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">cpu</span></span>
		info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>get_cpu_info<span class="token punctuation">(</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>get_cpu_price<span class="token punctuation">(</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Cpu: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">end</span>

	<span class="token comment"># ... 类似操作</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    我们可以看到 mouse 和 cpu 就有大量的代码重复，如果后面还需要加其他的，则会让代码臃肿且冗余。</p>
<p>​    我们有两种办法进行重构优化：<code>动态方法</code> ，<code>method_missing</code></p>
<h3 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h3><h4 id="动态调用方法"><a href="#动态调用方法" class="headerlink" title="动态调用方法"></a>动态调用方法</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method</span></span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>method <span class="token string-literal"><span class="token string">"Hello World"</span></span>
<span class="token comment"># 动态派发和上面普通调用的结果是一样的, 将 obj.method 替换为 obj.send(:method)</span>
obj<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token symbol">:method</span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"Hello World"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>为什么使用动态派发？</p>
</blockquote>
<p>​    因为可以在运行最后才决定具体调用哪个方法。而不是硬编码决定</p>
<blockquote>
<p>这里使用<code>:method</code>，而不是”method”，实际上是一样的</p>
</blockquote>
<p><code>obj.send(&quot;method&quot;,&quot;Hello World&quot;)</code></p>
<p>​    :method 表示的是一个Symbol符号</p>
<p>​    “method”则是一个String字符串，一般在元编程我们常常使用Symbol，因为Symbol是不可变的。字符串是可变的。</p>
<h4 id="动态定义方法"><a href="#动态定义方法" class="headerlink" title="动态定义方法"></a>动态定义方法</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 这里就是定义了一个实例方法 将 def my_method 替换为 define_method :my_method，参数部分，通过Block传递</span>
	<span class="token keyword">define_method</span> <span class="token symbol">:my_method</span> <span class="token keyword">do</span> <span class="token operator">|</span>my_arg<span class="token operator">|</span>
		my_arg <span class="token operator">*</span> <span class="token number">3</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obj<span class="token punctuation">.</span>my_method <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    在运行时定义方法的技术称为动态方法。</p>
<blockquote>
<p>为什么使用动态方法，而不是直接定义：def</p>
</blockquote>
<p>​    因为这样可以在运行最后决定方法名叫什么</p>
<h4 id="重构Computer类"><a href="#重构Computer类" class="headerlink" title="重构Computer类"></a>重构Computer类</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">mouse</span></span>
		companent <span class="token symbol">:mouse</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">cpu</span></span>
		companent <span class="token symbol">:cpu</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">companent</span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    <span class="token comment"># 这里使用了动态调用方法</span>
		info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_price"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">end</span>
	<span class="token comment"># ... 类似操作</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    我们使用动态派发的方式，抽离出一个公共组件，其他配件可以直接使用，代码量减少的多</p>
<p>​    我们再用动态定义方法去试着重构一下代码    </p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
	<span class="token keyword">end</span>

	<span class="token comment"># 这里定义一个类方法，这里的self指向的是Computer类常量</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">define_companent</span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> 
		<span class="token comment"># 根据传入的Symbol，创建相应的方法</span>
		<span class="token keyword">define_method</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">do</span>
			info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
			price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_price"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
			result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
			result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
			<span class="token keyword">return</span> result
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
	<span class="token comment">## 这里主动调用 并动态创建对应的方法</span>
	define_companent <span class="token symbol">:mouse</span>
	define_companent <span class="token symbol">:cpu</span>
	define_companent <span class="token symbol">:keyboard</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>现在Computer已经剩不了多少代码了，我们使用内省方式缩减代码</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
    <span class="token comment"># 主动根据DS中给定的访问方法，创建访问方法，而不需要我们再去手动控制</span>
		data_source<span class="token punctuation">.</span>methods<span class="token punctuation">.</span>grep<span class="token punctuation">(</span><span class="token operator">/</span><span class="token operator">^</span>get_<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span>_info$<span class="token operator">/</span> <span class="token operator">|</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment"># 被正则表达式匹配到的方法，会依次调用这里传递的块儿，并将内容封装到 $1 全局变量中</span>
			Computer<span class="token punctuation">.</span>define_companent $<span class="token number">1</span>
		<span class="token punctuation">&#125;</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">define_companent</span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
		<span class="token keyword">define_method</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">do</span>
			info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
			price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_price"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
			result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
			result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
			<span class="token keyword">return</span> result
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    我们在初始化方法中加入几场代码就可以让代码更加简洁。</p>
<h3 id="method-missing方法"><a href="#method-missing方法" class="headerlink" title="method_missing方法"></a>method_missing方法</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">User</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method_missing</span></span><span class="token punctuation">(</span>method<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
		puts <span class="token string-literal"><span class="token string">"我是所有丢失消息的重点"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obj<span class="token punctuation">.</span>hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    在Ruby中我们可以随意调用一个方法，而这个方法可能根本不存在，当运行时在当前对象的继承链上都没有找到这个方法时，会去找当前对象的 method_missing 方法，它就好像每个无家可归的人最终的点，method_missing是<code>BasicObject</code>中定义的私有实例方法，所以每个子类都可以使用这个方法，而BasicObject中是直接抛出这个异常，所以需要我们自己去重写。<code>method_missing</code>也叫做幽灵方法。</p>
<blockquote>
<p>现在我们通过method_missing来重构我们的Computer类</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Computer</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span><span class="token punctuation">(</span>computer_id<span class="token punctuation">,</span>data_source<span class="token punctuation">)</span>
		<span class="token variable">@id</span> <span class="token operator">=</span> computer_id
		<span class="token variable">@data_source</span> <span class="token operator">=</span> data_source
	<span class="token keyword">end</span>
	<span class="token comment"># name 为 调用的方法名，args 表示参数 ，*表示接受所有的参数,封装为一个数组</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method_miss</span></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
		<span class="token comment"># 判断@data_source是否有这个方法？如果没有则调用super.method_miss,也就是未找到该方法</span>
		<span class="token keyword">super</span> <span class="token keyword">if</span> <span class="token operator">!</span><span class="token variable">@data_source</span><span class="token punctuation">.</span>respond_to<span class="token operator">?</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">)</span>
		<span class="token comment"># 如果有这个方法</span>
		info <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_info"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		price <span class="token operator">=</span> <span class="token variable">@data_source</span><span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"get_</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">_price"</span></span><span class="token punctuation">,</span><span class="token variable">@id</span><span class="token punctuation">)</span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">: </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">info</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> : (</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">price</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">)"</span></span>
		result <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"*"</span></span> <span class="token operator">+</span> result <span class="token keyword">if</span> price <span class="token operator">></span> <span class="token number">99</span>
		<span class="token keyword">return</span> result
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    现在发现我们不需要再定义额外的方法了，直接通过幽灵方法来做判断与返回，这里方法：<code>respond_to?</code>表示该实例是否有目标方法，</p>
<p>​    如果方法返回值为Boolean，一般会在方法名上使用？表示。</p>
<blockquote>
<p>这里还有一个函数：<code>respond_to_missing?</code> 会判断目标方法是否为幽灵方法。</p>
</blockquote>
<p>​    在每次覆写respond_to?时都应该同时覆写respond_to_missing?方法</p>
<h4 id="const-missing方法"><a href="#const-missing方法" class="headerlink" title="const_missing方法"></a>const_missing方法</h4><p>​    如果对于一个常量的引用发现找不到，则会默认调用<code>const_missing</code>方法，将常量名作为一个符号进行传递。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Module</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">const_missing</span></span><span class="token punctuation">(</span>const_name<span class="token punctuation">)</span>
		<span class="token keyword">case</span> const_name
		<span class="token keyword">when</span> <span class="token symbol">:Task</span>
			p <span class="token string-literal"><span class="token string">"我们已经更新了，请访问 Rake::Task"</span></span>
		<span class="token keyword">when</span> <span class="token symbol">:FileTask</span>
			p <span class="token string-literal"><span class="token string">"我们已经更新了，请访问 Rake::FileTask"</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># main是Object的实例，Object是Class的实例，Class的父类是Module，所以当我们使用猴子补丁修改</span>
<span class="token comment"># Module#const_missing时，main对象是继承到这个方法的。</span>
<span class="token comment"># 我们想要访问Task常量，发现并不存在，则触发了const_missing(const_name)</span>
task_class <span class="token operator">=</span> Task  <span class="token comment"># => "我们已经更新了，请访问 Rake::Task"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    在Rake中就有使用，为了兼容老版本的Task和新版本的Rake::Task。 </p>
<h4 id="method-missing隐藏Bug"><a href="#method-missing隐藏Bug" class="headerlink" title="method_missing隐藏Bug"></a>method_missing隐藏Bug</h4><blockquote>
<p>我们设计一个按照人名，抽号码的小程序</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Roulette</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method_missing</span></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
		person <span class="token operator">=</span> name<span class="token punctuation">.</span>to_s<span class="token punctuation">.</span>capitalize
		<span class="token number">3.</span>times <span class="token keyword">do</span>
      <span class="token comment"># 这里在块儿内定义了number</span>
			number <span class="token operator">=</span> rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
			puts <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">number</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">..."</span></span>
		<span class="token keyword">end</span>
    <span class="token comment"># 这里又使用了number，因为作用域的不同，运行时找不到这个变量，所以默认会找 number这个方法，因为也没有这个方法，所以调用了method_missing方法，导致不断的重入</span>
		<span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> got </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">number</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
number_of <span class="token operator">=</span> <span class="token class-name">Roulette</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
p number_of<span class="token punctuation">.</span>bob	
p number_of<span class="token punctuation">.</span>Jack	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    不知道你是否可以看出来？当程序运行时会不断方法重入，直到栈溢出。所以我们需要进行改良。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Roulette</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">method_missing</span></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
		person <span class="token operator">=</span> name<span class="token punctuation">.</span>to_s<span class="token punctuation">.</span>capitalize
		<span class="token comment"># 判断是否名字是否存在，如果不存在，直接报错</span>
		<span class="token keyword">super</span> <span class="token keyword">unless</span> <span class="token string-literal"><span class="token string">%w[Bob Frank Bill]</span></span><span class="token punctuation">.</span><span class="token keyword">include</span><span class="token operator">?</span> person
		number <span class="token operator">=</span> <span class="token number">0</span>
		<span class="token number">3.</span>times <span class="token keyword">do</span>
			number <span class="token operator">=</span> rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
			puts <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">number</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">..."</span></span>
		<span class="token keyword">end</span>
		<span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">name</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> got </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">number</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
number_of <span class="token operator">=</span> <span class="token class-name">Roulette</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
p number_of<span class="token punctuation">.</span>Bob	
p number_of<span class="token punctuation">.</span>Frank	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="白板类"><a href="#白板类" class="headerlink" title="白板类"></a>白板类</h3><blockquote>
<p>​    比如说上面的 number_of.display 我们希望实际调用 method_missing 方法，但实际上可能调用了Object.display方法，这是因为我们从Object类中继承了大量的方法，所以时常导致幽灵方法与继承方法的重复。</p>
</blockquote>
<p>​    如果实例存在继承方法，则幽灵方法是失效的。我们有两个办法：</p>
<ol>
<li>删除继承来的方法</li>
<li>写一个白板类，也就是很干净了的类</li>
</ol>
<h4 id="BasicObject"><a href="#BasicObject" class="headerlink" title="BasicObject"></a>BasicObject</h4><p>​    BasicObject是Object的父类，其中定义的实例方法很少，所以我们可以让现有的类继承BasicObject，从而可以避免继承Object类的方法，这是最简单的白板类实现方法</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># [:__send__, :!, :instance_eval, :==, :instance_exec, :!=, :equal?, :__id__]</span>
p BasicObject<span class="token punctuation">.</span>instance_methods<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><ol>
<li>Module#undef_method  删除所有的方法，包括继承的</li>
<li>Module#remove_method 只删除接受者自己的方法</li>
</ol>
<p>所以我们最终可以选择让Roulette 继承 BasicObject，或者删除指定方法</p>
<h4 id="对比动态方法与幽灵方法"><a href="#对比动态方法与幽灵方法" class="headerlink" title="对比动态方法与幽灵方法"></a>对比动态方法与幽灵方法</h4><p>​    幽灵方法更容易出现隐性Bug，所以能使用动态方法，尽量使用动态方法，除非不得不使用时，才去使用，记住如果重写 response_to? ，也要重新 response_to_missing?</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
  <span class="token comment"># 这里是my_method的作用域</span>
	x <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hi"</span></span>
	<span class="token keyword">yield</span> <span class="token string-literal"><span class="token string">"World"</span></span>
<span class="token keyword">end</span>
<span class="token comment"># 这里是顶级上下文的作用域</span>
x <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hello"</span></span>
my_method <span class="token keyword">do</span> <span class="token operator">|</span>variable<span class="token operator">|</span>
  <span class="token comment"># 这里Block内绑定的 x ，是当前对象self的 x ，和被传入的方法 my_method 内定义的x没有关系</span>
	puts <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">x</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">variable</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>  <span class="token comment">#=> Hello World</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面我们定义了一个Block，并传入给my_method，这里我们发现Block绑定了一个x变量，x变量属于self对象的，my_method内部定义的x，对于块儿内是不可见的。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
	<span class="token keyword">yield</span>
<span class="token keyword">end</span>
num <span class="token operator">=</span> <span class="token number">1</span>
my_method <span class="token keyword">do</span>
	num <span class="token operator">+=</span> <span class="token number">1</span>
	arg <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">end</span>
p num  <span class="token comment"># 这里正常输出 => 2</span>
p arg  <span class="token comment"># 这里无法输出，引入Block内定义的变量，作用域仅局限在内部，外部不可见</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>所以Block也叫做闭包，可以引用外部self的变量，Block内定义的变量仅局限于Block内</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>不论是Java，Python，Ruby都会有作用域的概念，就好像是单独的一个作用空间，一个领地，在这里有专属的局部变量</p>
<h3 id="切换作用域"><a href="#切换作用域" class="headerlink" title="切换作用域"></a>切换作用域</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">v1 <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 顶层作用域</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>  <span class="token comment"># 类作用域</span>
	v2 <span class="token operator">=</span> <span class="token number">2</span>
	p local_variables  <span class="token comment"># => [:v2]</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>  <span class="token comment"># 方法作用域</span>
		v3 <span class="token operator">=</span> <span class="token number">3</span>
		p local_variables  <span class="token comment"># => [:v3]</span>
	<span class="token keyword">end</span>
	p local_variables  <span class="token comment"># => [:v2]</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obj<span class="token punctuation">.</span>my_method
obj<span class="token punctuation">.</span>my_method
p local_variables  <span class="token comment"># => [:v1, :obj]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最初在顶层作用域 定义 v1 = 1</p>
<p>定义class MyClass，切换作用域，一旦切换作用域，绑定也会修改，v1对于MyClass内部域是不可见的，在其内部定义了一个方法和变量，当执行到实例方法内部，作用域再次切换</p>
<p>当MyClass定义完毕，再次切换回顶级作用域。</p>
<blockquote>
<p>全局变量与顶级实例变量</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token variable">$var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">incre</span></span>
		<span class="token variable">$var</span> <span class="token operator">+=</span> <span class="token number">1</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p <span class="token variable">$var</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obj<span class="token punctuation">.</span>incre
p <span class="token variable">$var</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里定义了全局变量var，发现在所有作用域都可以访问并操作到，所以一旦出现问题，很难排查。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token variable">@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
	<span class="token variable">@var</span> <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">end</span>
p <span class="token variable">@var</span>
my_method
p <span class="token variable">@var</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里定义一个顶级上下文中的实例变量，当main对象扮演self的角色，就可以访问到顶级实例变量，但如果进入其他对象作为self，则无法访问到</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token variable">@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
    <span class="token variable">@var</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"this is not top level @var"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span> 
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
p obj<span class="token punctuation">.</span>my_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>顶级实例变量 要比 全局变量 有限的安全</p>
<p>这里我们想弄清楚作用域是如何切换，绑定是如何切换的，需要了解作用域门</p>
<h3 id="作用域门"><a href="#作用域门" class="headerlink" title="作用域门"></a>作用域门</h3><p>程序一般会在三个地方，关闭之前的作用域，打开新的作用域，分别为：</p>
<ol>
<li>方法 def</li>
<li>类定义 class</li>
<li>模块儿定义 module</li>
</ol>
<p>每个关键字对应一个作用域门</p>
<blockquote>
<p>现在看到每个作用域有独立的空间，如果想要变量在作用域之间传递，该如何操作？</p>
</blockquote>
<h3 id="扁平化作用域"><a href="#扁平化作用域" class="headerlink" title="扁平化作用域"></a>扁平化作用域</h3><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">var <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Success"</span></span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 这里想访问到var</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		<span class="token comment"># 这里想访问到var</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p> 一旦切换作用域局部变量就会失效，如何能让var穿越两个作用域被访问到？</p>
</blockquote>
<p>Ruby是非常灵活的，它为一种实现提供了多种方法，上面知道了<code>class module def</code>三个关键字为作用域门，那我们使用其他方式来实现相同的结果，这样就可以避免切换作用域了</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">var <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Success"</span></span>
<span class="token comment"># 使用Class.new 切换 class关键字，避免切换作用域</span>
MyClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token keyword">do</span> 
	<span class="token comment"># 这里想访问到var</span>
	p var
  <span class="token comment"># 使用动态定义方法，替换def关键字，避免切换作用域</span>
	<span class="token keyword">define_method</span> <span class="token symbol">:my_method</span> <span class="token keyword">do</span>
		<span class="token comment"># 这里想访问到var</span>
		p var
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obg <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
obg<span class="token punctuation">.</span>my_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    如果两个作用域挤压在一起，我们通常简称为 扁平作用域</p>
<h3 id="共享作用域"><a href="#共享作用域" class="headerlink" title="共享作用域"></a>共享作用域</h3><blockquote>
<p>​    如果想在一组方法之间共享一个变量，但又不想别的方法访问到这个变量，就可以把这些方法定义在该变量所在的扁平作用域</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
  <span class="token comment"># 这里是一个局部变量，希望仅被几个方法访问到</span>
	share <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment"># 使用内核方法，调用 define_method 来定义函数，而又不用切换域，这样这几个方法就可以访问到变量</span>
	Kernel<span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:counter</span> <span class="token keyword">do</span>
		share
	<span class="token keyword">end</span>
	Kernel<span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:inc</span> <span class="token keyword">do</span> <span class="token operator">|</span>x<span class="token operator">|</span>
		share <span class="token operator">+=</span> x
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
my_method
p counter 
inc <span class="token number">4</span>
p counter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="上下文探针（instance-eval）"><a href="#上下文探针（instance-eval）" class="headerlink" title="上下文探针（instance_eval）"></a>上下文探针（instance_eval）</h3><p>这里我们学习一个新的方法：<code>instance_eval</code>,它能打开接收者的作用域，将当前对象self转为方接收者，并对其进行操作</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span>
		<span class="token variable">@v</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 这里self切换为obj</span>
obj<span class="token punctuation">.</span>instance_eval <span class="token keyword">do</span>
	p <span class="token keyword">self</span>
  <span class="token comment"># 输出的实例变量也是属于self的</span>
	p <span class="token variable">@v</span>
<span class="token keyword">end</span>
<span class="token comment"># 这里 下面三行代码都处在扁平作用域，所以Block可以使用局部变量v，并访问到obj中的实例变量</span>
v <span class="token operator">=</span> <span class="token number">2</span>
obj<span class="token punctuation">.</span>instance_eval <span class="token punctuation">&#123;</span><span class="token variable">@v</span> <span class="token operator">=</span> v<span class="token punctuation">&#125;</span>
obj<span class="token punctuation">.</span>instance_eval <span class="token punctuation">&#123;</span>p <span class="token variable">@v</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>这里需要注意一个点：instance_eval会将接收者变为当前对象self。而调用者的<strong>实例变量</strong>就落在作用域范围外，如果不了解，就会出现Bug，例如：</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">C</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span>
		<span class="token variable">@x</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">D</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">twisted_method</span></span>
    <span class="token comment"># 如果这里 @y 改为 y ，即可被访问到</span>
		<span class="token variable">@y</span> <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token comment"># 在执行下面代码之前，self为D.new，一旦执行下面的代码，C.new为self，@x在C.new中定义了，@y则没有</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>instance_eval <span class="token punctuation">&#123;</span><span class="token string-literal"><span class="token string">"@x : </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@x</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> , @y : </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@y</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">&#125;</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p <span class="token class-name">D</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>twisted_method  <span class="token comment"># => "@x : 1 , @y : "</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    这里输出发现，@y并未访问到， 可是上面的调用代码在同一个扁平作用域，原来是因为instance_eval将C.new对象变为当前对象self，调用者的实例变量就落在了作用域外了，所以访问不到为：nil，该如何操作呢？</p>
<h4 id="instance-exec"><a href="#instance-exec" class="headerlink" title="instance_exec"></a>instance_exec</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">D</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">twisted_method</span></span>
		<span class="token variable">@y</span> <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token comment"># 这里主动将 @y传递到块儿中</span>
		<span class="token class-name">C</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>instance_exec<span class="token punctuation">(</span><span class="token variable">@y</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">|</span>y<span class="token operator">|</span><span class="token string-literal"><span class="token string">"@x : </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token variable">@x</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> , @y : </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">y</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">&#125;</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="洁净室"><a href="#洁净室" class="headerlink" title="洁净室"></a>洁净室</h3><p>​    有时我们只想创建一个执行块儿的对象，这样的对象称为<code>洁净室</code>，洁净室最好继承BasicObject，变为白板类，因为当切换self后，Block调用实例方法可能会与Block所处作用域方法冲突</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 子类继承Object，并继承了hello方法</span>
<span class="token keyword">class</span> <span class="token class-name">CleanRoom</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">current_temperature</span></span>
  <span class="token keyword">end</span>
  <span class="token comment"># 这里我们进行重定义操作</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hello</span></span>
  	<span class="token comment"># 这里访问到的是 p "Hello World"</span>
  	<span class="token keyword">super</span>
  	p <span class="token string-literal"><span class="token string">"I am King"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 这里在顶级上下文中定义了方法，其实是所属Object的实例方法</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hello</span></span>
	p <span class="token string-literal"><span class="token string">"Hello World"</span></span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">CleanRoom</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>instance_eval <span class="token keyword">do</span>
  <span class="token comment"># 这里self为obj，所以Block是去self中找hello方法，如果没有，则去祖先连中查找</span>
  hello
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><p>​    目前我们使用的Block是直接执行的，我们需要让Block变为对象，可以进行打包传递，调用，我们看一下有哪些打包代码的方式。</p>
<ol>
<li>proc , 将Block转为Proc对象</li>
<li>lambda ，属于proc的变种</li>
<li>使用方法</li>
</ol>
<h4 id="Proc对象"><a href="#Proc对象" class="headerlink" title="Proc对象"></a>Proc对象</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 将Block打包为Proc</span>
inc <span class="token operator">=</span> <span class="token class-name">Proc</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">&#123;</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
<span class="token comment"># 主动调用Block</span>
p inc<span class="token punctuation">.</span>call <span class="token number">2</span>

inc_ <span class="token operator">=</span> proc <span class="token punctuation">&#123;</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
p inc<span class="token punctuation">.</span>call <span class="token number">2</span>

obj <span class="token operator">=</span> lambda <span class="token punctuation">&#123;</span><span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
p obj<span class="token punctuation">.</span>call <span class="token number">2</span>

obj_ <span class="token operator">=</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
p obj_<span class="token punctuation">.</span>call <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="amp-操作符"><a href="#amp-操作符" class="headerlink" title="&amp;操作符"></a>&amp;操作符</h4><p>​    在调用方法时，我们为其传递一个Block，可通过yield进行执行，但是如果我们想将这个Block封装起来，延迟调用，该如何操作</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 这里&amp;block将Block封装为Proc</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token operator">&amp;</span>block<span class="token punctuation">)</span>
	p name
  <span class="token comment"># 这里对其调用</span>
	block<span class="token punctuation">.</span>call
<span class="token keyword">end</span>
<span class="token comment"># 传递Block时，不需要再参数后面加 , </span>
my_method <span class="token string-literal"><span class="token string">"qsc"</span></span> <span class="token keyword">do</span> p <span class="token string-literal"><span class="token string">"Hello World"</span></span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>如果想把 Proc 再转为 Block 该怎么操作</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span>
	p <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">greeting</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> , </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token keyword">yield</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">&#125;"</span></span>
<span class="token keyword">end</span>
my_proc <span class="token operator">=</span> proc <span class="token punctuation">&#123;</span><span class="token string-literal"><span class="token string">"Bill"</span></span><span class="token punctuation">&#125;</span>
my_method<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Hello"</span></span><span class="token punctuation">,</span><span class="token operator">&amp;</span>my_proc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    现在就可以将Block与Proc相互转化了</p>
<h4 id="Lambda-和-Proc的区别"><a href="#Lambda-和-Proc的区别" class="headerlink" title="Lambda 和 Proc的区别"></a>Lambda 和 Proc的区别</h4><ol>
<li>参数校验不同</li>
<li>return定义不同</li>
</ol>
<p>​    参数校验是指：Lambda中定义两个入参，如果你没传递，或者传递多了，则会报错，如果是Proc定义两个入参，如果没传递，则变量为nil，如果传递多了，多余部分也不会使用。Lambda更严格一些</p>
<p>​    return定义不同：Lambda中使用return，表示从Lambda表达式中返回，而Proc表示从定义Proc的作用域中返回</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
  <span class="token comment"># 这里block在my_method中定义，一旦执行return就会从my_method中退出</span>
	p <span class="token operator">=</span> <span class="token class-name">Proc</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">&#125;</span>
	result <span class="token operator">=</span> p<span class="token punctuation">.</span>call  <span class="token comment"># 这里调用完，就退出定义p的作用域，所以下面执行不到</span>
	<span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span>  <span class="token comment"># 这里实际上是不可到达的</span>
<span class="token keyword">end</span>

p my_method <span class="token comment"># => 10 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Metthod对象"><a href="#Metthod对象" class="headerlink" title="Metthod对象"></a>Metthod对象</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">initialize</span></span>
		<span class="token variable">@v</span> <span class="token operator">=</span> <span class="token number">100</span>
	<span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		<span class="token variable">@v</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 通过Kernel#method方法，将obj中的方法转为一个Method对象</span>
mobj <span class="token operator">=</span> obj<span class="token punctuation">.</span>method <span class="token symbol">:my_method</span>

p mobj<span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token comment"># => Method</span>
<span class="token comment"># 主动调用</span>
p mobj<span class="token punctuation">.</span>call
mobj<span class="token punctuation">.</span>to_proc  <span class="token comment"># 将Method转为Proc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Method和Proc有什么区别？</p>
</blockquote>
<p>lambda 在定义它的作用域执行</p>
<p>Method 对象会在自身所在的对象的作用域执行，因为Method是所属对象的</p>
<h4 id="自由方法"><a href="#自由方法" class="headerlink" title="自由方法"></a>自由方法</h4><p>​    听名字感觉是一个脱离类，模块儿的一个方法，可以使用<code>Module#unbind</code>将一个方法转为自由方法，也可以使用<code>Module#instance_method</code>获取一个自由方法</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		<span class="token number">42</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
unbound <span class="token operator">=</span> MyModule<span class="token punctuation">.</span>instance_method<span class="token punctuation">(</span><span class="token symbol">:my_method</span><span class="token punctuation">)</span>
p unbound<span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token comment"># => UnboundMethod</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    自由方法并不能脱离对象执行，所以我们可以把他再绑定到一个对象中，使之再次成为Method对象，可以使用<code>UnboundMethod#bind</code>进行绑定，从某个类中分离出来的UnboundMethod，只能绑定在该类或者子类的对象上，模块儿中分离的自由方法则可以自由处置。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span>
		<span class="token number">42</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
unbound <span class="token operator">=</span> MyModule<span class="token punctuation">.</span>instance_method<span class="token punctuation">(</span><span class="token symbol">:my_method</span><span class="token punctuation">)</span>
p unbound<span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token comment"># => UnboundMethod</span>
<span class="token comment"># 这里直接在String中定义 新的方法，使用UnboundMethod</span>
<span class="token builtin">String</span><span class="token punctuation">.</span>send <span class="token symbol">:define_method</span><span class="token punctuation">,</span><span class="token symbol">:another_method</span><span class="token punctuation">,</span>unbound
p <span class="token string-literal"><span class="token string">"abc"</span></span><span class="token punctuation">.</span>another_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">result <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">self</span>
<span class="token keyword">end</span>
p result  <span class="token comment"># => MyClass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    定义类或模块儿时，内本身充当当前对象self的角色，因为类和模块儿也是对象，所以可以充当self，这里我们引入一个相关的概念：当前类</p>
<h3 id="当前类"><a href="#当前类" class="headerlink" title="当前类"></a>当前类</h3><blockquote>
<p>至今为止，有几个概念混杂在一起，当前对象，当前类，当前作用域</p>
</blockquote>
<p>​    无论程序在哪个位置，都会有一个当前对象self，同样也总是有一个当前类或模块儿的存在，定义一个方法时，这个方法将成为当前类的一个实例方法。</p>
<p>​    self可以获取当前对象，但是Ruby中并没有相应的方法获取当前类的引用，我们这里有几个规则</p>
<ol>
<li>在程序的顶层，当前类为Object，这是main对象所属的类(这就是在顶层定义方法会成为Object实例方法的原因)</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 这里定义的是private实例方法，当前类为Object，所以子类也会继承到这个方法</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">say_hello</span></span>
	p <span class="token string-literal"><span class="token string">"Hello World"</span></span>
<span class="token keyword">end</span>

<span class="token keyword">class</span> <span class="token class-name">User</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hi</span></span>
		say_hello
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 这里是可以调用成功的</span>
obj<span class="token punctuation">.</span>hi  
say_hello
obj<span class="token punctuation">.</span>send <span class="token symbol">:say_hello</span>
<span class="token comment"># 这里无法调用</span>
obj<span class="token punctuation">.</span>say_hello  <span class="token comment"># 因为say_hello是一个私有方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>在一个方法中，当前类就是当前对象的类，比如我们在一个函数中定义另一个函数，这个内部定义的函数属于当前对象的类</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">User</span>
	<span class="token comment"># 这里一旦执行，当前类为User</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span> 
		<span class="token comment"># 这里定义的函数生效，并属于User，</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">two</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>one
p User<span class="token punctuation">.</span>instance_methods<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token comment"># => [:one, :two]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>当使用class或者module打开一个类时，这个类成为当前类</li>
</ol>
<blockquote>
<p>如果我们想将类为参数，动态的给类添加一个实例方法，我们该如何操作</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_method_to</span></span><span class="token punctuation">(</span>a_class<span class="token punctuation">)</span>
  <span class="token comment"># TODO : 在 a_class上定义方法 m()</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里我们引入class_eval方法</p>
<h4 id="class-eval方法"><a href="#class-eval方法" class="headerlink" title="class_eval方法"></a>class_eval方法</h4><p>Module#class_eval方法会在一个已存在类的上下文中执行一个块儿。这听起来和<code>obj.instance_eval</code>很像。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_method_to</span></span><span class="token punctuation">(</span>a_class<span class="token punctuation">)</span>
  a_class<span class="token punctuation">.</span>class_eval <span class="token keyword">do</span>
    <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">m</span></span><span class="token punctuation">;</span> <span class="token string-literal"><span class="token string">'Hello'</span></span><span class="token punctuation">;</span> <span class="token keyword">end</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
add_method_to <span class="token builtin">String</span>
<span class="token string-literal"><span class="token string">"abc"</span></span><span class="token punctuation">.</span>m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li><p>Module#class_eval 会同时修改self和当前类，所以可以定义方法</p>
</li>
<li><p>Object#instance_eval 只修改self</p>
</li>
</ol>
<p>​    Module#class_eval功能和class类似，但更强大，因为class关键字传入 常量，而Module#class_eval，只要是类即可使用。</p>
<p>​    class也是作用域门，会切换作用域，而Module#class_eval则是扁平作用域可以引入外部变量</p>
<blockquote>
<p>Module#class_eval 也有 class_exec 可以接收额外的代码块作为参数</p>
</blockquote>
<h3 id="类实例变量"><a href="#类实例变量" class="headerlink" title="类实例变量"></a>类实例变量</h3><blockquote>
<p>这里需要声明，类实例变量 和 类实例化对象的实例变量是不同的</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 这里当前类为MyClass，self也为MyClass，这里定义@my_var实例变量，所属MyClass</span>
	<span class="token variable">@my_var</span> <span class="token operator">=</span> <span class="token number">100</span>
	<span class="token comment"># 定义MyClass的read方法，一个指向MyClass的类方法，访问@my_var是可以的</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read</span></span><span class="token punctuation">;</span> <span class="token variable">@my_var</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token comment"># 定义MyClass的实例方法write，这里的@my_var 和 外面的@my_var 并不是一个变量，作用域不同</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">write</span></span><span class="token punctuation">;</span> <span class="token variable">@my_var</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
	<span class="token comment"># 这里一样，是访问不到外部的@my_var,除非调用write方法，给类的对象创建一个@my_var</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">read</span></span><span class="token punctuation">;</span> <span class="token variable">@my_var</span><span class="token punctuation">;</span> <span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span> 
p obj<span class="token punctuation">.</span>read  <span class="token comment"># nil</span>
obj<span class="token punctuation">.</span>write <span class="token comment"># 定义 @my_var = 2</span>
p obj<span class="token punctuation">.</span>read  <span class="token comment"># @my_var = 2</span>
p MyClass<span class="token punctuation">.</span>read <span class="token comment"># @my_var = 100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    Ruby解释器假定所有的实例变量都属于当前对象self，在类定义时也如此。</p>
<blockquote>
<p>一个类实例变量只可以被类本身所访问，而不能被类的实例或子类所访问到</p>
</blockquote>
<h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>​    如果想在类中定义变量，可被子类或者实例对象访问到，可以使用类变量，它更像是Java中的静态变量.</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">C</span>
	<span class="token variable">@@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token operator">&lt;</span> <span class="token constant">C</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">hi</span></span>
	 	<span class="token variable">@@var</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">D</span><span class="token punctuation">.</span><span class="token keyword">new</span>
p obj<span class="token punctuation">.</span>hi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>需要注意一点，盲目的使用类变量也会有问题</p>
</blockquote>
<p>​    不允许在顶级上下文中定义类变量，因为main对象所属Object类，定义类变量，则所有Object子类都会继承这个类变量，也就有修改类变量的可能，在最新的Ruby编译器中已经对这个行为禁止，并爆出错误</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token variable">@@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">class</span> <span class="token class-name">User</span>
	<span class="token variable">@@var</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">end</span>
p <span class="token variable">@@var</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>这里再回顾一下Ruby中的操作符</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">p <span class="token boolean">false</span> <span class="token operator">||</span> <span class="token boolean">true</span>  <span class="token comment"># 一个为真则为真</span>
p <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span>  <span class="token comment"># 一个为假都为假</span>
p <span class="token keyword">nil</span> <span class="token operator">||</span> <span class="token string-literal"><span class="token string">"a"</span></span>     <span class="token comment"># 除了 nil 和 false，其他都为真</span>
p <span class="token string-literal"><span class="token string">"a"</span></span> <span class="token operator">||</span> <span class="token keyword">nil</span>     <span class="token comment"># || 遇到真则返回</span>
p <span class="token string-literal"><span class="token string">"a"</span></span> <span class="token operator">||</span> <span class="token string-literal"><span class="token string">'b'</span></span>

p <span class="token keyword">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token string-literal"><span class="token string">"a"</span></span>     <span class="token comment"># &amp;&amp; 遇到假则返回</span>
p <span class="token string-literal"><span class="token string">"a"</span></span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">nil</span>
p <span class="token string-literal"><span class="token string">"a"</span></span> <span class="token operator">&amp;&amp;</span> <span class="token string-literal"><span class="token string">"b"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>类对象是否可以访问到类实例变量</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 这里@var 属于 MyClass，因为MyClass也是一个对象</span>
	<span class="token variable">@var</span> <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get</span></span>
		<span class="token comment"># 这里访问，self为类的对象，作用域分离</span>
		<span class="token variable">@var</span>
	<span class="token keyword">end</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">get</span></span>
		<span class="token variable">@var</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>get  <span class="token comment"># 无法访问到</span>
p MyClass<span class="token punctuation">.</span>get      <span class="token comment"># 正常输出 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>obj.instance.eval 改变obj为self，如果在Block内定义实例变量，则该实例变量属于obj</p>
<p>Class.class_eval 改变Class为self，同时改变当前类，定义实例变量属于这个类</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">get</span></span>
		<span class="token variable">@var</span> 
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">get</span></span>
		<span class="token variable">@var</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

MyClass<span class="token punctuation">.</span>class_eval <span class="token keyword">do</span> 
	<span class="token variable">@var</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">end</span>

p MyClass<span class="token punctuation">.</span>get  <span class="token comment"># => 1</span>
p <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>get  <span class="token comment"># => nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="单件方法"><a href="#单件方法" class="headerlink" title="单件方法"></a>单件方法</h3><blockquote>
<p>我们现在想要修改一个类的实例方法有三种办法</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
<span class="token comment"># 1.0 猴子补丁</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 2.0 细化</span>
<span class="token keyword">module</span> <span class="token class-name">MyClass_Plus</span>
  refine MyClass <span class="token keyword">do</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">two</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 3.0 单件方法</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token class-name">obj</span><span class="token punctuation">.</span><span class="token function">tree</span></span>
  <span class="token comment"># 方法体</span>
<span class="token keyword">end</span>
obj<span class="token punctuation">.</span>tree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    单件方法我们可以看到是在对象上操作， 定义的函数也只针对这个对象，其他对象并没有这个方法，所以叫做单件方法，语法：<code>def obj.method_name</code></p>
<h4 id="类方法的真相"><a href="#类方法的真相" class="headerlink" title="类方法的真相"></a>类方法的真相</h4><p>​    类方法的实质是一个类的单件方法，因为类也是一个对象，给类定义单件方法，就是类方法。</p>
<h4 id="类宏"><a href="#类宏" class="headerlink" title="类宏"></a>类宏</h4><p>​    Ruby中的对象是没有属性的，对外只提供方法。所以在最初我们访问对象的实例变量时，可以写get，set方法，但是这会很麻烦，所以我们使用<code>Module#attr_accessor :var</code>访问器，这也叫做类宏</p>
<h3 id="单件类"><a href="#单件类" class="headerlink" title="单件类"></a>单件类</h3><blockquote>
<p>提问：单件方法，类方法的信息是保存在哪里？</p>
</blockquote>
<p>​    首先不在对象中，因为只有类和模块儿可以定义方法</p>
<p>​    其次也不在类中，因为无法在类的对象中共享，它们就好像是一个独立个体，存在与某个与当前类有关的地方，这个地方就是单件类，负责存储单件方法。</p>
<blockquote>
<p>那我们该如何访问到单间类内？如何看到它？</p>
</blockquote>
<p>两种方式：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
single_class <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token operator">&lt;&lt;</span> obj
	<span class="token comment"># 返回单件类</span>
	<span class="token keyword">self</span>
<span class="token keyword">end</span>
p single_class  <span class="token comment"># => #&lt;Class:#&lt;MyClass:0x0000000108beb5c8>></span>
p single_class<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token comment"># => Class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># 访问对象所属单件类，每个对象的单件类都不同</span>
<span class="token comment"># #&lt;Class:#&lt;MyClass:0x00000001051f3a78>></span>
p obj<span class="token punctuation">.</span>singleton_class
other <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># #&lt;Class:#&lt;MyClass:0x00000001051f3578>></span>
p other<span class="token punctuation">.</span>singleton_class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    单件类只有一个实例，且无法被继承，单件方法就定义在单件类中</p>
<h4 id="单件类-和-方法查找"><a href="#单件类-和-方法查找" class="headerlink" title="单件类 和 方法查找"></a>单件类 和 方法查找</h4><blockquote>
<p>单件类的超类是什么？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token comment"># #&lt;Class:#&lt;MyClass:0x00000001051f3a78>></span>
p obj<span class="token punctuation">.</span>singleton_class
<span class="token comment"># 对象的单件类的超类 就是 对象的所属类</span>
p obj<span class="token punctuation">.</span>singleton_class<span class="token punctuation">.</span>superclass  <span class="token comment"># => MyClass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>单件类是否在祖先链中，因为这涉及到方法的查找</p>
</blockquote>
<p>​    单件类是存在于祖先链中的，而且单件类的超类为对象的所属类，所以在祖先链中排在当前类之前。方法查找也是按照这个顺序进行查找的。所以对象访问方法时，是先在单件类中访问，然后再去当前类中访问。</p>
<blockquote>
<p>类的单件类的超类就是超类的单件类</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">D</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">E</span> <span class="token operator">&lt;</span> <span class="token constant">D</span>
<span class="token keyword">end</span>

p <span class="token constant">D</span><span class="token punctuation">.</span>singleton_class   <span class="token comment"># => #&lt;Class:D></span>
p <span class="token constant">E</span><span class="token punctuation">.</span>singleton_class   <span class="token comment"># => #&lt;Class:E></span>
p <span class="token constant">D</span><span class="token punctuation">.</span>singleton_class<span class="token punctuation">.</span>superclass  <span class="token comment"># => #&lt;Class:Object></span>
p <span class="token constant">E</span><span class="token punctuation">.</span>singleton_class<span class="token punctuation">.</span>superclass  <span class="token comment"># => #&lt;Class:D></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>上面的定义看起来有点儿绕，Ruby为何这样设计？</p>
</blockquote>
<p>​    因为这样就可以在子类中调用父类的类方法</p>
<p>​    <img src="/Users/qinsicheng/Library/Application Support/typora-user-images/image-20230103164540176.png" alt="image-20230103164540176" style="zoom:80%;" /></p>
<h4 id="七条规则"><a href="#七条规则" class="headerlink" title="七条规则"></a>七条规则</h4><ol>
<li>对象：要么是普通对象，要么是模块儿</li>
<li>模块：可以是普通模块，一个类或一个单件类</li>
<li>方法：存在与一个模块中，通常定义在类中</li>
<li>对象都有自己真正的类，要么是普通类，要么是单件类</li>
<li>除了BasicObject没有超类，其他的类都有一个祖先</li>
<li>一个对象的单件类的超类，就是这对象的类</li>
<li>一个类的单件类的超类，就是这个类的超类的单件类</li>
<li>调用一个方法时，Ruby先找到接收者真的类，再向上进入祖先链</li>
</ol>
<h4 id="类方法的语法"><a href="#类方法的语法" class="headerlink" title="类方法的语法"></a>类方法的语法</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
<span class="token comment"># 1</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token function">one</span></span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
<span class="token comment"># 2</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">two</span></span> <span class="token punctuation">;</span> <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 3</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">class</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">self</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">three</span></span> <span class="token punctuation">;</span><span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="单件类-和-instance-eval-方法"><a href="#单件类-和-instance-eval-方法" class="headerlink" title="单件类 和 instance_eval 方法"></a>单件类 和 instance_eval 方法</h4><p>​    之前我们说<code>instance_eval</code>修改self，实际上也修改当前类为接收者的单件类。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">s1 <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"abc"</span></span>

s1<span class="token punctuation">.</span>instance_eval <span class="token keyword">do</span>
  <span class="token comment"># 这里的swooh！属于 self对象，为对象的单件方法</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">swoosh</span></span><span class="token operator">!</span>
		reverse
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

p s1<span class="token punctuation">.</span>swoosh<span class="token operator">!</span>   <span class="token comment"># => cba</span>
s2 <span class="token operator">=</span> <span class="token string-literal"><span class="token string">'qsc'</span></span>  
p s2<span class="token punctuation">.</span>respond_to<span class="token operator">?</span><span class="token punctuation">(</span><span class="token symbol">:swoosh!</span><span class="token punctuation">)</span>  <span class="token comment"># => false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="类扩展"><a href="#类扩展" class="headerlink" title="类扩展"></a>类扩展</h3><blockquote>
<p>​    我们之前再module中定义方法，在类中<code>include和pretend</code>，将模块儿方法转为类的实例方法，那我们是否可以将module中的方法转为类的类方法？</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		p <span class="token string-literal"><span class="token string">"Hello World"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token comment"># 在单件类中引入module，self所指MyClass，所以继承的方法为MyClass的类方法，</span>
	<span class="token keyword">class</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">self</span>
		<span class="token keyword">include</span> MyModule
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
MyClass<span class="token punctuation">.</span>my_method  <span class="token comment"># => "Hello World"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​        这称为类扩展</p>
<h4 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h4><pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		p <span class="token string-literal"><span class="token string">"Hello World"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
<span class="token keyword">class</span> <span class="token operator">&lt;&lt;</span> obj
	<span class="token comment"># 单件类所属obj，所以引入的方法，会作为对象的单件方法</span>
	<span class="token keyword">include</span> MyModule
<span class="token keyword">end</span>
obj<span class="token punctuation">.</span>my_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    这称为对象扩展</p>
<blockquote>
<p>类扩展，对象扩展 因为用的很多，所以Ruby提供了<code>Object#extend</code>方法</p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">MyModule</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		p <span class="token string-literal"><span class="token string">"Hello World"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">extend</span> MyModule
<span class="token keyword">end</span>
MyClass<span class="token punctuation">.</span>my_method

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span><span class="token keyword">extend</span> MyModule
obj<span class="token punctuation">.</span>my_method<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="方法包装器"><a href="#方法包装器" class="headerlink" title="方法包装器"></a>方法包装器</h3><blockquote>
<p>如何在原有函数不修改的前提下，对方法做增强，在此之前我们介绍一些新的东西</p>
</blockquote>
<h4 id="方法别名"><a href="#方法别名" class="headerlink" title="方法别名"></a>方法别名</h4><p>​    <code>alias_method :new_method_name , :old_method_name</code> 对方法起一个别名</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span>
		p <span class="token string-literal"><span class="token string">"Hello one"</span></span>
	<span class="token keyword">end</span>
	alias_method <span class="token symbol">:two</span><span class="token punctuation">,</span><span class="token symbol">:one</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>one
obj<span class="token punctuation">.</span>two<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre><code> 定义方法时，并不是修改这个方法，而是定义一个新的方法，并将之前存在的方法名从新绑定，只要老方法还存在一个绑定，就仍可调用
</code></pre>
<h4 id="环绕别名"><a href="#环绕别名" class="headerlink" title="环绕别名"></a>环绕别名</h4><ol>
<li>给方法定义一个别名</li>
<li>重定义这个方法</li>
<li>新方法中调用老的方法</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span> 
		p <span class="token string-literal"><span class="token string">"Hello one"</span></span>
	<span class="token keyword">end</span>

	alias_method <span class="token symbol">:two</span><span class="token punctuation">,</span><span class="token symbol">:one</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">one</span></span>
		two
		p <span class="token string-literal"><span class="token string">"Hello I am new one"</span></span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>

obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span>
obj<span class="token punctuation">.</span>one
obj<span class="token punctuation">.</span>two<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="更多方法包装器"><a href="#更多方法包装器" class="headerlink" title="更多方法包装器"></a>更多方法包装器</h4><ol>
<li>细化：使用细化，可以从新定义方法，如果定义重名方法，使用super则可调用到原先的内容</li>
<li>Module#prepend：因为会将引入module放入当前类的祖父链位置的前面，所以也会覆盖掉当前类中定义的方法，使用super则可调用到原先的内容</li>
</ol>
<h3 id="测试：打破数据规律"><a href="#测试：打破数据规律" class="headerlink" title="测试：打破数据规律"></a>测试：打破数据规律</h3><blockquote>
<p>让 1 + 1 = 3</p>
</blockquote>
<p>绝大部分Ruby操作符实际上是方法， 例如整数的+只是名为Fixnum#+方法的语法糖，编写1+1时。实际上为：<code>1.+(1)</code>。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Fixnum</span>
	alias_method <span class="token symbol">:old_plus</span> <span class="token punctuation">,</span> <span class="token operator">:</span><span class="token operator">+</span>

	<span class="token keyword">def</span> <span class="token operator">+</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
		<span class="token keyword">self</span><span class="token punctuation">.</span>old_plus<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span>old_plus<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
p <span class="token number">1</span><span class="token operator">+</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>务必要慎用这种能力</p>
<h2 id="编写代码的代码"><a href="#编写代码的代码" class="headerlink" title="编写代码的代码"></a>编写代码的代码</h2><h3 id="Kernel-eval"><a href="#Kernel-eval" class="headerlink" title="Kernel#eval"></a>Kernel#eval</h3><p>​    前面我们学习了：<code>instance_eval , class_eval</code>,现在我要学习<code>Kernel#eval</code>方法，它的作用是执行一段<strong>代码字符串</strong></p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 执行 "p 123" 这段字符串，p 123表示输出 123 </span>
eval <span class="token string-literal"><span class="token string">"p 123"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​    代码字符串也可以访问局部变量</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">var <span class="token operator">=</span> <span class="token number">1</span>
eval <span class="token string-literal"><span class="token string">"p var"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="Binding-绑定对象"><a href="#Binding-绑定对象" class="headerlink" title="Binding 绑定对象"></a>Binding 绑定对象</h3><p>​    Binding是用一个对象表示完整的作用域，可以使用eval方法在这个Binding对象所携带的作用域中执行代码，Kernel#binding方法可以用来常见Binding对象</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">MyClass</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_thod</span></span>
    <span class="token variable">@x</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token comment"># 返回binding</span>
    binding
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
obj <span class="token operator">=</span> <span class="token class-name">MyClass</span><span class="token punctuation">.</span><span class="token keyword">new</span><span class="token punctuation">.</span>my_thod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>​    可以把Binding对象看作是一个闭包，它只包含作用域而不包含代码，对于eval方法，可以传递一个Binding对象作为额外参数，代码可以在这个Binding对象所携带的作用域中执行</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">eval <span class="token string-literal"><span class="token string">"p @x"</span></span> <span class="token punctuation">,</span> obj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    Ruby还定义了一个预定义常量<code>TOPLEVEL_BINDING</code>,它表示顶级作用域的Binding对象。可以在程序任务地方访问到。</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">eval <span class="token string-literal"><span class="token string">"self"</span></span><span class="token punctuation">,</span><span class="token constant">TOPLEVEL_BINDING</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    其中在我们最早使用Ruby时都使用过<code>irb</code>,其实就是解析控制台或者文件输入，再把每一行代码传递给eval方法执行，这种类型的程序有时被称为<code>代码处理器</code></p>
<p>​    eval方法后面三个为可选参数，statement代表执行语句，@binding表示所在作用域，file表示文件，line表示执行行号,这对于查找问题时比较方便</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">eval<span class="token punctuation">(</span>statement<span class="token punctuation">,</span><span class="token variable">@binding</span><span class="token punctuation">,</span>file<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="对比代码字符串-与-块"><a href="#对比代码字符串-与-块" class="headerlink" title="对比代码字符串 与 块"></a>对比代码字符串 与 块</h3><p>eval 只能执行代码字符串</p>
<p>Instance_eval，class_eval 可以执行Block，也能执行代码字符串</p>
<p>一般能使用Block，就使用Block</p>
<h4 id="eval麻烦"><a href="#eval麻烦" class="headerlink" title="eval麻烦"></a>eval麻烦</h4><ol>
<li>不能利用编辑器的功能特性，例如高亮</li>
<li>难以阅读与修改</li>
<li>错误隐藏到执行期</li>
<li>安全性！！！</li>
</ol>
<h4 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h4><p>​    这里用Java操作SQL时，遇到的SQL注入问题为例，就是我们在执行SQL前，如果SQL使用字符串拼接，如果用户传递恶意参数，就会导致SQL注入问题，代码注入也是类似的。</p>
<h4 id="防止代码注入"><a href="#防止代码注入" class="headerlink" title="防止代码注入"></a>防止代码注入</h4><p>​    有些人会禁用eval方法，毕竟可以找到替换的方式，Ruby也提供了更安全的方法</p>
<h4 id="污染对象和安全级别"><a href="#污染对象和安全级别" class="headerlink" title="污染对象和安全级别"></a>污染对象和安全级别</h4><p>​    Ruby会自动把不安全对象标记为污染对象，比如：Web表单，文件，命令行读取，可以通过<code>obj.tainted?</code> 来判断</p>
<h4 id="安全级别"><a href="#安全级别" class="headerlink" title="安全级别"></a>安全级别</h4><p>​    可以通过给$SAFE全局变量赋值来实现，一共有四个级别</p>
<p>0 ： 随意操作</p>
<p>1 ： 拒绝执行污染字符串</p>
<p>2 ： 禁止绝大多数与文件相关的操作</p>
<p>3 ： 每个创建对象都为被污染</p>
<p>​    为了谨慎使用安全级别，可以为eval方法创建一个可控环境，也称为<strong>沙盒</strong>，比如在一个块儿内，执行eval方法。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​    写一个attr_accessor类宏类似的方法，attr_checked，与访问器类似，但是会对属性进行校验，attr_checked 可以接受属性名和代码块，代码块用来进行校验，如果是对属性赋值，判断Block中是否为true，如果为false则报错。需求通过一组代码进行展示</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 这里是一个测试gem ，使用 gem install test-unit</span>
<span class="token keyword">require</span> <span class="token string-literal"><span class="token string">"test/unit"</span></span>
<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">;</span><span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">TestCheckedAttribute</span> <span class="token operator">&lt;</span> Test<span class="token double-colon punctuation">::</span>Unit<span class="token double-colon punctuation">::</span>TestCase
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">setup</span></span>
    <span class="token comment"># 在Person类中，加入 age 的读写方法，并对age的写操作进行校验</span>
		add_checked_attribute<span class="token punctuation">(</span>Person<span class="token punctuation">,</span><span class="token symbol">:age</span><span class="token punctuation">)</span>
		<span class="token variable">@bob</span> <span class="token operator">=</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">new</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test_accept_vaild_values</span></span>
		<span class="token variable">@bob</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span>
		assert_equal <span class="token number">20</span><span class="token punctuation">,</span><span class="token variable">@bob</span><span class="token punctuation">.</span>age
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test_refuses_nil_values</span></span>
		assert_raises RuntimeError<span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">do</span>
			<span class="token variable">@bob</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token keyword">nil</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>

	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">test_refuses_false_values</span></span>
		assert_raises RuntimeError<span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">do</span>
			<span class="token variable">@bob</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token boolean">false</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token comment"># 这里是我们负责编写的代码 ， klass表示一个类对象，attribute表示需要给该类加入属性</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_checked_attribute</span></span><span class="token punctuation">(</span>klass<span class="token punctuation">,</span>attribute<span class="token punctuation">)</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ol>
<li>使用eval进行快速的单元测试</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token comment"># 先定义一个函数，利用eval方法执行字符串代码</span>
<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_checked_attribute</span></span><span class="token punctuation">(</span>klass<span class="token punctuation">,</span>attribute<span class="token punctuation">)</span>
	eval "
	  <span class="token comment"># 打开类</span>
		<span class="token keyword">class</span> <span class="token comment">#&#123;klass&#125;</span>
			<span class="token comment"># 根据参数生成，get，set方法</span>
			<span class="token keyword">def</span> <span class="token comment">#&#123;attribute&#125;=(value)</span>
				<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">'Invalid attribute'</span></span> <span class="token keyword">unless</span> value
				@<span class="token comment">#&#123;attribute&#125; = value</span>
			<span class="token keyword">end</span>

			<span class="token keyword">def</span> <span class="token comment">#&#123;attribute&#125;()</span>
				@<span class="token comment">#&#123;attribute&#125;</span>
			<span class="token keyword">end</span>
		<span class="token keyword">end</span>
	"
<span class="token keyword">end</span>
<span class="token comment"># 这里对String添加属性my_attr</span>
add_checked_attribute<span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span><span class="token symbol">:my_attr</span><span class="token punctuation">)</span>
obj <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"a"</span></span>
obj<span class="token punctuation">.</span>my_attr <span class="token operator">=</span> <span class="token number">123</span>
p obj<span class="token punctuation">.</span>my_attr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>重构add_checked_attribute方法，把eval方法使用Ruby方法替换掉</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_checked_attribute</span></span><span class="token punctuation">(</span>klass<span class="token punctuation">,</span>attribute<span class="token punctuation">)</span>
	<span class="token comment"># 这里使用class_eval打开类的作用域，替换eval，因为替换后无法使用class，因为class关键字无法接受使用参数作为类名</span>
	klass<span class="token punctuation">.</span>class_eval <span class="token keyword">do</span>
		<span class="token comment"># 使用扁平作用域，使用define_method 替换 def，因为这里方法名也是动态的</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">="</span></span> <span class="token keyword">do</span> <span class="token operator">|</span>value<span class="token operator">|</span>
			<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">unless</span> value
      <span class="token comment"># 这里通过Object#instance_variable_* 方法来操作实例比变量</span>
			instance_variable_set<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>value<span class="token punctuation">)</span>
		<span class="token keyword">end</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> <span class="token keyword">do</span>
			instance_variable_get<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span>
add_checked_attribute<span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span><span class="token symbol">:my_attr</span><span class="token punctuation">)</span>
obj <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"a"</span></span>
obj<span class="token punctuation">.</span>my_attr <span class="token operator">=</span> <span class="token number">123</span>
p obj<span class="token punctuation">.</span>my_attr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>完成通过一个Block来校验属性，</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">def</span> <span class="token method-definition"><span class="token function">add_checked_attribute</span></span><span class="token punctuation">(</span>klass<span class="token punctuation">,</span>attribute<span class="token punctuation">,</span><span class="token operator">&amp;</span>validation<span class="token punctuation">)</span>
	klass<span class="token punctuation">.</span>class_eval <span class="token keyword">do</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">=&#125;"</span></span> <span class="token keyword">do</span> <span class="token operator">|</span>value<span class="token operator">|</span>
			<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">unless</span> validation<span class="token punctuation">.</span>call<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
			instance_variable_set <span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>value
		<span class="token keyword">end</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> <span class="token keyword">do</span>
			instance_variable_get <span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li>内核方法改造成一个类宏，让它对所有的类定义中都可用，我们试着在class或module中定义，并且我们不需要再指类对象，通过self即可读取到</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Class</span>
  <span class="token comment"># 这样所有对象都有拥有这个方法了</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">attr_checked</span></span><span class="token punctuation">(</span>attribute<span class="token punctuation">,</span><span class="token operator">&amp;</span>validation<span class="token punctuation">)</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">="</span></span> <span class="token keyword">do</span> <span class="token operator">|</span>value<span class="token operator">|</span>
			<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">unless</span> validation<span class="token punctuation">.</span>call<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
			instance_variable_set<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>value<span class="token punctuation">)</span>
		<span class="token keyword">end</span>
		<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> 
			instance_variable_get<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h4><p>​    也就是在代码运行中，有各种事件，我们可以利用事件进行操作，这个就叫做钩子方法</p>
<ol>
<li>类被继承时触犯</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">String</span>
  <span class="token comment"># inherited方法为Class的实例方法，我们可以进行覆写操作</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">inherited</span></span><span class="token punctuation">(</span>subclass<span class="token punctuation">)</span>
    p <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content"><span class="token keyword">self</span></span><span class="token delimiter punctuation">&#125;</span></span><span class="token string"> was inherited by </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">subclass</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li>模块儿被引入</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M1</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">included</span></span><span class="token punctuation">(</span>othermod<span class="token punctuation">)</span>
    p <span class="token string-literal"><span class="token string">"M1 was included into </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">othermod</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">module</span> <span class="token class-name">M2</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">prepended</span></span><span class="token punctuation">(</span>othermod<span class="token punctuation">)</span>
    p <span class="token string-literal"><span class="token string">"M2 was prepended to </span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">othermod</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
<span class="token keyword">class</span> <span class="token class-name">C</span>
  <span class="token keyword">include</span> <span class="token constant">M1</span>
  <span class="token keyword">prepend</span> <span class="token constant">M2</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="3">
<li>模块儿新增方法事件</li>
</ol>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">M</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">method_added</span></span><span class="token punctuation">(</span>method<span class="token punctuation">)</span>
    p <span class="token string-literal"><span class="token string">"New method: M#</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">method</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span>
  <span class="token keyword">end</span>
  
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">my_method</span></span><span class="token punctuation">;</span><span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>我们现在需要保证，引入CheckedAttributes的类才运行使用<code>attr_checked</code></p>
</blockquote>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token class-name">CheckedAttributes</span>
	<span class="token comment"># 当类include CheckedAttributes 时被触发</span>
	<span class="token keyword">def</span> <span class="token method-definition"><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">included</span></span><span class="token punctuation">(</span>base<span class="token punctuation">)</span>
		<span class="token comment"># 将类extend ClassMethods，也就是转为base类的类方法</span>
		base<span class="token punctuation">.</span><span class="token keyword">extend</span> ClassMethods
	<span class="token keyword">end</span>

	<span class="token keyword">module</span> <span class="token class-name">ClassMethods</span>
		<span class="token keyword">def</span> <span class="token method-definition"><span class="token function">attr_checked</span></span><span class="token punctuation">(</span>attribute<span class="token punctuation">,</span><span class="token operator">&amp;</span>validation<span class="token punctuation">)</span>
			<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">="</span></span> <span class="token keyword">do</span> <span class="token operator">|</span>value<span class="token operator">|</span>
				<span class="token keyword">raise</span> <span class="token string-literal"><span class="token string">"Invalid attribute"</span></span> <span class="token keyword">unless</span> validation<span class="token punctuation">.</span>call<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
				instance_variable_set<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">,</span>value<span class="token punctuation">)</span>
			<span class="token keyword">end</span>
			<span class="token keyword">define_method</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span> 
				instance_variable_get<span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"@</span><span class="token interpolation"><span class="token delimiter punctuation">#&#123;</span><span class="token content">attribute</span><span class="token delimiter punctuation">&#125;</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
			<span class="token keyword">end</span>
		<span class="token keyword">end</span>
	<span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    这里我们编写了自己的类宏，并使用了钩子方法。我们已经可以所使用的对象为所欲为，剩下的就交给我们不断的实践。后面我们将开启Rails之旅。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.chengling.cloud">庚辰</a></span></div><!--.post-copyright__type--><!--  span.post-copyright-meta= _p('post.copyright.link') + ": "--><!--  span.post-copyright-info--><!--    a(href=url_for(url))= theme.post_copyright.decode ? decodeURI(url) : url--><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.chengling.cloud" target="_blank">玲辰书斋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%83%E7%BC%96%E7%A8%8B/">元编程</a></div><div class="post_share"><div class="social-share" data-image="/img/default_top_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/Linux/shell%E7%9A%84%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8.html"><img class="prev-cover" src="/img/default_top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Shell的常规使用</div></div></a></div><div class="next-post pull-right"><a href="/post/Ruby/Ruby%20On%20Rails.html"><img class="next-cover" src="/img/default_top_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">庚辰</div><div class="author-info__description">要么读书，要么旅行，身体和心灵总有一个要在路上.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">元编程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">对象模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%9C%9F%E7%9B%B8"><span class="toc-number">2.1.</span> <span class="toc-text">类的真相</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">实例变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%9C%9F%E7%9B%B8-1"><span class="toc-number">2.1.3.</span> <span class="toc-text">类的真相</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.5.</span> <span class="toc-text">方法查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kernel%E6%A8%A1%E5%9D%97%E5%84%BF"><span class="toc-number">2.1.6.</span> <span class="toc-text">Kernel模块儿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.7.</span> <span class="toc-text">执行方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.1.8.</span> <span class="toc-text">顶层上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E5%8C%96"><span class="toc-number">2.1.9.</span> <span class="toc-text">细化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%86%E5%8C%96%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">2.1.9.1.</span> <span class="toc-text">细化的陷阱</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">动态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">动态调用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.2.</span> <span class="toc-text">动态定义方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%9E%84Computer%E7%B1%BB"><span class="toc-number">3.1.3.</span> <span class="toc-text">重构Computer类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#method-missing%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">method_missing方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const-missing%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">const_missing方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#method-missing%E9%9A%90%E8%97%8FBug"><span class="toc-number">3.2.2.</span> <span class="toc-text">method_missing隐藏Bug</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E6%9D%BF%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">白板类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BasicObject"><span class="toc-number">3.3.1.</span> <span class="toc-text">BasicObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">删除方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B9%BD%E7%81%B5%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">对比动态方法与幽灵方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">4.</span> <span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.1.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.2.</span> <span class="toc-text">切换作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%A8"><span class="toc-number">4.3.</span> <span class="toc-text">作用域门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E5%8C%96%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.4.</span> <span class="toc-text">扁平化作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.5.</span> <span class="toc-text">共享作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%8E%A2%E9%92%88%EF%BC%88instance-eval%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">上下文探针（instance_eval）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#instance-exec"><span class="toc-number">4.6.1.</span> <span class="toc-text">instance_exec</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%81%E5%87%80%E5%AE%A4"><span class="toc-number">4.7.</span> <span class="toc-text">洁净室</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.8.</span> <span class="toc-text">可调用对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Proc%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.8.1.</span> <span class="toc-text">Proc对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#amp-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.8.2.</span> <span class="toc-text">&amp;操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda-%E5%92%8C-Proc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.8.3.</span> <span class="toc-text">Lambda 和 Proc的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metthod%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.8.4.</span> <span class="toc-text">Metthod对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%94%B1%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.5.</span> <span class="toc-text">自由方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">5.</span> <span class="toc-text">类定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">当前类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#class-eval%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">class_eval方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">类实例变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">类变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">单件方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E7%9C%9F%E7%9B%B8"><span class="toc-number">5.3.1.</span> <span class="toc-text">类方法的真相</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%AE%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">类宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BB%B6%E7%B1%BB"><span class="toc-number">5.4.</span> <span class="toc-text">单件类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BB%B6%E7%B1%BB-%E5%92%8C-%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE"><span class="toc-number">5.4.1.</span> <span class="toc-text">单件类 和 方法查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E6%9D%A1%E8%A7%84%E5%88%99"><span class="toc-number">5.4.2.</span> <span class="toc-text">七条规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">5.4.3.</span> <span class="toc-text">类方法的语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%BB%B6%E7%B1%BB-%E5%92%8C-instance-eval-%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.4.</span> <span class="toc-text">单件类 和 instance_eval 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%89%A9%E5%B1%95"><span class="toc-number">5.5.</span> <span class="toc-text">类扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95"><span class="toc-number">5.5.1.</span> <span class="toc-text">对象扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">方法包装器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%88%AB%E5%90%8D"><span class="toc-number">5.6.1.</span> <span class="toc-text">方法别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E7%BB%95%E5%88%AB%E5%90%8D"><span class="toc-number">5.6.2.</span> <span class="toc-text">环绕别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E6%96%B9%E6%B3%95%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">5.6.3.</span> <span class="toc-text">更多方法包装器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%EF%BC%9A%E6%89%93%E7%A0%B4%E6%95%B0%E6%8D%AE%E8%A7%84%E5%BE%8B"><span class="toc-number">5.7.</span> <span class="toc-text">测试：打破数据规律</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">6.</span> <span class="toc-text">编写代码的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kernel-eval"><span class="toc-number">6.1.</span> <span class="toc-text">Kernel#eval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binding-%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.</span> <span class="toc-text">Binding 绑定对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E4%BB%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2-%E4%B8%8E-%E5%9D%97"><span class="toc-number">6.3.</span> <span class="toc-text">对比代码字符串 与 块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#eval%E9%BA%BB%E7%83%A6"><span class="toc-number">6.3.1.</span> <span class="toc-text">eval麻烦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="toc-number">6.3.2.</span> <span class="toc-text">代码注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="toc-number">6.3.3.</span> <span class="toc-text">防止代码注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%A1%E6%9F%93%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB"><span class="toc-number">6.3.4.</span> <span class="toc-text">污染对象和安全级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%BA%A7%E5%88%AB"><span class="toc-number">6.3.5.</span> <span class="toc-text">安全级别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">6.4.</span> <span class="toc-text">测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.1.</span> <span class="toc-text">钩子方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">6.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/Linux/shell%E7%9A%84%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8.html" title="Shell的常规使用"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shell的常规使用"/></a><div class="content"><a class="title" href="/post/Linux/shell%E7%9A%84%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8.html" title="Shell的常规使用">Shell的常规使用</a><time datetime="2023-01-10T01:00:04.000Z" title="发表于 2023-01-10 09:00:04">2023-01-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/Ruby/Ruby%E5%85%83%E7%BC%96%E7%A8%8B.html" title="Ruby元编程"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ruby元编程"/></a><div class="content"><a class="title" href="/post/Ruby/Ruby%E5%85%83%E7%BC%96%E7%A8%8B.html" title="Ruby元编程">Ruby元编程</a><time datetime="2023-01-02T02:30:12.000Z" title="发表于 2023-01-02 10:30:12">2023-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/Ruby/Ruby%20On%20Rails.html" title="无题"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/post/Ruby/Ruby%20On%20Rails.html" title="无题">无题</a><time datetime="2022-12-27T15:05:50.093Z" title="发表于 2022-12-27 23:05:50">2022-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E6%BC%94%E5%8C%96%E8%BF%87%E7%A8%8B.html" title="查找算法的演化过程"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="查找算法的演化过程"/></a><div class="content"><a class="title" href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E6%BC%94%E5%8C%96%E8%BF%87%E7%A8%8B.html" title="查找算法的演化过程">查找算法的演化过程</a><time datetime="2022-12-17T13:27:04.000Z" title="发表于 2022-12-17 21:27:04">2022-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/JVM/12_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html" title="Java内存模型与线程"><img src="/img/default_top_img.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java内存模型与线程"/></a><div class="content"><a class="title" href="/post/JVM/12_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html" title="Java内存模型与线程">Java内存模型与线程</a><time datetime="2022-12-11T11:02:04.000Z" title="发表于 2022-12-11 19:02:04">2022-12-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 庚辰</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="498210" data-server="netease" data-type="song" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>