{"total":23,"pageSize":13,"pageCount":2,"data":[{"title":"拦截器与过滤器的区别","uid":"2b2e8451f755e036c0af04fba68240df","slug":"Web/拦截器与过滤器的区别","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:02:50.203Z","comments":true,"path":"api/articles/Web/拦截器与过滤器的区别.json","cover":"/img/default_top_img.jpg","text":"拦截器与过滤器的区别 底层思想是什么？ 拦截器与过滤器都是基于AOP面向切面编程的思想来实现的。 两者有什么相同，有什么不同？ 相同点：都可以对请求做出统一的处理，例如在方法调用前进行一些操作，在方法调后后处理一些操作 不同点： 拦截器是Spring提供的（org.springf...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"Web","slug":"Web","count":1,"path":"api/categories/Web.json"}],"tags":[{"name":"Filter","slug":"Filter","count":1,"path":"api/tags/Filter.json"},{"name":"Interceptor","slug":"Interceptor","count":1,"path":"api/tags/Interceptor.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"后端风云","uid":"1b78b57250af97fad0b302e86d2e91a2","slug":"分布式/后端风云","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T07:25:41.787Z","comments":true,"path":"api/articles/分布式/后端风云.json","cover":"/img/default_top_img.jpg","text":"后端风云​ 本文简单概况了一下刘欣老师的《码农翻身》的后端风云章，这本书强烈推荐给大家，每看一遍都有不同的感觉，通俗易懂且知识面大而全。居家旅行，必备良药！！！ 早期初级阶段： ​ 在我们早期学习 javaWeb阶段，将订单模块儿，购物车模块儿，支付模块儿都写在了一个项目中，并访...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"分布式","slug":"分布式","count":2,"path":"api/categories/分布式.json"}],"tags":[],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"分布式事务","uid":"c064617a2958c28ea23700a4261c6075","slug":"分布式/分布式事务","date":"2022-11-25T05:03:04.000Z","updated":"2022-12-03T09:27:00.033Z","comments":true,"path":"api/articles/分布式/分布式事务.json","cover":[],"text":"简介​ 我们在过去总是使用本地事务，也就是数据库提供的事务操作，其中具有ACID的特性，但在如今我们的各个模块儿被拆分，服务与服务间相互调用，简单来说就是需要跨进程的事务，我们来想一下现有的本地事务是否能解决分布式事务。情况1：跨JVM，跨数据库产生分布式事务 graph TD;...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"分布式","slug":"分布式","count":2,"path":"api/categories/分布式.json"}],"tags":[{"name":"事务","slug":"事务","count":1,"path":"api/tags/事务.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"手写线程池","uid":"df1cff2ea6b0a8229883d729950dd5e6","slug":"并发/手写线程池","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:50:12.412Z","comments":true,"path":"api/articles/并发/手写线程池.json","cover":"/img/default_top_img.jpg","text":"手写线程池 ​ 我们从初级阶段自己创建线程去异步执行任务，到后期使用线程池不断执行任务，原理书上都有，但都是字面意思，无法深入理解，所以打算自己进行实现。 阶段一： 123456new Thread(new Runnable() &#123; @Override public v...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"并发","slug":"并发","count":2,"path":"api/categories/并发.json"}],"tags":[{"name":"线程池","slug":"线程池","count":1,"path":"api/tags/线程池.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"并发编程","uid":"be447ed25be14672c8ade5d39be9da07","slug":"并发/并发编程","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:49:54.174Z","comments":true,"path":"api/articles/并发/并发编程.json","cover":"/img/default_top_img.jpg","text":"基础的概念什么是并发操作？利用多核CPU去完成任务，类似于使用影分身去完成不同的作业，这肯定比我一个人一个个写要快的多 什么时候可以使用并发？当有多核CPU时。如果只有一个CPU，那并发实际上只是线程的不断切换，好比我在数学作业上先写点儿，再到语文上再写点儿，因为处理的很快，给人...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"并发","slug":"并发","count":2,"path":"api/categories/并发.json"}],"tags":[{"name":"并发","slug":"并发","count":1,"path":"api/tags/并发.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Mysql的事务与索引","uid":"99be73816d71c90e1cc1cbf82e76416f","slug":"数据库/Mysql的事务与索引","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T07:26:26.008Z","comments":true,"path":"api/articles/数据库/Mysql的事务与索引.json","cover":"/img/default_top_img.jpg","text":"Mysql事务与索引 ​ 需求：先从数据库中读取摸一个字段的值，然后在该字段上的基础上进行修改，由于操作不是原子性，无法保证线程安全，也就是当A线程读取到1时，想+1，赋值为2。而B线程已经将数据修改为2了，那么A线程应该是在2的基础上+1，赋值为3。但实际中可能该值都到8了，A...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":1,"path":"api/tags/Mysql.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"第三章：二叉树问题","uid":"ef3a6aac56d074894be545c71d6959e7","slug":"数据结构/第三章：二叉树问题","date":"2022-11-25T05:03:04.000Z","updated":"2022-12-01T02:13:16.426Z","comments":true,"path":"api/articles/数据结构/第三章：二叉树问题.json","cover":"/img/default_top_img.jpg","text":"树形dp套路在做树结构的题目中，如果求解规则可以分为，以某个节点为子树，先向左要数据，再向右要数据，最后返回总数据，我们就可以使用该套路。 递归进行遍历 1234567891011public static void QTraverse2(Point tree) &#123; i...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":3,"path":"api/categories/数据结构.json"}],"tags":[{"name":"二叉树","slug":"二叉树","count":1,"path":"api/tags/二叉树.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Shell脚本","uid":"4c7aeff5501d897794d9e23b1c1097ec","slug":"Linux/shell脚本","date":"2022-11-25T03:03:04.000Z","updated":"2022-12-02T07:43:54.386Z","comments":true,"path":"api/articles/Linux/shell脚本.json","cover":"/img/default_top_img.jpg","text":"Shell输入输出重定向 我们在后台挂在jar包时，常使用过一个命令：nohup java -jar xxx.jar &gt; java.log 2&gt;&amp;1 &amp; 这里就有几个知识点： 末尾的 &amp; 代表后台默认启动，页面关闭后，程序终止。 头部的 noh...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Linux","slug":"Linux","count":1,"path":"api/categories/Linux.json"}],"tags":[{"name":"Shell","slug":"Shell","count":1,"path":"api/tags/Shell.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"IO流","uid":"eab0435802cc6e95f43c834dccfaf907","slug":"Java/IO流","date":"2022-11-24T05:03:04.000Z","updated":"2022-12-02T07:43:54.349Z","comments":true,"path":"api/articles/Java/IO流.json","cover":"/img/default_top_img.jpg","text":"今天面试的时候问了一道IO流的题，鉴于之前在java基础篇的时候学过一遍，后再无使用和复习，就再跟着韩顺平老师的课件复习一遍。 IO流IO流是什么？当我们使用程序读取或修改本地文件时， 文件是以流的形式加载在内存中的。 InputStream:输入流，从数据源加载至内存。 Out...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"IO流","slug":"IO流","count":1,"path":"api/tags/IO流.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Java基础","uid":"3316961ecf1671c6065b043220187c47","slug":"Java/Java基础","date":"2022-11-23T05:03:04.000Z","updated":"2022-12-02T07:43:54.382Z","comments":true,"path":"api/articles/Java/Java基础.json","cover":"/img/default_top_img.jpg","text":"ListArrayList 如何将ArrayList变成同步操作？ Collections.synchronizedList(arrayList); Collections.synchronizedList是一个包装类，会将arrayList的一些操作进行加锁，这里我们注意：读写...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"集合","slug":"集合","count":1,"path":"api/tags/集合.json"},{"name":"锁","slug":"锁","count":1,"path":"api/tags/锁.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}