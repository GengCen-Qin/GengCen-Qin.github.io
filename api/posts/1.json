{"total":23,"pageSize":13,"pageCount":2,"data":[{"title":"反射复习","uid":"c18aa1916b90b67de06b43b022141dcc","slug":"Java/反射复习","date":"2022-12-03T02:57:12.000Z","updated":"2022-12-03T08:18:29.572Z","comments":true,"path":"api/articles/Java/反射复习.json","cover":"/img/default_top_img.jpg","text":"反射复习能干嘛​ 当我们创建一个对象时，需要事先在源码中进行编写，例如：new Object(),但如果未来发生变化，我就不得不在源码中进行修改，这也违反了开闭原则，我们能不能仅修改配置文件就可以调整系统中需要创建的类。比如说我在配置文件写: 12classPathName=or...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"从 JDBC 到 ORM（例：Mybatis）的演化过程","uid":"bf110c25b189686e7bf0f2a9ddd106cd","slug":"数据库/从 JDBC 到 ORM（例：Mybatis）的演化过程","date":"2022-11-29T11:03:04.000Z","updated":"2022-11-29T11:45:34.570Z","comments":true,"path":"api/articles/数据库/从 JDBC 到 ORM（例：Mybatis）的演化过程.json","cover":"/img/default_top_img.jpg","text":"从 JDBC 到 ORM（例：Mybatis）的演化过程​ 下面我将介绍Java操作Mysql数据的方式的演化过程，从最基本的JDBC到ORM框架的实现，每一次演化都是为了解决现有存在的问题。 JDBC这里需要加入Mysql驱动包或者依赖. 12345&lt;dependency...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"jdbc","slug":"jdbc","count":1,"path":"api/tags/jdbc.json"},{"name":"orm","slug":"orm","count":1,"path":"api/tags/orm.json"},{"name":"mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"第二章：链表问题","uid":"d03f3e28d8ef9c66091c681cce2f6e52","slug":"数据结构/第二章：链表问题","date":"2022-11-28T05:03:04.000Z","updated":"2022-12-01T02:10:52.726Z","comments":true,"path":"api/articles/数据结构/第二章：链表问题.json","cover":"/img/default_top_img.jpg","text":"第二章：链表问题打印两个有序链表的公共部分1234567891011121314151617181920/** * 给定两个有序链表的头指针head1和head2,打印两个链表的公共部分 * @param head1 * @param head2 */public static ...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":3,"path":"api/categories/数据结构.json"}],"tags":[{"name":"链表","slug":"链表","count":1,"path":"api/tags/链表.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Hexo d 推送至服务器","uid":"1b45a8bf657516596200d2bea123bb7b","slug":"Hexo同步服务器","date":"2022-11-28T02:57:12.000Z","updated":"2022-11-28T03:45:59.894Z","comments":true,"path":"api/articles/Hexo同步服务器.json","cover":"/img/default_top_img.jpg","text":"Hexo d 推送至服务器​ 前段时间利用Hexo搭建博客，并配合GitHub page进行页面显示，一切都很美妙，但有一个问题就是访问速度太慢，后面我希望将博客迁移到腾讯云中，之后就从服务器访问了。现在关于Hexo搭建基本博客的帖子已经很详细了，所以我会放一些我参考的链接，主要...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","count":1,"path":"api/tags/博客搭建.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"第一章：栈与队列","uid":"7bfcb6263ec210a85c00c06eddb51ce5","slug":"数据结构/第一章：栈与队列","date":"2022-11-27T05:03:04.000Z","updated":"2022-11-27T10:24:19.773Z","comments":true,"path":"api/articles/数据结构/第一章：栈与队列.json","cover":"/img/default_top_img.jpg","text":"第一章：栈与队列设计一个有getMin功能的栈 要求：pop，push，getMin的时间复杂度为：O(1) 123456789101112131415161718192021222324252627282930313233public class stackTemplate &...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":3,"path":"api/categories/数据结构.json"}],"tags":[{"name":"栈","slug":"栈","count":1,"path":"api/tags/栈.json"},{"name":"队列","slug":"队列","count":1,"path":"api/tags/队列.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Redis 底层结构","uid":"cdfc791f29b6a36876f87df237d095a0","slug":"Redis/Redis-底层结构","date":"2022-11-26T01:27:45.000Z","updated":"2022-11-26T04:48:22.090Z","comments":true,"path":"api/articles/Redis/Redis-底层结构.json","cover":"/img/default_top_img.jpg","text":"BigKey是什么 ？BigKey通常以Key的大小和Key中成员的数量来综合判定，例如： Key本身的数据量过大：一个String类型的Key，它的值为5 MB。 Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。 Key中成员的数据量过大：一个Ha...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Redis","slug":"Redis","count":2,"path":"api/categories/Redis.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"垃圾回收与内存分配","uid":"4d85e3fb54b920a7053434d8fa115e61","slug":"JVM/3_垃圾收集器与内存分配策略","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.396Z","comments":true,"path":"api/articles/JVM/3_垃圾收集器与内存分配策略.json","cover":"/img/default_top_img.jpg","text":"垃圾收集器与内存分配策略概述我们先提出三个问题： 哪部分内存需要回收? 什么时候进行回收？ 如何进行回收？ 生存还是死亡？where​ 我们都知道在Java中，栈，本地方法区，程序计数器都是线程私有的，随着线程的创建和结束，内存也会自动的分配和销毁，执行的方法也随着栈帧的插入和弹...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"垃圾回收","slug":"垃圾回收","count":1,"path":"api/tags/垃圾回收.json"},{"name":"内存分配","slug":"内存分配","count":1,"path":"api/tags/内存分配.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"内存划分与溢出","uid":"0e623c6a0a57ea6ab7fc40153f1c0960","slug":"JVM/2_Java内存区域与内存溢出异常","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.375Z","comments":true,"path":"api/articles/JVM/2_Java内存区域与内存溢出异常.json","cover":"/img/default_top_img.jpg","text":"概述​ 对于java与C&amp;C++开发的一大区别就在内存管理方面。Java是通过虚拟机管理内存，但如果不熟悉虚拟机怎么使用管理内存，出现内存泄露和内存溢出问题，修正就会很艰难。 运行时数据区域​ Java虚拟机在执行Java程序的过程中会把所管理的内存划分为一个个小部分，有...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"内存溢出","slug":"内存溢出","count":1,"path":"api/tags/内存溢出.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"后端编译与优化","uid":"b541249aeac135d3361cb459457b0ae9","slug":"JVM/后端编译与优化","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.368Z","comments":true,"path":"api/articles/JVM/后端编译与优化.json","cover":"/img/default_top_img.jpg","text":"后端编译与优化编译器优化技术逃逸分析 逃逸分析本身不是直接进行优化的方法，而是一种为优化提供帮助的分析算法 逃逸分析的原理： ​ 我们分析对象的动态作用域，如果对象创建在方法中，可能被外部方法所引用到，例如作为参数被外部方法进行调用，这叫做方法逃逸， ​ 被外部线程所访问到，例如...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"逃逸分析","slug":"逃逸分析","count":1,"path":"api/tags/逃逸分析.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"类加载机制","uid":"7749a2b5879f92c33b3cacbb2a610b9b","slug":"JVM/7_类加载机制","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.390Z","comments":true,"path":"api/articles/JVM/7_类加载机制.json","cover":"/img/default_top_img.jpg","text":"概述 虚拟机是如何加载Class文件的？ Class文件进入虚拟机后会有什么变化？ ​ 在Java中我们知道有编译期和运行期，其中编译期为我们写的java代码通过javac编译成一个一个的class文件，而运行期则为将class文件通过jvm加载到内存中，通过一些列操作变成可以j...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"类加载","slug":"类加载","count":1,"path":"api/tags/类加载.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Redis挖矿分析","uid":"ac22266bae0c79a0958a1796275c31c3","slug":"Redis/为什么当你学习Redis，发现自己的服务器在挖矿了","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:47:42.938Z","comments":true,"path":"api/articles/Redis/为什么当你学习Redis，发现自己的服务器在挖矿了.json","cover":"/img/default_top_img.jpg","text":"为什么当你学习Redis，发现自己的服务器在挖矿了​ 在我学习Redis时，因为嫌麻烦就没有设置密码，结果导致一段时间后系统提醒我，我的服务器上有挖矿行为，如果不清理就停止运行，我一脸懵逼，并不断上网查找哪里出现问题了，但最终还是没有解决，无奈下我初始化了服务器。希望本篇文章能对...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"Redis","slug":"Redis","count":2,"path":"api/categories/Redis.json"}],"tags":[{"name":"网络攻击","slug":"网络攻击","count":1,"path":"api/tags/网络攻击.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"封装自己的SDK","uid":"fad787980031e756d8eadb6688777ddf","slug":"Spring/封装自己的SDK","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:48:35.827Z","comments":true,"path":"api/articles/Spring/封装自己的SDK.json","cover":"/img/default_top_img.jpg","text":"封装自己的SDK​ 我们在开发Spring项目时常常会引入各种xxx-spring-boot-starter的依赖包，然后在配置文件中填入必要的信息，就可以使用依赖提供好的容器。这里是在鱼皮新项目直播中学习到的，特此记录一下。可在未来封装自己的SDK进行封装与装逼。 SDK项目下...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"Spring","slug":"Spring","count":2,"path":"api/categories/Spring.json"}],"tags":[{"name":"SDK","slug":"SDK","count":1,"path":"api/tags/SDK.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Spring如何解决循环依赖","uid":"2846594611fd32071ec8e1a72cd8f17d","slug":"Spring/Spring如何解决循环依赖","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T07:24:28.522Z","comments":true,"path":"api/articles/Spring/Spring如何解决循环依赖.json","cover":"/img/default_top_img.jpg","text":"Spring循环依如何解决？ 循环依赖是什么？ 1234567class A&#123; B b;&#125;class B&#123; A a;&#125;//简单来说就是A的创建依赖于B，B的创建依赖于A。 在一般场景下，如何解决循环依赖的问题？ 我们知道对象的创建一般有： ...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"Spring","slug":"Spring","count":2,"path":"api/categories/Spring.json"}],"tags":[{"name":"循环依赖","slug":"循环依赖","count":1,"path":"api/tags/循环依赖.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}