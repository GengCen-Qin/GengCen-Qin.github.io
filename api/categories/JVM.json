{"name":"JVM","slug":"JVM","count":4,"postlist":[{"title":"垃圾回收与内存分配","uid":"4d85e3fb54b920a7053434d8fa115e61","slug":"JVM/3_垃圾收集器与内存分配策略","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.396Z","comments":true,"path":"api/articles/JVM/3_垃圾收集器与内存分配策略.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"垃圾收集器与内存分配策略概述我们先提出三个问题： 哪部分内存需要回收? 什么时候进行回收？ 如何进行回收？ 生存还是死亡？where​ 我们都知道在Java中，栈，本地方法区，程序计数器都是线程私有的，随着线程的创建和结束，内存也会自动的分配和销毁，执行的方法也随着栈帧的插入和弹...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"垃圾回收","slug":"垃圾回收","count":1,"path":"api/tags/垃圾回收.json"},{"name":"内存分配","slug":"内存分配","count":1,"path":"api/tags/内存分配.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"内存划分与溢出","uid":"0e623c6a0a57ea6ab7fc40153f1c0960","slug":"JVM/2_Java内存区域与内存溢出异常","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.375Z","comments":true,"path":"api/articles/JVM/2_Java内存区域与内存溢出异常.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"概述​ 对于java与C&amp;C++开发的一大区别就在内存管理方面。Java是通过虚拟机管理内存，但如果不熟悉虚拟机怎么使用管理内存，出现内存泄露和内存溢出问题，修正就会很艰难。 运行时数据区域​ Java虚拟机在执行Java程序的过程中会把所管理的内存划分为一个个小部分，有...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"内存溢出","slug":"内存溢出","count":1,"path":"api/tags/内存溢出.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"后端编译与优化","uid":"b541249aeac135d3361cb459457b0ae9","slug":"JVM/后端编译与优化","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.368Z","comments":true,"path":"api/articles/JVM/后端编译与优化.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"后端编译与优化编译器优化技术逃逸分析 逃逸分析本身不是直接进行优化的方法，而是一种为优化提供帮助的分析算法 逃逸分析的原理： ​ 我们分析对象的动态作用域，如果对象创建在方法中，可能被外部方法所引用到，例如作为参数被外部方法进行调用，这叫做方法逃逸， ​ 被外部线程所访问到，例如...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"逃逸分析","slug":"逃逸分析","count":1,"path":"api/tags/逃逸分析.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"类加载机制","uid":"7749a2b5879f92c33b3cacbb2a610b9b","slug":"JVM/7_类加载机制","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.390Z","comments":true,"path":"api/articles/JVM/7_类加载机制.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"概述 虚拟机是如何加载Class文件的？ Class文件进入虚拟机后会有什么变化？ ​ 在Java中我们知道有编译期和运行期，其中编译期为我们写的java代码通过javac编译成一个一个的class文件，而运行期则为将class文件通过jvm加载到内存中，通过一些列操作变成可以j...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"类加载","slug":"类加载","count":1,"path":"api/tags/类加载.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}