{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}},"post_list":[{"title":"反射复习","uid":"c18aa1916b90b67de06b43b022141dcc","slug":"Java/反射复习","date":"2022-12-03T02:57:12.000Z","updated":"2022-12-03T08:18:29.572Z","comments":true,"path":"api/articles/Java/反射复习.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"反射复习能干嘛​ 当我们创建一个对象时，需要事先在源码中进行编写，例如：new Object(),但如果未来发生变化，我就不得不在源码中进行修改，这也违反了开闭原则，我们能不能仅修改配置文件就可以调整系统中需要创建的类。比如说我在配置文件写: 12classPathName=or...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"从 JDBC 到 ORM（例：Mybatis）的演化过程","uid":"bf110c25b189686e7bf0f2a9ddd106cd","slug":"数据库/从 JDBC 到 ORM（例：Mybatis）的演化过程","date":"2022-11-29T11:03:04.000Z","updated":"2022-11-29T11:45:34.570Z","comments":true,"path":"api/articles/数据库/从 JDBC 到 ORM（例：Mybatis）的演化过程.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"从 JDBC 到 ORM（例：Mybatis）的演化过程​ 下面我将介绍Java操作Mysql数据的方式的演化过程，从最基本的JDBC到ORM框架的实现，每一次演化都是为了解决现有存在的问题。 JDBC这里需要加入Mysql驱动包或者依赖. 12345&lt;dependency...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"jdbc","slug":"jdbc","count":1,"path":"api/tags/jdbc.json"},{"name":"orm","slug":"orm","count":1,"path":"api/tags/orm.json"},{"name":"mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"第二章：链表问题","uid":"d03f3e28d8ef9c66091c681cce2f6e52","slug":"数据结构/第二章：链表问题","date":"2022-11-28T05:03:04.000Z","updated":"2022-12-01T02:10:52.726Z","comments":true,"path":"api/articles/数据结构/第二章：链表问题.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"第二章：链表问题打印两个有序链表的公共部分1234567891011121314151617181920/** * 给定两个有序链表的头指针head1和head2,打印两个链表的公共部分 * @param head1 * @param head2 */public static ...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":3,"path":"api/categories/数据结构.json"}],"tags":[{"name":"链表","slug":"链表","count":1,"path":"api/tags/链表.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Hexo d 推送至服务器","uid":"1b45a8bf657516596200d2bea123bb7b","slug":"Hexo同步服务器","date":"2022-11-28T02:57:12.000Z","updated":"2022-11-28T03:45:59.894Z","comments":true,"path":"api/articles/Hexo同步服务器.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"Hexo d 推送至服务器​ 前段时间利用Hexo搭建博客，并配合GitHub page进行页面显示，一切都很美妙，但有一个问题就是访问速度太慢，后面我希望将博客迁移到腾讯云中，之后就从服务器访问了。现在关于Hexo搭建基本博客的帖子已经很详细了，所以我会放一些我参考的链接，主要...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","count":1,"path":"api/tags/博客搭建.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"第一章：栈与队列","uid":"7bfcb6263ec210a85c00c06eddb51ce5","slug":"数据结构/第一章：栈与队列","date":"2022-11-27T05:03:04.000Z","updated":"2022-11-27T10:24:19.773Z","comments":true,"path":"api/articles/数据结构/第一章：栈与队列.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"第一章：栈与队列设计一个有getMin功能的栈 要求：pop，push，getMin的时间复杂度为：O(1) 123456789101112131415161718192021222324252627282930313233public class stackTemplate &...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":3,"path":"api/categories/数据结构.json"}],"tags":[{"name":"栈","slug":"栈","count":1,"path":"api/tags/栈.json"},{"name":"队列","slug":"队列","count":1,"path":"api/tags/队列.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Redis 底层结构","uid":"cdfc791f29b6a36876f87df237d095a0","slug":"Redis/Redis-底层结构","date":"2022-11-26T01:27:45.000Z","updated":"2022-11-26T04:48:22.090Z","comments":true,"path":"api/articles/Redis/Redis-底层结构.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"BigKey是什么 ？BigKey通常以Key的大小和Key中成员的数量来综合判定，例如： Key本身的数据量过大：一个String类型的Key，它的值为5 MB。 Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。 Key中成员的数据量过大：一个Ha...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Redis","slug":"Redis","count":2,"path":"api/categories/Redis.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"垃圾回收与内存分配","uid":"4d85e3fb54b920a7053434d8fa115e61","slug":"JVM/3_垃圾收集器与内存分配策略","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.396Z","comments":true,"path":"api/articles/JVM/3_垃圾收集器与内存分配策略.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"垃圾收集器与内存分配策略概述我们先提出三个问题： 哪部分内存需要回收? 什么时候进行回收？ 如何进行回收？ 生存还是死亡？where​ 我们都知道在Java中，栈，本地方法区，程序计数器都是线程私有的，随着线程的创建和结束，内存也会自动的分配和销毁，执行的方法也随着栈帧的插入和弹...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"垃圾回收","slug":"垃圾回收","count":1,"path":"api/tags/垃圾回收.json"},{"name":"内存分配","slug":"内存分配","count":1,"path":"api/tags/内存分配.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"内存划分与溢出","uid":"0e623c6a0a57ea6ab7fc40153f1c0960","slug":"JVM/2_Java内存区域与内存溢出异常","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.375Z","comments":true,"path":"api/articles/JVM/2_Java内存区域与内存溢出异常.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"概述​ 对于java与C&amp;C++开发的一大区别就在内存管理方面。Java是通过虚拟机管理内存，但如果不熟悉虚拟机怎么使用管理内存，出现内存泄露和内存溢出问题，修正就会很艰难。 运行时数据区域​ Java虚拟机在执行Java程序的过程中会把所管理的内存划分为一个个小部分，有...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"内存溢出","slug":"内存溢出","count":1,"path":"api/tags/内存溢出.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"后端编译与优化","uid":"b541249aeac135d3361cb459457b0ae9","slug":"JVM/后端编译与优化","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.368Z","comments":true,"path":"api/articles/JVM/后端编译与优化.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"后端编译与优化编译器优化技术逃逸分析 逃逸分析本身不是直接进行优化的方法，而是一种为优化提供帮助的分析算法 逃逸分析的原理： ​ 我们分析对象的动态作用域，如果对象创建在方法中，可能被外部方法所引用到，例如作为参数被外部方法进行调用，这叫做方法逃逸， ​ 被外部线程所访问到，例如...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"逃逸分析","slug":"逃逸分析","count":1,"path":"api/tags/逃逸分析.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"类加载机制","uid":"7749a2b5879f92c33b3cacbb2a610b9b","slug":"JVM/7_类加载机制","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.390Z","comments":true,"path":"api/articles/JVM/7_类加载机制.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"概述 虚拟机是如何加载Class文件的？ Class文件进入虚拟机后会有什么变化？ ​ 在Java中我们知道有编译期和运行期，其中编译期为我们写的java代码通过javac编译成一个一个的class文件，而运行期则为将class文件通过jvm加载到内存中，通过一些列操作变成可以j...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"类加载","slug":"类加载","count":1,"path":"api/tags/类加载.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Redis挖矿分析","uid":"ac22266bae0c79a0958a1796275c31c3","slug":"Redis/为什么当你学习Redis，发现自己的服务器在挖矿了","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:47:42.938Z","comments":true,"path":"api/articles/Redis/为什么当你学习Redis，发现自己的服务器在挖矿了.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"为什么当你学习Redis，发现自己的服务器在挖矿了​ 在我学习Redis时，因为嫌麻烦就没有设置密码，结果导致一段时间后系统提醒我，我的服务器上有挖矿行为，如果不清理就停止运行，我一脸懵逼，并不断上网查找哪里出现问题了，但最终还是没有解决，无奈下我初始化了服务器。希望本篇文章能对...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"Redis","slug":"Redis","count":2,"path":"api/categories/Redis.json"}],"tags":[{"name":"网络攻击","slug":"网络攻击","count":1,"path":"api/tags/网络攻击.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"封装自己的SDK","uid":"fad787980031e756d8eadb6688777ddf","slug":"Spring/封装自己的SDK","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:48:35.827Z","comments":true,"path":"api/articles/Spring/封装自己的SDK.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"封装自己的SDK​ 我们在开发Spring项目时常常会引入各种xxx-spring-boot-starter的依赖包，然后在配置文件中填入必要的信息，就可以使用依赖提供好的容器。这里是在鱼皮新项目直播中学习到的，特此记录一下。可在未来封装自己的SDK进行封装与装逼。 SDK项目下...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"Spring","slug":"Spring","count":2,"path":"api/categories/Spring.json"}],"tags":[{"name":"SDK","slug":"SDK","count":1,"path":"api/tags/SDK.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Spring如何解决循环依赖","uid":"2846594611fd32071ec8e1a72cd8f17d","slug":"Spring/Spring如何解决循环依赖","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T07:24:28.522Z","comments":true,"path":"api/articles/Spring/Spring如何解决循环依赖.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"Spring循环依如何解决？ 循环依赖是什么？ 1234567class A&#123; B b;&#125;class B&#123; A a;&#125;//简单来说就是A的创建依赖于B，B的创建依赖于A。 在一般场景下，如何解决循环依赖的问题？ 我们知道对象的创建一般有： ...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"Spring","slug":"Spring","count":2,"path":"api/categories/Spring.json"}],"tags":[{"name":"循环依赖","slug":"循环依赖","count":1,"path":"api/tags/循环依赖.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"拦截器与过滤器的区别","uid":"2b2e8451f755e036c0af04fba68240df","slug":"Web/拦截器与过滤器的区别","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:02:50.203Z","comments":true,"path":"api/articles/Web/拦截器与过滤器的区别.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"拦截器与过滤器的区别 底层思想是什么？ 拦截器与过滤器都是基于AOP面向切面编程的思想来实现的。 两者有什么相同，有什么不同？ 相同点：都可以对请求做出统一的处理，例如在方法调用前进行一些操作，在方法调后后处理一些操作 不同点： 拦截器是Spring提供的（org.springf...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"Web","slug":"Web","count":1,"path":"api/categories/Web.json"}],"tags":[{"name":"Filter","slug":"Filter","count":1,"path":"api/tags/Filter.json"},{"name":"Interceptor","slug":"Interceptor","count":1,"path":"api/tags/Interceptor.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"后端风云","uid":"1b78b57250af97fad0b302e86d2e91a2","slug":"分布式/后端风云","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T07:25:41.787Z","comments":true,"path":"api/articles/分布式/后端风云.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"后端风云​ 本文简单概况了一下刘欣老师的《码农翻身》的后端风云章，这本书强烈推荐给大家，每看一遍都有不同的感觉，通俗易懂且知识面大而全。居家旅行，必备良药！！！ 早期初级阶段： ​ 在我们早期学习 javaWeb阶段，将订单模块儿，购物车模块儿，支付模块儿都写在了一个项目中，并访...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"分布式","slug":"分布式","count":2,"path":"api/categories/分布式.json"}],"tags":[],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"分布式事务","uid":"c064617a2958c28ea23700a4261c6075","slug":"分布式/分布式事务","date":"2022-11-25T05:03:04.000Z","updated":"2022-12-03T09:27:00.033Z","comments":true,"path":"api/articles/分布式/分布式事务.json","keywords":null,"cover":[],"text":"简介​ 我们在过去总是使用本地事务，也就是数据库提供的事务操作，其中具有ACID的特性，但在如今我们的各个模块儿被拆分，服务与服务间相互调用，简单来说就是需要跨进程的事务，我们来想一下现有的本地事务是否能解决分布式事务。情况1：跨JVM，跨数据库产生分布式事务 graph TD;...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"分布式","slug":"分布式","count":2,"path":"api/categories/分布式.json"}],"tags":[{"name":"事务","slug":"事务","count":1,"path":"api/tags/事务.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"手写线程池","uid":"df1cff2ea6b0a8229883d729950dd5e6","slug":"并发/手写线程池","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:50:12.412Z","comments":true,"path":"api/articles/并发/手写线程池.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"手写线程池 ​ 我们从初级阶段自己创建线程去异步执行任务，到后期使用线程池不断执行任务，原理书上都有，但都是字面意思，无法深入理解，所以打算自己进行实现。 阶段一： 123456new Thread(new Runnable() &#123; @Override public v...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"并发","slug":"并发","count":2,"path":"api/categories/并发.json"}],"tags":[{"name":"线程池","slug":"线程池","count":1,"path":"api/tags/线程池.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"并发编程","uid":"be447ed25be14672c8ade5d39be9da07","slug":"并发/并发编程","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:49:54.174Z","comments":true,"path":"api/articles/并发/并发编程.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"基础的概念什么是并发操作？利用多核CPU去完成任务，类似于使用影分身去完成不同的作业，这肯定比我一个人一个个写要快的多 什么时候可以使用并发？当有多核CPU时。如果只有一个CPU，那并发实际上只是线程的不断切换，好比我在数学作业上先写点儿，再到语文上再写点儿，因为处理的很快，给人...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"并发","slug":"并发","count":2,"path":"api/categories/并发.json"}],"tags":[{"name":"并发","slug":"并发","count":1,"path":"api/tags/并发.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Mysql的事务与索引","uid":"99be73816d71c90e1cc1cbf82e76416f","slug":"数据库/Mysql的事务与索引","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T07:26:26.008Z","comments":true,"path":"api/articles/数据库/Mysql的事务与索引.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"Mysql事务与索引 ​ 需求：先从数据库中读取摸一个字段的值，然后在该字段上的基础上进行修改，由于操作不是原子性，无法保证线程安全，也就是当A线程读取到1时，想+1，赋值为2。而B线程已经将数据修改为2了，那么A线程应该是在2的基础上+1，赋值为3。但实际中可能该值都到8了，A...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":1,"path":"api/tags/Mysql.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"第三章：二叉树问题","uid":"ef3a6aac56d074894be545c71d6959e7","slug":"数据结构/第三章：二叉树问题","date":"2022-11-25T05:03:04.000Z","updated":"2022-12-01T02:13:16.426Z","comments":true,"path":"api/articles/数据结构/第三章：二叉树问题.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"树形dp套路在做树结构的题目中，如果求解规则可以分为，以某个节点为子树，先向左要数据，再向右要数据，最后返回总数据，我们就可以使用该套路。 递归进行遍历 1234567891011public static void QTraverse2(Point tree) &#123; i...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":3,"path":"api/categories/数据结构.json"}],"tags":[{"name":"二叉树","slug":"二叉树","count":1,"path":"api/tags/二叉树.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Shell脚本","uid":"4c7aeff5501d897794d9e23b1c1097ec","slug":"Linux/shell脚本","date":"2022-11-25T03:03:04.000Z","updated":"2022-12-02T07:43:54.386Z","comments":true,"path":"api/articles/Linux/shell脚本.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"Shell输入输出重定向 我们在后台挂在jar包时，常使用过一个命令：nohup java -jar xxx.jar &gt; java.log 2&gt;&amp;1 &amp; 这里就有几个知识点： 末尾的 &amp; 代表后台默认启动，页面关闭后，程序终止。 头部的 noh...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Linux","slug":"Linux","count":1,"path":"api/categories/Linux.json"}],"tags":[{"name":"Shell","slug":"Shell","count":1,"path":"api/tags/Shell.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"IO流","uid":"eab0435802cc6e95f43c834dccfaf907","slug":"Java/IO流","date":"2022-11-24T05:03:04.000Z","updated":"2022-12-02T07:43:54.349Z","comments":true,"path":"api/articles/Java/IO流.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"今天面试的时候问了一道IO流的题，鉴于之前在java基础篇的时候学过一遍，后再无使用和复习，就再跟着韩顺平老师的课件复习一遍。 IO流IO流是什么？当我们使用程序读取或修改本地文件时， 文件是以流的形式加载在内存中的。 InputStream:输入流，从数据源加载至内存。 Out...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"IO流","slug":"IO流","count":1,"path":"api/tags/IO流.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Java基础","uid":"3316961ecf1671c6065b043220187c47","slug":"Java/Java基础","date":"2022-11-23T05:03:04.000Z","updated":"2022-12-02T07:43:54.382Z","comments":true,"path":"api/articles/Java/Java基础.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"ListArrayList 如何将ArrayList变成同步操作？ Collections.synchronizedList(arrayList); Collections.synchronizedList是一个包装类，会将arrayList的一些操作进行加锁，这里我们注意：读写...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"集合","slug":"集合","count":1,"path":"api/tags/集合.json"},{"name":"锁","slug":"锁","count":1,"path":"api/tags/锁.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}],"categories":10,"tags":26,"word_count":"199k","post_count":23}