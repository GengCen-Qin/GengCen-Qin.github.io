{"title":"后端编译与优化","uid":"b541249aeac135d3361cb459457b0ae9","slug":"JVM/后端编译与优化","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.368Z","comments":true,"path":"api/articles/JVM/后端编译与优化.json","keywords":null,"cover":"/img/default_top_img.jpg","content":"<h1 id=\"后端编译与优化\"><a href=\"#后端编译与优化\" class=\"headerlink\" title=\"后端编译与优化\"></a>后端编译与优化</h1><h2 id=\"编译器优化技术\"><a href=\"#编译器优化技术\" class=\"headerlink\" title=\"编译器优化技术\"></a>编译器优化技术</h2><h3 id=\"逃逸分析\"><a href=\"#逃逸分析\" class=\"headerlink\" title=\"逃逸分析\"></a>逃逸分析</h3><blockquote>\n<p>逃逸分析本身不是直接进行优化的方法，而是一种为优化提供帮助的分析算法</p>\n<p>逃逸分析的原理：</p>\n<p>​        我们分析对象的动态作用域，如果对象创建在方法中，可能被外部方法所引用到，例如作为参数被外部方法进行调用，这叫做<code>方法逃逸</code>，</p>\n<p>​        被外部线程所访问到，例如赋值给外部线程使用的变量中。称为<code>线程逃逸</code></p>\n</blockquote>\n<p>​        从不逃逸，方法逃逸，线程逃逸。称为对象从小到大的逃逸程度，我们因此也可以做不同的优化策略、</p>\n<h4 id=\"栈上分配\"><a href=\"#栈上分配\" class=\"headerlink\" title=\"栈上分配\"></a>栈上分配</h4><p>​        大家都知道在java中，所有的对象都存储在堆空间中，随着存放 的对象越来越多，也就需要垃圾回收器来进行工作，而这一步也是非常消耗性能的，那这里就引出一个概念<code>栈上分配</code>，也就是当我们进行逃逸分析后，发现对象不存在<code>线程逃逸</code>，我们将对象存储在栈上，随着栈帧的插入与弹出，对象本身也跟着创建和销毁。</p>\n<blockquote>\n<p> 这里我们需要提醒两点：</p>\n<ol>\n<li><p>之前放在堆中，堆中对象是被各个线程共享的，只要有指针指向该对象的地址，就可以进行使用。但栈是线程独有的。所以栈上分配的第一点：<code>对象不会被线程共享，也叫做线程逃逸</code>。</p>\n</li>\n<li><p>如果对象被分配到栈上了，随着栈帧插入与弹出（也就是方法的调用与结束），变量会跟着创建和删除，那如果该变量被方法外所引用，比如被当做方法参数被其他方法进行调用。这也称为<code>方法逃逸</code></p>\n</li>\n</ol>\n</blockquote>\n<p>​        栈上分配支持：<code>方法逃逸</code>，不支持：<code>线程逃逸</code></p>\n<h4 id=\"标量替换\"><a href=\"#标量替换\" class=\"headerlink\" title=\"标量替换\"></a>标量替换</h4><blockquote>\n<p>这里的标量是指Java中基础变量，例如：<code>int,char,boolen,short,Refference</code>等，也就是变量不能再拆分为更小的元素，这就叫<code>标量</code>。</p>\n<p>而当我们创建对象后，对象可以再被细分为各种标量的组合，该对象也叫做<code>聚合量</code></p>\n</blockquote>\n<p>​        面向过程编程的一个好处就是不用封装对象，效率更高，所以通过这一点，如果我们能分析出该对象只有一部分会被使用，且对象不会逃逸到方法体外，则我们不创建该对象，而是直接创建对象的标量，进行使用。下面我们来代码解释一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> x;</span><br><span class=\"line\">  <span class=\"type\">int</span> y;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getX</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//没有优化前</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getValue</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">XX</span> <span class=\"operator\">=</span> x+<span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(XX,<span class=\"number\">42</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> person.getX();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第一步：构造函数内联后的样子</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getValue</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">XX</span> <span class=\"operator\">=</span> x+<span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"type\">Person</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> point_memory_alloc();  <span class=\"comment\">//堆中分配P对象</span></span><br><span class=\"line\">  p.x==XX;\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//Person构造函数内联后</span></span><br><span class=\"line\">  p.y==<span class=\"number\">42</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> p.x;\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//Person::getX()被内联后</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二步：进行标量替换优化</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getValue</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">XX</span> <span class=\"operator\">=</span> x+<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//相当于我不创建一个完整对象了，我只创建几个标量来代替使用</span></span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">pX</span> <span class=\"operator\">=</span> XX;</span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"variable\">py</span> <span class=\"operator\">=</span> <span class=\"number\">42</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pX;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第三步：作无效代码消除后</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getValue</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x+<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​        标量替换会更加严格一些：不允许方法逃狱。</p>\n<h4 id=\"同步消除\"><a href=\"#同步消除\" class=\"headerlink\" title=\"同步消除\"></a>同步消除</h4><blockquote>\n<p>同步消除是指Java中的锁的优化，也就是当我们分析出一个同步的方法，实际中不会被其他线程所争抢，那么久没有必要上锁了，相当于你去公共厕所，怕别人进来，你上把锁。走了再开锁，那如果是在你家，只有你一个人时，就没必要再加个锁吧，再懒点儿你门都可以不要了。</p>\n</blockquote>\n<p>​        当经过逃逸分析后，我们发现方法不会被其他线程访问使用，也就是线程逃逸，我们就可以不对线程进行同步操作。</p>\n<h4 id=\"小总结\"><a href=\"#小总结\" class=\"headerlink\" title=\"小总结\"></a>小总结</h4><p>​        从测试中我们发现效果不错，但实际中可能分析后消耗了性能还发现能被优化的很少。所以在<code>JDK 6 Update 23</code>之前是禁止该优化的，之后才开始默认开启逃逸分析。</p>\n<ol>\n<li><code>-XX:+DoEscapeAnalysis</code>手动开启逃逸分析</li>\n<li><code>-XX:+PrintEscapeAnalysis</code>来查看开启后的分析结果</li>\n<li><code>-XX:+EliminateAllocations</code>开启标量替换</li>\n<li><code>-XX:+PrintEliminateAllocations</code>查看标量替换结果</li>\n<li><code>-XX:+EliminateLocks</code>开启同步消除</li>\n</ol>\n","text":"后端编译与优化编译器优化技术逃逸分析 逃逸分析本身不是直接进行优化的方法，而是一种为优化提供帮助的分析算法 逃逸分析的原理： ​ 我们分析对象的动态作用域，如果对象创建在方法中，可能被外部方法所引用到，例如作为参数被外部方法进行调用，这叫做方法逃逸， ​ 被外部线程所访问到，例如...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"逃逸分析","slug":"逃逸分析","count":1,"path":"api/tags/逃逸分析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">后端编译与优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">编译器优化技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90\"><span class=\"toc-text\">逃逸分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D\"><span class=\"toc-text\">栈上分配</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2\"><span class=\"toc-text\">标量替换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E6%B6%88%E9%99%A4\"><span class=\"toc-text\">同步消除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">小总结</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"内存划分与溢出","uid":"0e623c6a0a57ea6ab7fc40153f1c0960","slug":"JVM/2_Java内存区域与内存溢出异常","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.375Z","comments":true,"path":"api/articles/JVM/2_Java内存区域与内存溢出异常.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"概述​ 对于java与C&amp;C++开发的一大区别就在内存管理方面。Java是通过虚拟机管理内存，但如果不熟悉虚拟机怎么使用管理内存，出现内存泄露和内存溢出问题，修正就会很艰难。 运行时数据区域​ Java虚拟机在执行Java程序的过程中会把所管理的内存划分为一个个小部分，有...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"内存溢出","slug":"内存溢出","count":1,"path":"api/tags/内存溢出.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"类加载机制","uid":"7749a2b5879f92c33b3cacbb2a610b9b","slug":"JVM/7_类加载机制","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.390Z","comments":true,"path":"api/articles/JVM/7_类加载机制.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"概述 虚拟机是如何加载Class文件的？ Class文件进入虚拟机后会有什么变化？ ​ 在Java中我们知道有编译期和运行期，其中编译期为我们写的java代码通过javac编译成一个一个的class文件，而运行期则为将class文件通过jvm加载到内存中，通过一些列操作变成可以j...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"类加载","slug":"类加载","count":1,"path":"api/tags/类加载.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}