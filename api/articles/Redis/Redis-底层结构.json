{"title":"Redis 底层结构","uid":"cdfc791f29b6a36876f87df237d095a0","slug":"Redis/Redis-底层结构","date":"2022-11-26T01:27:45.000Z","updated":"2022-11-26T04:48:22.090Z","comments":true,"path":"api/articles/Redis/Redis-底层结构.json","keywords":null,"cover":"/img/default_top_img.jpg","content":"<h2 id=\"BigKey\"><a href=\"#BigKey\" class=\"headerlink\" title=\"BigKey\"></a>BigKey</h2><h3 id=\"是什么-？\"><a href=\"#是什么-？\" class=\"headerlink\" title=\"是什么 ？\"></a>是什么 ？</h3><p>BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：</p>\n<ol>\n<li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB。</li>\n<li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。</li>\n<li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB。</li>\n</ol>\n<p>推荐值：</p>\n<ol>\n<li>单个key的value小于10KB</li>\n<li>对于集合类型的key，建议元素数量小于1000</li>\n</ol>\n<h3 id=\"有什么危害-？\"><a href=\"#有什么危害-？\" class=\"headerlink\" title=\"有什么危害 ？\"></a>有什么危害 ？</h3><ul>\n<li>网络阻塞</li>\n</ul>\n<p>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢 </p>\n<ul>\n<li>数据倾斜</li>\n</ul>\n<p>BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡 </p>\n<ul>\n<li>Redis阻塞</li>\n</ul>\n<p>对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞 </p>\n<ul>\n<li>CPU压力</li>\n</ul>\n<p>对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</p>\n<h3 id=\"怎么识别-？\"><a href=\"#怎么识别-？\" class=\"headerlink\" title=\"怎么识别 ？\"></a>怎么识别 ？</h3><ul>\n<li>redis-cli –bigkeys</li>\n</ul>\n<p>利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key </p>\n<ul>\n<li>scan扫描</li>\n</ul>\n<p>自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE） </p>\n<ul>\n<li>第三方工具</li>\n</ul>\n<p>利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况 </p>\n<ul>\n<li>网络监控</li>\n</ul>\n<p>自定义工具，监控进出Redis的网络数据，超出预警值时主动告警</p>\n<h3 id=\"如何删除-？\"><a href=\"#如何删除-？\" class=\"headerlink\" title=\"如何删除 ？\"></a>如何删除 ？</h3><p>BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。 </p>\n<ul>\n<li>redis 3.0 及以下版本</li>\n</ul>\n<p>如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKey </p>\n<ul>\n<li>Redis 4.0以后 </li>\n</ul>\n<p>Redis在4.0后提供了异步删除的命令：unlink</p>\n<h2 id=\"底层数据结构\"><a href=\"#底层数据结构\" class=\"headerlink\" title=\"底层数据结构\"></a>底层数据结构</h2><h3 id=\"动态字符串SDS\"><a href=\"#动态字符串SDS\" class=\"headerlink\" title=\"动态字符串SDS\"></a>动态字符串SDS</h3><p>Redis并未使用C语言的字符串，因为存在一些问题：</p>\n<ol>\n<li>获取字符串长度需要运算</li>\n<li>非二进制安全</li>\n<li>不可修改</li>\n</ol>\n<p>因此Redis自己优化了字符串结构，为简单动态字符串（Simple Dynamic String），简称SDS。</p>\n<p>我们在最初学习Redis时，会操作：<code>set key value</code>, 底层实际上创建了两个SDS，一个包含 key，一个包含 value。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ib64ydeij30w00dtq5b.jpg\" alt=\"image-20221126101355075\"></p>\n<p>​    我们看到它提到了动态字符串，那相应应该有动态扩容的能力，假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p>\n<ul>\n<li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</li>\n<li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</li>\n</ul>\n<blockquote>\n<p>优点：</p>\n</blockquote>\n<ol>\n<li>获取字符串长度为 <code>O(1)</code></li>\n<li>支持动态扩容</li>\n<li>减少内存分配次数</li>\n<li>二进制安全</li>\n</ol>\n<h3 id=\"IntSet\"><a href=\"#IntSet\" class=\"headerlink\" title=\"IntSet\"></a>IntSet</h3><p>IntSet 是Redis的Set结构的一种实现方式，基于<strong>整数数组</strong>来实现，并且<strong>长度可变</strong>，<strong>有序</strong>。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ibaytj98j30qm0dfdia.jpg\" alt=\"image-20221126101835593\"></p>\n<p>为了方便查找，本身按照整数进行<strong>升序存储</strong>保存到content[]内</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ibeluzphj30vz0b5dgx.jpg\" alt=\"image-20221126102206179\"></p>\n<p>假设最初存储元素：<code>&#123;5,10,20&#125;</code>采用的编码是INTSET_ENC_INT16，则每个整数占2字节。</p>\n<p>我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。以当前案例来说流程如下：</p>\n<ol>\n<li><p>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数<strong>扩容数组</strong></p>\n</li>\n<li><p><strong>倒序</strong>依次将数组中的元素拷贝到扩容后的正确位置（倒序保证，之前节点不会被覆盖）</p>\n</li>\n</ol>\n<h4 id=\"新增流程\"><a href=\"#新增流程\" class=\"headerlink\" title=\"新增流程\"></a>新增流程</h4><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intset *intsetAdd(intset *<span class=\"keyword\">is</span>, int64_t <span class=\"keyword\">value</span>, uint8_t *success) &#123;</span><br><span class=\"line\">    uint8_t valenc = _intsetValueEncoding(<span class=\"keyword\">value</span>);<span class=\"comment\">// 获取当前值编码</span></span><br><span class=\"line\">    uint32_t pos; <span class=\"comment\">// 要插入的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) *success = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 判断编码是不是超过了当前intset的编码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (valenc &gt; intrev32ifbe(<span class=\"keyword\">is</span>-&gt;encoding)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 超出编码，需要升级</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> intsetUpgradeAndAdd(<span class=\"keyword\">is</span>,<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在当前intset中查找值与value一样的元素的角标pos</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intsetSearch(<span class=\"keyword\">is</span>,<span class=\"keyword\">value</span>,&amp;pos)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (success) *success = <span class=\"number\">0</span>; <span class=\"comment\">//如果找到了，则无需插入，直接结束并返回失败</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">is</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 数组扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">is</span> = intsetResize(<span class=\"keyword\">is</span>,intrev32ifbe(<span class=\"keyword\">is</span>-&gt;length)+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 移动数组中pos之后的元素到pos+1，给新元素腾出空间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos &lt; intrev32ifbe(<span class=\"keyword\">is</span>-&gt;length)) intsetMoveTail(<span class=\"keyword\">is</span>,pos,pos+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 插入新元素</span></span><br><span class=\"line\">    _intsetSet(<span class=\"keyword\">is</span>,pos,<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 重置元素长度</span></span><br><span class=\"line\">    <span class=\"keyword\">is</span>-&gt;length = intrev32ifbe(intrev32ifbe(<span class=\"keyword\">is</span>-&gt;length)+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">is</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"升级流程\"><a href=\"#升级流程\" class=\"headerlink\" title=\"升级流程\"></a>升级流程</h4><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> intset *intsetUpgradeAndAdd(intset *<span class=\"keyword\">is</span>, int64_t <span class=\"keyword\">value</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前intset编码</span></span><br><span class=\"line\">    uint8_t curenc = intrev32ifbe(<span class=\"keyword\">is</span>-&gt;encoding);</span><br><span class=\"line\">    <span class=\"comment\">// 获取新编码</span></span><br><span class=\"line\">    uint8_t newenc = _intsetValueEncoding(<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 获取元素个数</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> length = intrev32ifbe(<span class=\"keyword\">is</span>-&gt;length); </span><br><span class=\"line\">    <span class=\"comment\">// 判断新元素是大于0还是小于0 ，小于0插入队首、大于0插入队尾</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> prepend = <span class=\"keyword\">value</span> &lt; <span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 重置编码为新编码</span></span><br><span class=\"line\">    <span class=\"keyword\">is</span>-&gt;encoding = intrev32ifbe(newenc);</span><br><span class=\"line\">    <span class=\"comment\">// 重置数组大小</span></span><br><span class=\"line\">    <span class=\"keyword\">is</span> = intsetResize(<span class=\"keyword\">is</span>,intrev32ifbe(<span class=\"keyword\">is</span>-&gt;length)+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 倒序遍历，逐个搬运元素到新的位置，_intsetGetEncoded按照旧编码方式查找旧元素</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(length--) <span class=\"comment\">// _intsetSet按照新编码方式插入新元素</span></span><br><span class=\"line\">        _intsetSet(<span class=\"keyword\">is</span>,length+prepend,_intsetGetEncoded(<span class=\"keyword\">is</span>,length,curenc));</span><br><span class=\"line\">    <span class=\"comment\">/* 插入新元素，prepend决定是队首还是队尾*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prepend)</span><br><span class=\"line\">        _intsetSet(<span class=\"keyword\">is</span>,<span class=\"number\">0</span>,<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        _intsetSet(<span class=\"keyword\">is</span>,intrev32ifbe(<span class=\"keyword\">is</span>-&gt;length),<span class=\"keyword\">value</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 修改数组长度</span></span><br><span class=\"line\">    <span class=\"keyword\">is</span>-&gt;length = intrev32ifbe(intrev32ifbe(<span class=\"keyword\">is</span>-&gt;length)+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">is</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>总结：</p>\n</blockquote>\n<ol>\n<li>底层为<strong>整数数组</strong>，也就是一块儿完整的内存</li>\n<li>内部元素，<strong>唯一</strong>，<strong>有序</strong>。</li>\n<li>具备类型升级（<strong>倒序扩容</strong>）。</li>\n<li>底层采用二分查找。（因为有序）</li>\n</ol>\n<h3 id=\"Dict\"><a href=\"#Dict\" class=\"headerlink\" title=\"Dict\"></a>Dict</h3><p>​    我们知道Redis中是Key-Value结构，在Java中类似的也有Map结构，能够快速的进行增删改查，底层一定是有关系的映射。Redis正是基于Dict实现的。</p>\n<p>​    Dict有三个部分：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">dictht</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// entry数组</span></span><br><span class=\"line\">    <span class=\"comment\">// 数组中保存的是指向entry的指针</span></span><br><span class=\"line\">    dictEntry **table; </span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> size;     </span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小的掩码，总等于size - 1</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> sizemask;     </span><br><span class=\"line\">    <span class=\"comment\">// entry个数</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> used; </span><br><span class=\"line\">&#125; dictht;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">dictEntry</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> *key; <span class=\"comment\">// 键</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">void</span> *val;</span><br><span class=\"line\">        <span class=\"type\">uint64_t</span> u64;</span><br><span class=\"line\">        <span class=\"type\">int64_t</span> s64;</span><br><span class=\"line\">        <span class=\"type\">double</span> d;</span><br><span class=\"line\">    &#125; v; <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"comment\">// 下一个Entry的指针</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">dictEntry</span> *next; </span><br><span class=\"line\">&#125; dictEntry;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dict</span> &#123;</span></span><br><span class=\"line\">    dictType *type; <span class=\"comment\">// dict类型，内置不同的hash函数</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *privdata;     <span class=\"comment\">// 私有数据，在做特殊hash运算时用</span></span><br><span class=\"line\">    dictht ht[<span class=\"number\">2</span>]; <span class=\"comment\">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class=\"line\">    <span class=\"type\">long</span> rehashidx;   <span class=\"comment\">// rehash的进度，-1表示未进行</span></span><br><span class=\"line\">    <span class=\"type\">int16_t</span> pauserehash; <span class=\"comment\">// rehash是否暂停，1则暂停，0则继续</span></span><br><span class=\"line\">&#125; dict;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ibpu0dwbj30vb0b8ab5.jpg\" alt=\"image-20221126103253031\"></p>\n<p>​    我们可以看到Dict中有两个dictht，第一个负责存储值，第二个负责reHash。也就是当节点个数过多时，需要进行扩容，在Java的Map中，当数组中一个链表的长度大于8，就会进行数组扩容，否则查找遍历太慢。这里的原理是类似的。</p>\n<p>​    dictht内部是dictEntry数组，dictEntry含有指向下一个节点的指针。</p>\n<h4 id=\"Dict扩容\"><a href=\"#Dict扩容\" class=\"headerlink\" title=\"Dict扩容\"></a>Dict扩容</h4><p>​    这里还是有Java中Map举例，HashMap默认还有加载因子为0.75，也就是说不等我们把空间使用完，底层就会判断如果<code>当前节点数/容量数</code>大于0.75，会频繁导致Hash碰撞，并且链表长度太长，所以需要扩容。</p>\n<p>​    Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发哈希表扩容：</p>\n<ul>\n<li>哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；</li>\n<li>哈希表的 LoadFactor &gt; 5 ；</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> _dictExpandIfNeeded(dict *d)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果正在rehash，则返回ok</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">dictIsRehashing</span>(d)) <span class=\"keyword\">return</span> DICT_OK;\u000b    <span class=\"comment\">// 如果哈希表为空，则初始化哈希表为默认大小：4</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d-&gt;ht[<span class=\"number\">0</span>].size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">dictExpand</span>(d, DICT_HT_INITIAL_SIZE);</span><br><span class=\"line\">    <span class=\"comment\">// 当负载因子（used/size）达到1以上，并且当前没有进行bgrewrite等子进程操作</span></span><br><span class=\"line\">    <span class=\"comment\">// 或者负载因子超过5，则进行 dictExpand ，也就是扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d-&gt;ht[<span class=\"number\">0</span>].used &gt;= d-&gt;ht[<span class=\"number\">0</span>].size &amp;&amp;</span><br><span class=\"line\">        (dict_can_resize || d-&gt;ht[<span class=\"number\">0</span>].used/d-&gt;ht[<span class=\"number\">0</span>].size &gt; dict_force_resize_ratio)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 扩容大小为used + 1，底层会对扩容大小做判断，实际上找的是第一个大于等于 used+1 的 2^n</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dictExpand</span>(d, d-&gt;ht[<span class=\"number\">0</span>].used + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DICT_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dict收缩\"><a href=\"#Dict收缩\" class=\"headerlink\" title=\"Dict收缩\"></a>Dict收缩</h4><p>Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor &lt; 0.1 时，会做哈希表收缩：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// t_hash.c # hashTypeDeleted() </span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dictDelete((dict*)o-&gt;ptr, field) == C_OK) &#123;</span><br><span class=\"line\">    deleted = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 删除成功后，检查是否需要重置Dict大小，如果需要则调用dictResize重置\u000b    /* Always check if the dictionary needs a resize after a delete. */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (htNeedsResize(o-&gt;ptr)) dictResize(o-&gt;ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// server.c 文件</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">htNeedsResize</span><span class=\"params\">(dict *dict)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> size, used;</span><br><span class=\"line\">    <span class=\"comment\">// 哈希表大小</span></span><br><span class=\"line\">    size = dictSlots(dict);</span><br><span class=\"line\">    <span class=\"comment\">// entry数量</span></span><br><span class=\"line\">    used = dictSize(dict);</span><br><span class=\"line\">    <span class=\"comment\">// size &gt; 4（哈希表初识大小）并且 负载因子低于0.1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp; (used*<span class=\"number\">100</span>/size &lt; HASHTABLE_MIN_FILL));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">dictResize</span><span class=\"params\">(dict *d)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> minimal;</span><br><span class=\"line\">    <span class=\"comment\">// 如果正在做bgsave或bgrewriteof或rehash，则返回错误</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!dict_can_resize || dictIsRehashing(d)) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> DICT_ERR;</span><br><span class=\"line\">    <span class=\"comment\">// 获取used，也就是entry个数</span></span><br><span class=\"line\">    minimal = d-&gt;ht[<span class=\"number\">0</span>].used;</span><br><span class=\"line\">    <span class=\"comment\">// 如果used小于4，则重置为4</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class=\"line\">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class=\"line\">    <span class=\"comment\">// 重置大小为minimal，其实是第一个大于等于minimal的2^n</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> dictExpand(d, minimal);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Dict的ReHash\"><a href=\"#Dict的ReHash\" class=\"headerlink\" title=\"Dict的ReHash\"></a>Dict的ReHash</h4><p>​    不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p>\n<ol>\n<li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</li>\n</ol>\n<ul>\n<li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li>\n<li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li>\n</ul>\n<ol start=\"2\">\n<li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li>\n<li>设置dict.rehashidx = 0，标示开始rehash</li>\n<li>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</li>\n<li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li>\n</ol>\n<blockquote>\n<p>如果Key中的节点过多，那一次性进行Rehash就有可能导致主线程阻塞，怎么解决？</p>\n</blockquote>\n<p>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</p>\n<ol>\n<li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</li>\n</ol>\n<ul>\n<li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li>\n<li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li>\n</ul>\n<ol start=\"2\">\n<li>按照新的size申请内存空间，创建dictht，并赋值给dict.ht[1]</li>\n<li>设置dict.rehashidx = 0，标示开始rehash</li>\n<li><strong>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</strong></li>\n<li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li>\n<li>将rehashidx赋值为-1，代表rehash结束</li>\n<li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li>\n</ol>\n<blockquote>\n<p>总结：</p>\n</blockquote>\n<p>Dict的结构：</p>\n<ul>\n<li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li>\n<li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li>\n</ul>\n<p>Dict的伸缩：</p>\n<ul>\n<li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li>\n<li>当LoadFactor小于0.1时，Dict收缩</li>\n<li>扩容大小为第一个大于等于used + 1的2^n</li>\n<li>收缩大小为第一个大于等于used 的2^nDict采用渐进式rehash，每次访问Dict时执行一次rehash</li>\n<li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li>\n</ul>\n<h3 id=\"ZipList\"><a href=\"#ZipList\" class=\"headerlink\" title=\"ZipList\"></a>ZipList</h3><p>​    ZipList 是一种<strong>特殊的“双端链表”</strong> ，由一系列特殊编码的<strong>连续内存</strong>块组成。可以在<strong>任意一端进行压入/弹出</strong>操作, 并且该操作的时间复杂度为 **O(1)**。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ic7og3jvj30tq0bw3ze.jpg\" alt=\"image-20221126105002059\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ic8fm1plj30rw09rta6.jpg\" alt=\"image-20221126105045389\"></p>\n<p>​    ZipList说是特殊的来链表，但实际上并不是通过指针连接的，因为占用内存，所以Entry的结构是：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8icayfrsdj30vb07o3zr.jpg\" alt=\"image-20221126105310737\"></p>\n<p>​    因为是一块儿内存，每个节点记录了前一个节点的长度，就可以计算出各个节点的位置。</p>\n<blockquote>\n<p>这里有一个<strong>连锁更新</strong>（Cascade Update）的问题，但作者并未修改，因为发生的概率极低、</p>\n</blockquote>\n<p>​    假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8idymm1vij316e06dgmi.jpg\" alt=\"image-20221126115032201\"></p>\n<p>​    现在在头位置插入一个新的节点，长度为254，则原先的头结点的<code>previous_entry_length</code>就会用5个字节来存储，那么该节点本身的长度就超过了254，则后续所有节点都必须更新。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ie0zbr30j31ce06lgmo.jpg\" alt=\"image-20221126115247739\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ie1ey0jmj31c006qq42.jpg\" alt=\"image-20221126115312608\"></p>\n<blockquote>\n<p>总结：</p>\n</blockquote>\n<ol>\n<li>压缩列表的可以看做一种<strong>连续内存</strong>空间的”双向链表”</li>\n<li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点<strong>长度来寻址</strong>，内存占用较低</li>\n<li>如果列表数据过多，导致链表过长，可能影响查询性能</li>\n<li>增或删较大数据时有可能发生<strong>连续更新</strong>问题</li>\n</ol>\n<h3 id=\"QuickList\"><a href=\"#QuickList\" class=\"headerlink\" title=\"QuickList\"></a>QuickList</h3><blockquote>\n<p>​    上面我们学习了ZipList，虽然好操作，但因为是连续的空间，所以如果长度太长，也会影响效率，并且申请更多的连续空间，</p>\n</blockquote>\n<p>所以我们必须限制ZipList的长度和entry大小。</p>\n<blockquote>\n<p>如果ZipList超出上线怎么办？</p>\n</blockquote>\n<p>​    利用分片思想，形成多个ZipList，但分散后又不方便管理，则推出了：QuickList。它是一个双端链表，只不过链表中的每个节点都是一个ZipList。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ie8o2laqj30xo07gt9k.jpg\" alt=\"image-20221126120010880\"></p>\n<p>​    为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size来限制。</p>\n<ul>\n<li>如果值为正，则代表ZipList的允许的entry个数的最大值</li>\n<li>如果值为负，则代表ZipList的最大内存大小，分5种情况：<ul>\n<li>-1：每个ZipList的内存占用不能超过4kb</li>\n<li>-2：每个ZipList的内存占用不能超过8kb</li>\n<li>-3：每个ZipList的内存占用不能超过16kb</li>\n<li>-4：每个ZipList的内存占用不能超过32kb</li>\n<li>-5：每个ZipList的内存占用不能超过64kb</li>\n</ul>\n</li>\n</ul>\n<p>默认值：<code>config get list-max-ziplist-size</code></p>\n<p>​    除了控制ZipList的大小，QuickList还可以对节点的ZipList做<strong>压缩</strong>。通过配置项list-compress-depth来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p>\n<ul>\n<li>0：特殊值，代表不压缩</li>\n<li>1：标示QuickList的首尾各有1个节点不压缩，中间节点压缩</li>\n<li>2：标示QuickList的首尾各有2个节点不压缩，中间节点压缩</li>\n<li>以此类推</li>\n</ul>\n<p>默认值：<code>config get list-compress-depth</code></p>\n<blockquote>\n<p>源码：</p>\n</blockquote>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8iecj8qewj30tk0budje.jpg\" alt=\"image-20221126120353527\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8iecz7jujj30vy0eddhb.jpg\" alt=\"image-20221126120419505\"></p>\n<blockquote>\n<p>特点：</p>\n</blockquote>\n<ol>\n<li>是一个节点为ZipList的双端链表</li>\n<li>节点采用ZipList，解决了传统链表的内存占用问题</li>\n<li>控制了ZipList大小，解决连续内存空间申请效率问题</li>\n<li>中间节点可以压缩，进一步节省了内存</li>\n</ol>\n<h3 id=\"kipList\"><a href=\"#kipList\" class=\"headerlink\" title=\"kipList\"></a>kipList</h3><blockquote>\n<p>​    原有链表的一个问题，就是查找元素时，需要一个个遍历，每个节点有一个指针指向下一个元素，那能不能多加几个指针？</p>\n</blockquote>\n<p>跳表的结构图：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8iefh0xxjj30y80a3js9.jpg\" alt=\"image-20221126120643605\"></p>\n<p>可以看到跳表的一个特性就是有序，如果无序，则多出来的指针没有意义。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8iehdfaioj31do0icgp2.jpg\" alt=\"image-20221126120833282\"></p>\n<blockquote>\n<p>总结：</p>\n</blockquote>\n<ol>\n<li>跳跃表是一个双向链表，每个节点都包含score和ele值</li>\n<li>节点按照score值排序，score值一样则按照ele字典排序</li>\n<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>\n<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>\n<li>增删改查效率与红黑树基本一致，实现却更简单</li>\n</ol>\n<h3 id=\"RedisObject\"><a href=\"#RedisObject\" class=\"headerlink\" title=\"RedisObject\"></a>RedisObject</h3><p>Redis中的任意数据类型<code>(String,List,Set,Hash,ZSet)</code>都会被封装为RedisObject对象。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8iel9ffxvj30r508v765.jpg\" alt=\"image-20221126121217400\"></p>\n<h4 id=\"底层编码方式\"><a href=\"#底层编码方式\" class=\"headerlink\" title=\"底层编码方式\"></a>底层编码方式</h4><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8iembds0pj30pw0ce0ud.jpg\" alt=\"image-20221126121318276\"></p>\n<h4 id=\"五种数据类型的底层类型：\"><a href=\"#五种数据类型的底层类型：\" class=\"headerlink\" title=\"五种数据类型的底层类型：\"></a>五种数据类型的底层类型：</h4><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>数据类型</strong></th>\n<th><strong>编码方式</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">OBJ_STRING</td>\n<td>int、embstr、raw</td>\n</tr>\n<tr>\n<td align=\"left\">OBJ_LIST</td>\n<td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td>\n</tr>\n<tr>\n<td align=\"left\">OBJ_SET</td>\n<td>intset、HT</td>\n</tr>\n<tr>\n<td align=\"left\">OBJ_ZSET</td>\n<td>ZipList、HT、SkipList</td>\n</tr>\n<tr>\n<td align=\"left\">OBJ_HASH</td>\n<td>ZipList、HT</td>\n</tr>\n</tbody></table>\n<h2 id=\"五种数据类型\"><a href=\"#五种数据类型\" class=\"headerlink\" title=\"五种数据类型\"></a>五种数据类型</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>我们知道底层是通过SDS结构，但不同的SDS长度会使用不同的编码。</p>\n<p>如果存储的是字符串是整数值，大小在Long_MAX范围内，则会使用INT编码，直接将数据保存在RedisObject的ptr指针位置（刚好8字节），<strong>不再需要SDS了</strong>。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ieqz0q53j30k203jdfx.jpg\" alt=\"image-20221126121746597\"></p>\n<p>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8iero6hhaj30us02xmxd.jpg\" alt=\"image-20221126121826644\"></p>\n<p>否则用的就是raw编码了，SDS单独占一个内存，RedisObject用指针连接</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8iesl4ctqj30uy081t93.jpg\" alt=\"image-20221126121919607\"></p>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><blockquote>\n<p>我们可以自己想一想，底层结构中哪个合适?</p>\n</blockquote>\n<p>List操作需要可以从两端插入或弹出，范围读取。</p>\n<p>SDS是字符串（❎），intSet是完整的内存，支持有序，唯一（❎），Dict无法双端操作（❎）</p>\n<p>ZipList：完整内存，双端操作，范围读取（✅）</p>\n<p>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高（✅）</p>\n<ul>\n<li>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</li>\n<li>在3.2版本之后，Redis统一采用QuickList来实现List</li>\n</ul>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>Set需要元素唯一（可判断是否元素存在），不保证有序，求交集，并集，差集，也就是对查询效率要求很高</p>\n<p>我们能想到Java中，利用Map实现Set结构，Value存Null，那在Redis中应该也可以，所以Dict(✅)</p>\n<p>IntSet内部是整数数组，不过可以保证唯一，且有序，二分查询也快。当存储的所有数据都是整数，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存，IntSet(✅)</p>\n<h3 id=\"ZSet\"><a href=\"#ZSet\" class=\"headerlink\" title=\"ZSet\"></a>ZSet</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值。要求：</p>\n<p>可以根据score值排序，member必须唯一，可以根据member查询分数</p>\n<ol>\n<li>那想到第一个应该是Dict结构，key为member，value为score，可以保证member唯一，✅</li>\n<li>然后有分数的就是SkipList，可以排序，并且可以同时存储score和ele值（member）✅</li>\n<li>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：✅<ol>\n<li>元素数量小于zset_max_ziplist_entries，默认值128</li>\n<li>每个元素都小于zset_max_ziplist_value字节，默认值64</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p>\n</blockquote>\n<ol>\n<li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry， element在前，score在后</li>\n<li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li>\n</ol>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8ifcqek5sj30tz06xt96.jpg\" alt=\"image-20221126123840996\"></p>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p>需求：</p>\n<ol>\n<li>键值存储</li>\n<li>根据键获取值</li>\n<li>键唯一</li>\n</ol>\n<p>我们发现与Zset需求很相似</p>\n<ol>\n<li>zset的键是member，值是score；hash的键和值都是任意值</li>\n<li>zset要根据score排序；hash则无需排序</li>\n</ol>\n<p>因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可。也就是剩下ZipList和Dict</p>\n<ul>\n<li><p>Hash结构默认采用ZipList编码，用以节省内存。 ZipList中相邻的两个entry 分别保存field和value ✅</p>\n</li>\n<li><p>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件有两个： ✅</p>\n<ul>\n<li>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</li>\n<li>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</li>\n</ul>\n</li>\n</ul>\n","text":"BigKey是什么 ？BigKey通常以Key的大小和Key中成员的数量来综合判定，例如： Key本身的数据量过大：一个String类型的Key，它的值为5 MB。 Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。 Key中成员的数据量过大：一个Ha...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Redis","slug":"Redis","count":2,"path":"api/categories/Redis.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BigKey\"><span class=\"toc-text\">BigKey</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88-%EF%BC%9F\"><span class=\"toc-text\">是什么 ？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3-%EF%BC%9F\"><span class=\"toc-text\">有什么危害 ？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E8%AF%86%E5%88%AB-%EF%BC%9F\"><span class=\"toc-text\">怎么识别 ？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4-%EF%BC%9F\"><span class=\"toc-text\">如何删除 ？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">底层数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS\"><span class=\"toc-text\">动态字符串SDS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IntSet\"><span class=\"toc-text\">IntSet</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%A2%9E%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">新增流程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">升级流程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Dict\"><span class=\"toc-text\">Dict</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Dict%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">Dict扩容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Dict%E6%94%B6%E7%BC%A9\"><span class=\"toc-text\">Dict收缩</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Dict%E7%9A%84ReHash\"><span class=\"toc-text\">Dict的ReHash</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ZipList\"><span class=\"toc-text\">ZipList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#QuickList\"><span class=\"toc-text\">QuickList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#kipList\"><span class=\"toc-text\">kipList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RedisObject\"><span class=\"toc-text\">RedisObject</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BA%95%E5%B1%82%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">底层编码方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E7%B1%BB%E5%9E%8B%EF%BC%9A\"><span class=\"toc-text\">五种数据类型的底层类型：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">五种数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#String\"><span class=\"toc-text\">String</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#List\"><span class=\"toc-text\">List</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Set\"><span class=\"toc-text\">Set</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ZSet\"><span class=\"toc-text\">ZSet</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Hash\"><span class=\"toc-text\">Hash</span></a></li></ol></li></ol>","author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"第一章：栈与队列","uid":"7bfcb6263ec210a85c00c06eddb51ce5","slug":"数据结构/第一章：栈与队列","date":"2022-11-27T05:03:04.000Z","updated":"2022-11-27T10:24:19.773Z","comments":true,"path":"api/articles/数据结构/第一章：栈与队列.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"第一章：栈与队列设计一个有getMin功能的栈 要求：pop，push，getMin的时间复杂度为：O(1) 123456789101112131415161718192021222324252627282930313233public class stackTemplate &...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":3,"path":"api/categories/数据结构.json"}],"tags":[{"name":"栈","slug":"栈","count":1,"path":"api/tags/栈.json"},{"name":"队列","slug":"队列","count":1,"path":"api/tags/队列.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"垃圾回收与内存分配","uid":"4d85e3fb54b920a7053434d8fa115e61","slug":"JVM/3_垃圾收集器与内存分配策略","date":"2022-11-25T05:04:04.000Z","updated":"2022-12-02T07:43:54.396Z","comments":true,"path":"api/articles/JVM/3_垃圾收集器与内存分配策略.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"垃圾收集器与内存分配策略概述我们先提出三个问题： 哪部分内存需要回收? 什么时候进行回收？ 如何进行回收？ 生存还是死亡？where​ 我们都知道在Java中，栈，本地方法区，程序计数器都是线程私有的，随着线程的创建和结束，内存也会自动的分配和销毁，执行的方法也随着栈帧的插入和弹...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"JVM","slug":"JVM","count":4,"path":"api/categories/JVM.json"}],"tags":[{"name":"垃圾回收","slug":"垃圾回收","count":1,"path":"api/tags/垃圾回收.json"},{"name":"内存分配","slug":"内存分配","count":1,"path":"api/tags/内存分配.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}