{"title":"并发编程","uid":"be447ed25be14672c8ade5d39be9da07","slug":"并发/并发编程","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:49:54.174Z","comments":true,"path":"api/articles/并发/并发编程.json","keywords":null,"cover":"/img/default_top_img.jpg","content":"<h2 id=\"基础的概念\"><a href=\"#基础的概念\" class=\"headerlink\" title=\"基础的概念\"></a>基础的概念</h2><h3 id=\"什么是并发操作？\"><a href=\"#什么是并发操作？\" class=\"headerlink\" title=\"什么是并发操作？\"></a>什么是并发操作？</h3><p>利用多核CPU去完成任务，类似于使用影分身去完成不同的作业，这肯定比我一个人一个个写要快的多</p>\n<h3 id=\"什么时候可以使用并发？\"><a href=\"#什么时候可以使用并发？\" class=\"headerlink\" title=\"什么时候可以使用并发？\"></a>什么时候可以使用并发？</h3><p>当有多核CPU时。如果只有一个CPU，那并发实际上只是线程的不断切换，好比我在数学作业上先写点儿，再到语文上再写点儿，因为处理的很快，给人的感觉是同时操作的。但实际上只会比原来更慢。</p>\n<h3 id=\"如何使用并发编程？\"><a href=\"#如何使用并发编程？\" class=\"headerlink\" title=\"如何使用并发编程？\"></a>如何使用并发编程？</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BasicLearn</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">A</span>()).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;String&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">B</span>())).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">C</span>().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 无返回值</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 有返回值</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Callable</span>&lt;String&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot; a &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>实现Runnable或Callable接口，从写run方法。</li>\n<li>继承Thread类，从写run方法</li>\n</ol>\n<h3 id=\"实现Runnable-和-继承Thread有什么区别\"><a href=\"#实现Runnable-和-继承Thread有什么区别\" class=\"headerlink\" title=\"实现Runnable 和 继承Thread有什么区别\"></a>实现Runnable 和 继承Thread有什么区别</h3><ol>\n<li>Java是单继承结构，如果继承Thread，无法继承其他的类，接口更灵活</li>\n<li>继承Thread开销会大一些，如果我们只要求可运行</li>\n</ol>\n<h3 id=\"线程的分类\"><a href=\"#线程的分类\" class=\"headerlink\" title=\"线程的分类\"></a>线程的分类</h3><ol>\n<li><p>普通线程，就是我们上面所讲的内容</p>\n</li>\n<li><p>守护线程，也叫做<code>Daemon</code>，当所有非守护线程结束后，守护线程就会被回收。比如说垃圾回收就是守护线程</p>\n<ol>\n<li>```java<br>// 注意守护线程不能操作重要的数据，因为无法保证可以执行完后，守护线程才停止。<br>public static void main(String[] args) {<pre><code>Thread thread = new Thread(new MyRunnable());\nthread.setDaemon(true);\n</code></pre>\n}<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 线程的状态</span><br><span class=\"line\"></span><br><span class=\"line\">1. New ：创建好，但还未启动</span><br><span class=\"line\">2. Runable ：Runable本身是两个状态，一个是Runable表示等待CPU时间片的线程，一个是Running表示正在使用时间片的线程</span><br><span class=\"line\">3. Blocked ：阻塞住的线程 </span><br><span class=\"line\">4. Waiting  ：一直等待线程，直到被唤醒</span><br><span class=\"line\">5. Time Waiting ：有时间的等待，到时间自己醒了</span><br><span class=\"line\">6. terminted ：线程结束</span><br><span class=\"line\"></span><br><span class=\"line\">### 线程的中断</span><br><span class=\"line\"></span><br><span class=\"line\">​\t听起来线程的中断有点儿像人家正好好干活，你突然把人家赶走了。但实际上是这个线程在 Blocked 或 Waiting 时，我们将其打断，让他别等了。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t我们常用：`interrupt() ` 来打断线程，打断后会抛出 InterruptedException，从而提前结束该线程。但是**不能中断 I/O 阻塞和 synchronized 锁阻塞**。也是比较好判断的就是你看方法的调用是否有InterruptedException,如果有说明可以被打断。</span><br><span class=\"line\"></span><br><span class=\"line\">​\t如果该线程好好干活，我们是无法将其打断的。调用 `interrupt()`，只会是将其内部状态作为修改，通过 `interrupted()` 我们可以看这个线程是否被打断过，在 `while（true）中我们可以通过使用 interrupted() 来判断是否跳出循环 `</span><br><span class=\"line\"></span><br><span class=\"line\">​\t在使用 Executor 去管理多个线程任务时，有方法 `shutdown() 和 shutdownNow()`，区别是 shutdown() 是等所有线程执行完后进行结束。而shutdownNow()表示现在就可以结束了。</span><br><span class=\"line\"></span><br><span class=\"line\">### 多线程的缺点</span><br><span class=\"line\"></span><br><span class=\"line\">​\t一旦涉及到多线程，总是面临着数据安全的问题，如果一组操作没有原子性，那在多线程的情况下就会出现数据安全的问题。所以为了数据的安全性，我们引出了锁的概念，线程去抢同一把锁，谁抢到了谁去操作数据，其他人就在外面等着（阻塞），直到锁被之前持有的线程释放。锁的实现分为很多种，我们下面会介绍。</span><br><span class=\"line\"></span><br><span class=\"line\">### 线程各个操作导致的状态</span><br><span class=\"line\"></span><br><span class=\"line\">​\t这里我们常在使用锁的情况下来描述，比方说多个线程抢同一把锁，如果使用 `Thread.sleep() 或 Thread.yield() `是否会放回锁。</span><br><span class=\"line\"></span><br><span class=\"line\">```java</span><br><span class=\"line\">// 线程进入Runable，但未释放锁资源</span><br><span class=\"line\">Thread.yield();</span><br><span class=\"line\">// 线程进入Blocked，但未释放锁资源</span><br><span class=\"line\">Thread.sleep();</span><br><span class=\"line\">// 线程进入Waiting状态，释放锁资源</span><br><span class=\"line\">objectLock.wait();</span><br><span class=\"line\">// 底层实际用的wait(), 释放锁资源</span><br><span class=\"line\">Thread.join();</span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>这里有个小问题：<code>objectLock.notify() 与 objectLock.notifyall() </code> 有什么区别？</p>\n</blockquote>\n<p>notify是释放一个线程去抢锁，notifyall是释放所有等待的去抢锁，但只有一个能抢到。这看起来感觉不到区别。</p>\n<p>实际上每个对象底层有两个池：锁池 和 等待池</p>\n<ol>\n<li>在锁池的是阻塞状态，当锁被释放，所有在锁池的对象都有机会获得锁</li>\n<li>在等待池的是等待状态，是没有资格去抢锁的，只能被人唤醒</li>\n</ol>\n<p>​    当A线程抢到锁后，B线程没抢到就进入了锁池，A线程虽然抢到了，但是需要的资源没到位，使用了wait，进入的是等待池。这时候B就可以获取锁，并执行业务了，但A因为在等待池，所以即便是锁没被占用，自己仍无法操作，直到被唤醒。</p>\n<p>​    notify() 是将等待池的一个线程加入锁池，而notifyall() 是将等待池中的所有线程加入锁池。</p>\n<h3 id=\"当一个线程需要等待另一个线程的资源\"><a href=\"#当一个线程需要等待另一个线程的资源\" class=\"headerlink\" title=\"当一个线程需要等待另一个线程的资源\"></a>当一个线程需要等待另一个线程的资源</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">start</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">objectLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        objectLock.wait();</span><br><span class=\"line\">        objectLock.notify();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ReentrantLock</span> <span class=\"variable\">reentrantLock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">        <span class=\"type\">Condition</span> <span class=\"variable\">condition</span> <span class=\"operator\">=</span> reentrantLock.newCondition();</span><br><span class=\"line\">        condition.wait();</span><br><span class=\"line\">        condition.signalAll();</span><br><span class=\"line\"></span><br><span class=\"line\">        LockSupport.park();</span><br><span class=\"line\">        LockSupport.unpark(Thread.currentThread());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如我们主线程需要等待一个启动线程返回的结果，我们可以直接使用<code>Thread.join()</code>,等待该线程将资源返回，但这种方式必须要等到线程结束，主线程才能去获取，非常不灵活。因此我们常使用 <code>Object.wait() 与 Object.notify()</code>  方法可以更加主动的去等待与被通知。但有什么缺陷呢？</p>\n<ol>\n<li> 必须在静态代码块儿中使用，负责会抛出异常，这一点在 <code>condition.wait() 与condition.signal() </code>也存在</li>\n<li>必须先<code>wait() 再 notify()</code> 否则会报错，因此我们常用：<code>LockSupport.park();</code></li>\n</ol>\n<p>LockSupport.park(); 底层使用的Unsafe类，它是可以操作线程和内存的，所以说不安全，要规范使用，在Atomic类中底层调用的也是它。而且它不能被直接获取，只能通过反射来获取。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UnsafeAccessor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Unsafe unsafe;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">theUnsafe</span> <span class=\"operator\">=</span> Unsafe.class.getDeclaredField(<span class=\"string\">&quot;theUnsafe&quot;</span>);</span><br><span class=\"line\">            theUnsafe.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">            unsafe = (Unsafe) theUnsafe.get(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Unsafe <span class=\"title function_\">getUnsafe</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Volatile\"><a href=\"#Volatile\" class=\"headerlink\" title=\"Volatile\"></a>Volatile</h3><h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><p>这里设计线程的工作内存与主内存数据的交互，为什么有工作内存，就是因为CPU对寄存器的操作远远超出了对内存的操作，所以线程是工作内存拷贝主内存，来使得CPU操作工作内存更快速，</p>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><p>禁止指令重排</p>\n<h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8faeik83zj30u70ifgnm.jpg\" alt=\"image-20221123193040531\"></p>\n<h3 id=\"ReentrantLock-源码解读\"><a href=\"#ReentrantLock-源码解读\" class=\"headerlink\" title=\"ReentrantLock 源码解读\"></a>ReentrantLock 源码解读</h3><h3 id=\"活锁，死锁，哲学家问题\"><a href=\"#活锁，死锁，哲学家问题\" class=\"headerlink\" title=\"活锁，死锁，哲学家问题\"></a>活锁，死锁，哲学家问题</h3><p>活锁： 两个线程互相影响彼此依赖的变量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestLiveLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 期望减到 0 退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                sleep(<span class=\"number\">0.2</span>);</span><br><span class=\"line\">                count--;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t1&quot;</span>).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 期望超过 20 退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count &lt; <span class=\"number\">20</span>) &#123;</span><br><span class=\"line\">                sleep(<span class=\"number\">0.2</span>);</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;t2&quot;</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>死锁：程序需要获取两把锁才能向下执行，两个线程各拿到了一把锁，等待另一把，导致双方都进入阻塞。</p>\n<p>哲学家问题就是死锁问题的一种形式。</p>\n<h2 id=\"进阶知识\"><a href=\"#进阶知识\" class=\"headerlink\" title=\"进阶知识\"></a>进阶知识</h2><h3 id=\"Monitor\"><a href=\"#Monitor\" class=\"headerlink\" title=\"Monitor\"></a>Monitor</h3><p>Java对象头</p>\n<p>普通对象：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8faus1kkwj30kw04ljrt.jpg\" alt=\"image-20221123194620216\"></p>\n<p>数组对象：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8fav2bu47j30rt04t3z6.jpg\" alt=\"image-20221123194636687\"></p>\n<p>其中Mark Wordd的内部结构（32位虚拟机）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8favja6noj30on0bwtal.jpg\" alt=\"image-20221123194704096\"></p>\n<p>64位虚拟机</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8faw6ikyrj30sh0bjwgm.jpg\" alt=\"image-20221123194741408\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (lock) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>synchronized 对对象加入重量级锁时，Mark Work中就会有指向Monitor对象的指针</code>，下面我们看看Monitor的结构</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8fb7t8hbdj30uq0cf0u9.jpg\" alt=\"image-20221123195851860\"></p>\n<p>WaitSet 就是等待队列</p>\n<p>EntryList 就是阻塞队列</p>\n<p>Owner 就是当前获取锁的线程</p>\n<h3 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h3><h4 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h4><p>​    以前线程没有抢到锁，就会直接进入阻塞队列，但这代价太大了，所以JDK1.6后，因为了自旋锁，也就是抢不到锁后，没立刻阻塞，而是继续尝试获取锁，最后实在不行，就阻塞，因为也占用CPU资源。尝试几次是看之前获取几次来判断的，这也是自适应自旋锁的一个特点。</p>\n<p>​    自旋会占用CPU，所以单核CPU自旋就是浪费，只有多核CPU才能提高性能</p>\n<h4 id=\"锁消除\"><a href=\"#锁消除\" class=\"headerlink\" title=\"锁消除\"></a>锁消除</h4><p>​    通过逃逸分析，发现一个虽然加锁了，但实际上数据是无法被外界影响的，就会把锁消除。</p>\n<h4 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h4><p>​    对一个对象反复的加锁解锁，性能影响很大，如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。</p>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><ol>\n<li>对使用者透明：<code>synchronized</code></li>\n<li>多线程访问的时间是错开的，可用轻量级锁来优化</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">obj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">synchronized</span>( obj ) &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 同步块 A</span></span><br><span class=\"line\"> method2();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">synchronized</span>( obj ) &#123;</span><br><span class=\"line\"> <span class=\"comment\">// 同步块 B</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当遇到加锁操作时，线程的栈帧中会创建一个（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的解耦，内部存放锁定对象的Mark Word</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8g07uvra5j30n00cl0ty.jpg\" alt=\"image-20221124102353283\"></p>\n<ul>\n<li><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录。</p>\n<ul>\n<li>如果成功说明，锁当前没有被占用，01 代表无锁，00代表轻量级锁，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>\n<li>如果失败说明，有竞争，进入锁膨胀过程</li>\n<li>如果发现有竞争，但是可以通过Mark Word 判断加锁的线程是不是自己，如果是自己，则再添加一个Lock Record作为重入计数</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8g0bqg2mpj30oy0e3abi.jpg\" alt=\"image-20221124102736732\"></p>\n</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8g0ed5zh5j30p70ftmz3.jpg\" alt=\"image-20221124103008743\"></p>\n<p>​    当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一。</p>\n<p>​    当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p>\n<ul>\n<li><p>成功，则解锁成功</p>\n</li>\n<li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>\n</li>\n</ul>\n<h4 id=\"锁膨胀\"><a href=\"#锁膨胀\" class=\"headerlink\" title=\"锁膨胀\"></a>锁膨胀</h4><p>​    当发现线程竞争发生了直接冲突时，就会将Object中MarkWork指向Monitor，并且将状态改为10。10就是重量级锁。阻塞线程就进入Monitor的EntryList进行阻塞。</p>\n<p>​    当持有轻量级锁的线程进行cas操作时，发现失败了，就说明现在已经是重量级锁了，则通过Monitor地址找到Monitor对象，将Owner设置为空，表示锁释放，然后通知EntryList阻塞线程唤醒。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8g0o9wodtj30uz0b8dhe.jpg\" alt=\"image-20221124103939951\"></p>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p>偏向锁是对轻量级锁的再次优化，之前使用轻量级锁方案时，每次获取锁都要和Object的对象头做CAS操作，即便是重入锁，也需要该操作。现在希望Object对象头上直接写占有锁的线程ID，这样只要比较，不进行CAS操作。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8g111ax0wj30p70jqmz0.jpg\" alt=\"image-20221124105155494\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8g118jj14j30ov0dagmr.jpg\" alt=\"image-20221124105207495\"></p>\n<p>查看对象头的信息</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.openjdk.jol<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jol-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.16<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    // 这里需要注意，不用provided</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8g1m9xer0j30sx0c276u.jpg\" alt=\"image-20221124111220643\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">start</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"comment\">//        0x0000000000000001</span></span><br><span class=\"line\">        System.err.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">4000</span>);</span><br><span class=\"line\"><span class=\"comment\">//        延迟显示，不延迟：-XX:BiasedLockingStartupDelay=0</span></span><br><span class=\"line\">        System.err.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>适用范围：锁竞争少。</p>\n<p>如果是多线程竞争，可以设置关闭偏向锁，默认是开启的，适用：<code>-XX:-UseBiasedLocking</code></p>\n<blockquote>\n<p>需要注意：当使用了对象的.hashcode()方法会变为不可偏向</p>\n</blockquote>\n<p>因为在偏向锁中对象头没有位置存储HashCode，所以转为轻量级锁或者重量级锁。每个对象最初的HashCode为0，第一次使用时，进行赋值。</p>\n<h3 id=\"线程安全的集合类\"><a href=\"#线程安全的集合类\" class=\"headerlink\" title=\"线程安全的集合类\"></a>线程安全的集合类</h3><p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8g22iaj76j30to06caam.jpg\" alt=\"image-20221124112756210\"></p>\n<p>这里分为三类</p>\n<ol>\n<li><p>遗留的：HashTable（Map），Vector（List）</p>\n</li>\n<li><p>使用 Collections 装饰的线程安全集合，如：Collections.synchronizedCollection，可以将线程不安全的集合包装为线程安全的，底层实际上就是方法调用时包装类对原先方法加锁。  </p>\n</li>\n<li><p>JUC包下的类</p>\n</li>\n</ol>\n","text":"基础的概念什么是并发操作？利用多核CPU去完成任务，类似于使用影分身去完成不同的作业，这肯定比我一个人一个个写要快的多 什么时候可以使用并发？当有多核CPU时。如果只有一个CPU，那并发实际上只是线程的不断切换，好比我在数学作业上先写点儿，再到语文上再写点儿，因为处理的很快，给人...","link":"","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"并发","slug":"并发","count":2,"path":"api/categories/并发.json"}],"tags":[{"name":"并发","slug":"并发","count":1,"path":"api/tags/并发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E7%9A%84%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基础的概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%EF%BC%9F\"><span class=\"toc-text\">什么是并发操作？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%EF%BC%9F\"><span class=\"toc-text\">什么时候可以使用并发？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">如何使用并发编程？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0Runnable-%E5%92%8C-%E7%BB%A7%E6%89%BFThread%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">实现Runnable 和 继承Thread有什么区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">线程的分类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">当一个线程需要等待另一个线程的资源</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Volatile\"><span class=\"toc-text\">Volatile</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">可见性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%BA%8F%E6%80%A7\"><span class=\"toc-text\">有序性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%AD%90%E6%80%A7\"><span class=\"toc-text\">原子性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ReentrantLock-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB\"><span class=\"toc-text\">ReentrantLock 源码解读</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B4%BB%E9%94%81%EF%BC%8C%E6%AD%BB%E9%94%81%EF%BC%8C%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">活锁，死锁，哲学家问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">进阶知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Monitor\"><span class=\"toc-text\">Monitor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%94%81%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">锁优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E6%97%8B%E9%94%81\"><span class=\"toc-text\">自旋锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%81%E6%B6%88%E9%99%A4\"><span class=\"toc-text\">锁消除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%81%E7%B2%97%E5%8C%96\"><span class=\"toc-text\">锁粗化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">轻量级锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%94%81%E8%86%A8%E8%83%80\"><span class=\"toc-text\">锁膨胀</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%81%8F%E5%90%91%E9%94%81\"><span class=\"toc-text\">偏向锁</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB\"><span class=\"toc-text\">线程安全的集合类</span></a></li></ol></li></ol>","author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"手写线程池","uid":"df1cff2ea6b0a8229883d729950dd5e6","slug":"并发/手写线程池","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:50:12.412Z","comments":true,"path":"api/articles/并发/手写线程池.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"手写线程池 ​ 我们从初级阶段自己创建线程去异步执行任务，到后期使用线程池不断执行任务，原理书上都有，但都是字面意思，无法深入理解，所以打算自己进行实现。 阶段一： 123456new Thread(new Runnable() &#123; @Override public v...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"并发","slug":"并发","count":2,"path":"api/categories/并发.json"}],"tags":[{"name":"线程池","slug":"线程池","count":1,"path":"api/tags/线程池.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Mysql的事务与索引","uid":"99be73816d71c90e1cc1cbf82e76416f","slug":"数据库/Mysql的事务与索引","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T07:26:26.008Z","comments":true,"path":"api/articles/数据库/Mysql的事务与索引.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"Mysql事务与索引 ​ 需求：先从数据库中读取摸一个字段的值，然后在该字段上的基础上进行修改，由于操作不是原子性，无法保证线程安全，也就是当A线程读取到1时，想+1，赋值为2。而B线程已经将数据修改为2了，那么A线程应该是在2的基础上+1，赋值为3。但实际中可能该值都到8了，A...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":1,"path":"api/tags/Mysql.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}