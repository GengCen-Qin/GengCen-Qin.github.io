{"title":"第一章：栈与队列","uid":"7bfcb6263ec210a85c00c06eddb51ce5","slug":"数据结构/第一章：栈与队列","date":"2022-11-27T05:03:04.000Z","updated":"2022-11-27T10:24:19.773Z","comments":true,"path":"api/articles/数据结构/第一章：栈与队列.json","keywords":null,"cover":"/img/default_top_img.jpg","content":"<h1 id=\"第一章：栈与队列\"><a href=\"#第一章：栈与队列\" class=\"headerlink\" title=\"第一章：栈与队列\"></a>第一章：栈与队列</h1><h2 id=\"设计一个有getMin功能的栈\"><a href=\"#设计一个有getMin功能的栈\" class=\"headerlink\" title=\"设计一个有getMin功能的栈\"></a>设计一个有getMin功能的栈</h2><blockquote>\n<p>要求：pop，push，getMin的时间复杂度为：O(1)</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">stackTemplate</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记录插入值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 记录插入值的最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; minStack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        stack.push(value);</span><br><span class=\"line\">        <span class=\"comment\">// 如果最小值栈的栈顶元素 大于 当前元素，则说明有新的最小值了，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (minStack.isEmpty() || minStack.peek() &gt;= value) &#123;</span><br><span class=\"line\">            minStack.push(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;栈为空&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">pop</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pop &lt;= minStack.peek()) &#123;</span><br><span class=\"line\">            minStack.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMin</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minStack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isEmpty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stack.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"由两个栈组成的队列\"><a href=\"#由两个栈组成的队列\" class=\"headerlink\" title=\"由两个栈组成的队列\"></a>由两个栈组成的队列</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">myQueue</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; inStack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;Integer&gt; outStack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isEmpty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inStack.isEmpty() &amp;&amp; outStack.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        inStack.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;栈为空&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pushToPop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outStack.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">peek</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pushToPop();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outStack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushToPop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (outStack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!inStack.isEmpty()) &#123;</span><br><span class=\"line\">                outStack.push(inStack.pop());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如何仅用递归函数和栈操作逆序一个栈\"><a href=\"#如何仅用递归函数和栈操作逆序一个栈\" class=\"headerlink\" title=\"如何仅用递归函数和栈操作逆序一个栈\"></a>如何仅用递归函数和栈操作逆序一个栈</h2><blockquote>\n<p>通过递归函数实现栈中元素的逆序，比如放入：1,2,3,4. 逆序后：4,3,2,1</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 递归逆序栈  其实底层利用了栈帧的局部变量表去存储临时变量</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 每次pop()，返回栈底元素</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getAndRemoveLastElement</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">pop</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">lastElement</span> <span class=\"operator\">=</span> getAndRemoveLastElement(stack);</span><br><span class=\"line\">    stack.push(pop);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lastElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 逆序栈</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reverse</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果为空，说明已经到底了，栈内没元素了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 我们可以理解为，每次我就去取栈底的值，</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">element</span> <span class=\"operator\">=</span> getAndRemoveLastElement(stack);</span><br><span class=\"line\">    <span class=\"comment\">// 剩下的每一次递归都会去取栈底元素，直到为空</span></span><br><span class=\"line\">    reverse(stack);</span><br><span class=\"line\">    <span class=\"comment\">// 将栈底元素放到栈顶</span></span><br><span class=\"line\">    stack.push(element);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"用一个栈实现另一个栈的排序\"><a href=\"#用一个栈实现另一个栈的排序\" class=\"headerlink\" title=\"用一个栈实现另一个栈的排序\"></a>用一个栈实现另一个栈的排序</h2><p>方法1（利用栈帧）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack&lt;Integer&gt; helpStack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reverse</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (helpStack.isEmpty() || helpStack.peek() &gt;= value) &#123;</span><br><span class=\"line\">        helpStack.push(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">Integer</span> <span class=\"variable\">pop</span> <span class=\"operator\">=</span> helpStack.pop();</span><br><span class=\"line\">    reverse(value);</span><br><span class=\"line\">    helpStack.push(pop);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reverseByStack</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将stack内所有元素有序放入helpStack，所有元素访问后，helpStack有序，则导入stack，保证stack有序</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        reverse(stack.pop());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!helpStack.isEmpty()) &#123;</span><br><span class=\"line\">        stack.push(helpStack.pop());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法2（利用栈本身，更省空间）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过一个栈来帮另一个栈做排序， 将多余的值直接放入stack，性能更好，也更节省空间</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reverseByStackPlus</span><span class=\"params\">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Stack&lt;Integer&gt; helpStack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!helpStack.isEmpty() &amp;&amp; helpStack.peek() &lt; cur) &#123;</span><br><span class=\"line\">            stack.push(helpStack.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        helpStack.push(cur);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!helpStack.isEmpty()) &#123;</span><br><span class=\"line\">        stack.push(helpStack.pop());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生成窗口最大值数组-双端队列\"><a href=\"#生成窗口最大值数组-双端队列\" class=\"headerlink\" title=\"生成窗口最大值数组(双端队列)\"></a>生成窗口最大值数组(双端队列)</h2><p>输入：整形数组arr，窗口大小w。</p>\n<p>输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下最大值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 生窗口最大值数组，本题的关键在于利用双端队列，来记录滑动窗口的最大值</span></span><br><span class=\"line\"><span class=\"comment\"> * 为啥用双端队列？ 因为我们需要动态的从队列的头和尾更新值</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> arr 输入数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> w   窗口大小</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[] getMaxWindow(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> w) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr == <span class=\"literal\">null</span> || arr.length &lt; w || w&lt;<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// arr.length - w + 1 表示窗口大小w时，最终能获取到多少个最大值</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length - w + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 双端队列，记录窗口内最大值，并进行数据的更新，</span></span><br><span class=\"line\">    LinkedList&lt;Integer&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 插入策略</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty() &amp;&amp; arr[queue.peekLast()] &lt;= arr[i]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 队列中记录的是最大值的下标，方便更新时，判断是否过期</span></span><br><span class=\"line\">            queue.pollLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queue.addLast(i);</span><br><span class=\"line\">        <span class=\"comment\">// 弹出策略 i-w 表示过期值，比如i=5，w=3,i-w=2, 当前遍历到i=5的点，窗口长度为3，那当前窗口内有效值应该是&#123;3,4,5&#125;，2已经过期了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue.peekFirst() == i-w) &#123;</span><br><span class=\"line\">            queue.pollFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= w -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            res[index++] = arr[queue.peekFirst()];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单调栈结构\"><a href=\"#单调栈结构\" class=\"headerlink\" title=\"单调栈结构\"></a>单调栈结构</h2><blockquote>\n<p>给定一个不含有重复值的数组arr，找到每个i位置左边和右边离i位置最近且值比arr[i]小的位置，返回所有位置的相应信息</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 单调栈结构-找到每个节点离自己最近且比自己小的节点位置</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里默认arr内无重复值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[][] rightWay(<span class=\"type\">int</span>[] arr) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[][] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length][<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 栈内存储节点位置</span></span><br><span class=\"line\">    Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 策略：遍历数组，并将值放入栈中，</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果比栈顶值大，则直接放入，下面的值就是离自己最近的最小值点</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果比栈顶值小，则将栈中比自己大的都弹出，确认对应的坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]) &#123;</span><br><span class=\"line\">            <span class=\"type\">Integer</span> <span class=\"variable\">popIndex</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            res[popIndex][<span class=\"number\">0</span>] = stack.isEmpty()?-<span class=\"number\">1</span>:stack.peek();</span><br><span class=\"line\">            res[popIndex][<span class=\"number\">1</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 最后如果栈中还有数据，则一定是升序，也就是说栈内的每个节点都是左边有比自己小的，右边没有。</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里需要注意栈底的点，这个点是左边也没有，右边也没有</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">popIndex</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">        res[popIndex][<span class=\"number\">0</span>] = stack.isEmpty()?-<span class=\"number\">1</span>:stack.peek();</span><br><span class=\"line\">        res[popIndex][<span class=\"number\">1</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 单调栈结构-找到每个节点离自己最近且比自己小的节点位置</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里默认数组内有重复值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span>[][] rightWay(<span class=\"type\">int</span>[] arr) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[][] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length][<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 栈内存储节点位置，节点用List，来存储多个相同的值，List内部存储的也是坐标</span></span><br><span class=\"line\">    Stack&lt;List&lt;Integer&gt;&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 策略：遍历数组，并将值放入栈中</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果比栈顶值大，则直接放入，下面的值就是离自己最近的最小值点</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果和栈顶值一样，则加入栈顶的元素集合中</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果比栈顶值小，则将栈中比自己大的都弹出，确认对应的坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class=\"number\">0</span>)] &gt; arr[i]) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; popList = stack.pop();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">leftIndex</span> <span class=\"operator\">=</span> stack.isEmpty() ? -<span class=\"number\">1</span> : stack.peek().get(stack.peek().size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Integer popi : popList) &#123;</span><br><span class=\"line\">                res[popi][<span class=\"number\">0</span>] = leftIndex;</span><br><span class=\"line\">                res[popi][<span class=\"number\">1</span>] = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class=\"number\">0</span>)] == arr[i]) &#123;</span><br><span class=\"line\">            stack.peek().add(i);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ArrayList&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">            stack.push(list);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; popList = stack.pop();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">leftIndex</span> <span class=\"operator\">=</span> stack.isEmpty() ? -<span class=\"number\">1</span> : stack.peek().get(stack.peek().size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer popi : popList) &#123;</span><br><span class=\"line\">            res[popi][<span class=\"number\">0</span>] = leftIndex;</span><br><span class=\"line\">            res[popi][<span class=\"number\">1</span>] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"求最大子矩阵的大小（单调栈应用）\"><a href=\"#求最大子矩阵的大小（单调栈应用）\" class=\"headerlink\" title=\"求最大子矩阵的大小（单调栈应用）\"></a>求最大子矩阵的大小（单调栈应用）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 求最大子矩阵的大小 -》 单调栈</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">maxRecSize</span><span class=\"params\">(<span class=\"type\">int</span>[][] arr)</span> &#123;</span><br><span class=\"line\">    Stack&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 记录切分后每个位置的高度</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] record = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤1：将二维数组切割为一维数组，record[i] 表示i位置上有多高</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span>[] curList : arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; curList.length; i++) &#123;</span><br><span class=\"line\">            record[i] += curList[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 步骤2：利用单调栈找出每个点左右两侧，离自己最近且比自己小的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; record.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; record[i] &lt; record[stack.peek()]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前值小于栈顶元素，说明栈顶元素列的最大面积已经能计算出来了</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">popIndex</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">popLeftIndex</span> <span class=\"operator\">=</span> stack.isEmpty() ? -<span class=\"number\">1</span> : stack.peek();</span><br><span class=\"line\">            <span class=\"comment\">// 面积值:(i-popLeftIndex-1)*record[popIndex]</span></span><br><span class=\"line\">            max = Math.max(max, (i - popLeftIndex - <span class=\"number\">1</span>) * record[popIndex]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 栈内可能还有剩余元素</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">popIndex</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">popLeftIndex</span> <span class=\"operator\">=</span> stack.isEmpty() ? -<span class=\"number\">1</span> : stack.peek();</span><br><span class=\"line\">        <span class=\"comment\">// 面积值: 左边肯定比自己小，但右边都是比自己大的</span></span><br><span class=\"line\">        max = Math.max(max,(record.length-popLeftIndex-<span class=\"number\">1</span>)*record[popIndex]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最大值减去最小值小于或等于num的子数组的数量（Max-Min-lt-Num-）（双端队列应用）\"><a href=\"#最大值减去最小值小于或等于num的子数组的数量（Max-Min-lt-Num-）（双端队列应用）\" class=\"headerlink\" title=\"最大值减去最小值小于或等于num的子数组的数量（Max - Min &lt;= Num ）（双端队列应用）\"></a>最大值减去最小值小于或等于num的子数组的数量（Max - Min &lt;= Num ）（双端队列应用）</h2><blockquote>\n<p>如果数组长度为N，请实现O(N)的算法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 最大值减去最小值小于或等于num的子数组的数量</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> arr</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param</span> num</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">   * 思路：子数组是多个，当在不断变化时，最大值与最小值也在不断的更新，所以我们应该用一种结构可以实时记录和更新数组中最大值和最小值</span></span><br><span class=\"line\"><span class=\"comment\">   * 这里我们可以想到上面的滑动窗口问题，当时是记录窗口内的最大值。所以这里我们使用两个滑动窗口，一个记录最大值，一个记录最小值</span></span><br><span class=\"line\"><span class=\"comment\">   * max(arr[i..j]) - min(arr[i...j]) &lt;= num ，如果从i-j每种子集都计算一遍，时间复杂度太高，我们可以找找特定的规律</span></span><br><span class=\"line\"><span class=\"comment\">   * - 如果max(arr[i..j]) - min(arr[i...j]) &lt;= num 成立，则arr[i...j]中每一个数组都满足条件,即arr[k...l] (i&lt;=k&lt;=l&lt;=j)</span></span><br><span class=\"line\"><span class=\"comment\">   * 我们用arr[i...j-1]举例， max[arr[i...j]] &gt;= max[arr[i...j-1]]， 因为j如果j比i-(j-1)都大，则=成立，如果不是，则&gt; 成立</span></span><br><span class=\"line\"><span class=\"comment\">   * - 如果上面情况不成立，则arr[k...l](k&lt;=i&lt;=j&lt;=l) 都不满足条件，这样我们就可以排除许多的可能</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getNum</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 记录最大值</span></span><br><span class=\"line\">      LinkedList&lt;Integer&gt; maxList = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">      <span class=\"comment\">// 记录最小值</span></span><br><span class=\"line\">      LinkedList&lt;Integer&gt; minList = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">      <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, j = <span class=\"number\">0</span>, result = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (i &lt; arr.length) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (j &lt; arr.length) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 这里if(false)的唯一可能就是，j在某点时，已经不能继续向前了，所以i开始向右偏移，看是否可以让条件重新满足</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (minList.isEmpty() || minList.peekLast() != j) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// 更新最小值</span></span><br><span class=\"line\">                  <span class=\"keyword\">while</span> (!minList.isEmpty() &amp;&amp; arr[minList.peekLast()] &gt;= arr[j]) &#123;</span><br><span class=\"line\">                      minList.pollLast();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  minList.addLast(j);</span><br><span class=\"line\">                  <span class=\"comment\">// 更新最大值</span></span><br><span class=\"line\">                  <span class=\"keyword\">while</span> (!maxList.isEmpty() &amp;&amp; arr[maxList.peekLast()] &lt;= arr[j]) &#123;</span><br><span class=\"line\">                      maxList.pollLast();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  maxList.addLast(j);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              <span class=\"comment\">// 判断当前结果是否满足条件</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> ((arr[maxList.peekFirst()] - arr[minList.peekFirst()]) &gt; num) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              j++;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          result += j - i;</span><br><span class=\"line\">          <span class=\"comment\">// 检查最大值和最小值是否过期，需要更新的</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (maxList.peekFirst() == i) &#123;</span><br><span class=\"line\">              maxList.pollFirst();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (minList.peekFirst() == i) &#123;</span><br><span class=\"line\">              minList.pollFirst();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          i++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n","text":"第一章：栈与队列设计一个有getMin功能的栈 要求：pop，push，getMin的时间复杂度为：O(1) 123456789101112131415161718192021222324252627282930313233public class stackTemplate &...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":3,"path":"api/categories/数据结构.json"}],"tags":[{"name":"栈","slug":"栈","count":1,"path":"api/tags/栈.json"},{"name":"队列","slug":"队列","count":1,"path":"api/tags/队列.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97\"><span class=\"toc-text\">第一章：栈与队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%9C%89getMin%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%88\"><span class=\"toc-text\">设计一个有getMin功能的栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%B1%E4%B8%A4%E4%B8%AA%E6%A0%88%E7%BB%84%E6%88%90%E7%9A%84%E9%98%9F%E5%88%97\"><span class=\"toc-text\">由两个栈组成的队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BB%85%E7%94%A8%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E5%92%8C%E6%A0%88%E6%93%8D%E4%BD%9C%E9%80%86%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%A0%88\"><span class=\"toc-text\">如何仅用递归函数和栈操作逆序一个栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">用一个栈实现另一个栈的排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E6%95%B0%E7%BB%84-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">生成窗口最大值数组(双端队列)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">单调栈结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B1%82%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%88%E5%8D%95%E8%B0%83%E6%A0%88%E5%BA%94%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">求最大子矩阵的大小（单调栈应用）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E5%80%BC%E5%87%8F%E5%8E%BB%E6%9C%80%E5%B0%8F%E5%80%BC%E5%B0%8F%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8Enum%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%88Max-Min-lt-Num-%EF%BC%89%EF%BC%88%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">最大值减去最小值小于或等于num的子数组的数量（Max - Min &lt;&#x3D; Num ）（双端队列应用）</span></a></li></ol></li></ol>","author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Hexo d 推送至服务器","uid":"1b45a8bf657516596200d2bea123bb7b","slug":"Hexo同步服务器","date":"2022-11-28T02:57:12.000Z","updated":"2022-11-28T03:45:59.894Z","comments":true,"path":"api/articles/Hexo同步服务器.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"Hexo d 推送至服务器​ 前段时间利用Hexo搭建博客，并配合GitHub page进行页面显示，一切都很美妙，但有一个问题就是访问速度太慢，后面我希望将博客迁移到腾讯云中，之后就从服务器访问了。现在关于Hexo搭建基本博客的帖子已经很详细了，所以我会放一些我参考的链接，主要...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","count":1,"path":"api/tags/博客搭建.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis 底层结构","uid":"cdfc791f29b6a36876f87df237d095a0","slug":"Redis/Redis-底层结构","date":"2022-11-26T01:27:45.000Z","updated":"2022-11-26T04:48:22.090Z","comments":true,"path":"api/articles/Redis/Redis-底层结构.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"BigKey是什么 ？BigKey通常以Key的大小和Key中成员的数量来综合判定，例如： Key本身的数据量过大：一个String类型的Key，它的值为5 MB。 Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。 Key中成员的数据量过大：一个Ha...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Redis","slug":"Redis","count":2,"path":"api/categories/Redis.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}