{"title":"反射复习","uid":"c18aa1916b90b67de06b43b022141dcc","slug":"Java/反射复习","date":"2022-12-03T02:57:12.000Z","updated":"2022-12-03T08:18:29.572Z","comments":true,"path":"api/articles/Java/反射复习.json","keywords":null,"cover":"/img/default_top_img.jpg","content":"<h1 id=\"反射复习\"><a href=\"#反射复习\" class=\"headerlink\" title=\"反射复习\"></a>反射复习</h1><h2 id=\"能干嘛\"><a href=\"#能干嘛\" class=\"headerlink\" title=\"能干嘛\"></a>能干嘛</h2><p>​    当我们创建一个对象时，需要事先在源码中进行编写，例如：<code>new Object()</code>,但如果未来发生变化，我就不得不在源码中进行修改，这也违反了开闭原则，我们能不能仅修改配置文件就可以调整系统中需要创建的类。比如说我在配置文件写:</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">classPathName</span>=<span class=\"string\">org.Mysql.SQLBuilder</span></span><br><span class=\"line\"><span class=\"attr\">mathod</span>=<span class=\"string\">getSqlSession</span></span><br></pre></td></tr></table></figure>\n\n<p>​    我想未来我的系统可以读取该配置文件，知道需要的是一个<code>org.Mysql.SQLBuilder</code>类，并且调用<code>getSqlSession</code>方法。等到未来如果修改成：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">classPathName</span>=<span class=\"string\">org.Oracle.SQLBuilder</span></span><br><span class=\"line\"><span class=\"attr\">mathod</span>=<span class=\"string\">getSqlSessions</span></span><br></pre></td></tr></table></figure>\n\n<p>​    那系统也能动态的感知到现在需要的是<code>org.Oracle.SQLBuilder</code>,并要调用<code>getSqlSessions</code>方法。这在之前我们是无法解决的，因为所有使用的类，在编译期就固定了。所以引出了反射技术。也就是为了在运行期，可动态获取类信息或者创建对象。</p>\n<p>​    这在我们学习框架例如Spring，Mybatis时就经常使用，比如我想动态的获取<code>@Table(name=&quot;my_db&quot;)</code>注解内的内容，就可以通过反射来进行获取。</p>\n<blockquote>\n<p>具体功能：</p>\n</blockquote>\n<ol>\n<li><p>在运行时判断任意一个对象所属的类</p>\n</li>\n<li><p>在运行时构造任意一个类对象</p>\n</li>\n<li><p>在运行时得到任意一个类所具有的的成员方法和方法</p>\n</li>\n<li><p>在运行时调用任意一个对象的成员变量和方法</p>\n</li>\n<li><p>生成动态代理</p>\n<h2 id=\"是什么\"><a href=\"#是什么\" class=\"headerlink\" title=\"是什么\"></a>是什么</h2></li>\n</ol>\n<p>​    反射机制允许程序在执行期间借助<code>Reflection API</code>，获取任何类的内部信息（比如：成员变量，构造器，成员方法等），并能操作属性和方法。</p>\n<p>​    当JVM加载完类后，会在堆中产生一个Class类型的对象（一个类只有一个Class对象），这个类对象包含了类的完整结构信息。</p>\n<blockquote>\n<p>Java反射机制原理图</p>\n</blockquote>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8qn5uexq3j30l1099jsq.jpg\" alt=\"image-20221203151322560\"></p>\n<blockquote>\n<p>类加载过程</p>\n</blockquote>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8qocv8yxhj30j008yt9u.jpg\" alt=\"image-20221203155444189\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8qod7ynfnj30ho0973zr.jpg\" alt=\"image-20221203155504141\"></p>\n<blockquote>\n<p>其中最主要的几个类：</p>\n</blockquote>\n<ol>\n<li>Java.lang.Class 表示一个类</li>\n<li>Java.lang.reflect.Method  表示方法</li>\n<li>Java.lang.reflect.Field   表示成员变量</li>\n<li>Java.lang.reflect.Constructor   表示构造器</li>\n</ol>\n<p>其中Method，Field，Constructor都有<code>getModifiers()</code>以int形式返回修饰符</p>\n<p>0: 默认</p>\n<p>1: public</p>\n<p>2: private</p>\n<p>3: protected</p>\n<p>8: static</p>\n<p>16: fianl</p>\n<p>public(1) + static(8) = 9  这样就可以判断出一些信息。</p>\n<h2 id=\"怎么用\"><a href=\"#怎么用\" class=\"headerlink\" title=\"怎么用\"></a>怎么用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// 找到String的类对象</span></span><br><span class=\"line\">    Class&lt;String&gt; aClass = String.class;</span><br><span class=\"line\">  \t<span class=\"comment\">// 获取字段 public</span></span><br><span class=\"line\">    Field[] fields = aClass.getFields();</span><br><span class=\"line\">  \t<span class=\"comment\">// 获取方法 public</span></span><br><span class=\"line\">    Method[] methods = aClass.getMethods();</span><br><span class=\"line\">  \t<span class=\"comment\">// 获取构造器 public</span></span><br><span class=\"line\">    Constructor&lt;?&gt;[] constructors = aClass.getConstructors();</span><br><span class=\"line\">  \t<span class=\"comment\">// 所有修饰符的都可以获取到</span></span><br><span class=\"line\">    aClass.getDeclaredFields();</span><br><span class=\"line\">    aClass.getDeclaredMethods();</span><br><span class=\"line\">    aClass.getDeclaredConstructors();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>反射的优缺点：</p>\n</blockquote>\n<ol>\n<li>优点：可以动态创建和使用对象</li>\n<li>缺点：反射基本是解释执行，对执行速度有影响</li>\n</ol>\n<p>我们可代码验证</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">demo</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">time</span> <span class=\"operator\">=</span> <span class=\"number\">10000000</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 正常方式：</span></span><br><span class=\"line\">        <span class=\"type\">Cat</span> <span class=\"variable\">cat</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Cat</span>();</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; time; i++) &#123;</span><br><span class=\"line\">            cat.hi();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;正常调用：&quot;</span>+ (end - start));</span><br><span class=\"line\">        <span class=\"comment\">// 反射方式：</span></span><br><span class=\"line\">        Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Cat</span>&gt; aClass = cat.getClass();</span><br><span class=\"line\">        <span class=\"type\">Cat</span> <span class=\"variable\">cat1</span> <span class=\"operator\">=</span> aClass.newInstance();</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">hi</span> <span class=\"operator\">=</span> aClass.getMethod(<span class=\"string\">&quot;hi&quot;</span>);</span><br><span class=\"line\">        start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; time; i++) &#123;</span><br><span class=\"line\">            hi.invoke(cat1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;反射调用：&quot;</span>+ (end - start));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 结果： </span></span><br><span class=\"line\">        <span class=\"comment\">// 正常调用：9</span></span><br><span class=\"line\">        <span class=\"comment\">// 反射调用：84</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hi</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    Method和Field和Constructor对象都有<code>setAccessible()</code>方法,setAccessible作用是启动和禁止访问安全检查的开关。当setAccessible(true)表示反射的对象在使用时取消访问检查，提高反射的效率，为false则表示执行访问检查。当我们修改上述代码：<code>hi.setAccessible(true);</code>，最终执行速度可以快一倍左右。</p>\n<p>​    并且当我们访问<code>private</code>修饰的变量，方法，构造器时，如果不设置<code>setAccessible()</code>会爆出：<code>java.lang.IllegalAccessException</code>; 如果设置则可正常访问。</p>\n<h4 id=\"Class类\"><a href=\"#Class类\" class=\"headerlink\" title=\"Class类\"></a>Class类</h4><p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8qo1ltsduj30hr05gdfy.jpg\" alt=\"image-20221203154354105\"></p>\n<ol>\n<li>Class也是类，继承Object。</li>\n<li>Class类不是new出来的，而是系统创建的</li>\n<li>某个类的Class类对象，在内存只有一份，因为类只加载一次 （如果多线程同时进行同一个类加载，会导致阻塞）</li>\n<li>每个类的实例都知道自己是哪个Class实例的</li>\n<li>通过Class对象可以完整的获取一个类的完整结构</li>\n<li>Class对线是存放在堆的</li>\n<li>类的字节码二进制数据，是放在方法区的，也称为元数据。</li>\n</ol>\n<blockquote>\n<p>Class类的常用方法：</p>\n</blockquote>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8qoh7qnzxj30er07y0u7.jpg\" alt=\"image-20221203155854410\"></p>\n<blockquote>\n<p>如果获取Class类</p>\n</blockquote>\n<ol>\n<li>已经知道全类名：<code>Class.forName()</code>,常用语配置文件读取，加载类</li>\n<li>已经知道具体的类：<code>Class clas = Cat.class</code>,性能最好，一般用在参数传递</li>\n<li>已经知道类的实例：<code>Class clas = cat.getClass()</code></li>\n<li>基本数据类型：<code>Class i = int.class</code></li>\n<li>包装类型：<code>Class i = Inteager().Type</code></li>\n</ol>\n<blockquote>\n<p>哪些类型有Class对象</p>\n</blockquote>\n<ol>\n<li>类</li>\n<li>接口</li>\n<li>数组</li>\n<li>枚举</li>\n<li>注解</li>\n<li>基本数据类型</li>\n<li>void</li>\n</ol>\n<h2 id=\"最终测试\"><a href=\"#最终测试\" class=\"headerlink\" title=\"最终测试\"></a>最终测试</h2><p>测试1：</p>\n<p>​    定义PrivateTest类，私有属性name，属性值为hellokitty</p>\n<ol>\n<li>提供getName的公有方法</li>\n<li>利用Class类获取私有的name属性，修改属性值，并调用getName方法，打印name属性</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">demo</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class=\"line\">        Class&lt;PrivateTest&gt; aClass = PrivateTest.class;</span><br><span class=\"line\">        <span class=\"type\">PrivateTest</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> aClass.newInstance();</span><br><span class=\"line\">        <span class=\"type\">Field</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> aClass.getDeclaredField(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        name.setAccessible(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        name.set(instance,<span class=\"string\">&quot;wangCai&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Method</span> <span class=\"variable\">getName</span> <span class=\"operator\">=</span> aClass.getMethod(<span class=\"string\">&quot;getName&quot;</span>);</span><br><span class=\"line\">        System.out.println(getName.invoke(instance));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PrivateTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hellokitty&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试2：</p>\n<ol>\n<li>反射获取File类的Class对象</li>\n<li>在控制台打印File类的所有构造器</li>\n<li>通过newInstance创建File对象，并创建一个本地文件</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">demo</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, ClassNotFoundException, IOException &#123;</span><br><span class=\"line\">        Class&lt;?&gt; aClass = Class.forName(<span class=\"string\">&quot;java.io.File&quot;</span>);</span><br><span class=\"line\">        Constructor&lt;?&gt;[] constructors = aClass.getDeclaredConstructors();</span><br><span class=\"line\">        System.out.println(Arrays.toString(constructors));</span><br><span class=\"line\">        Constructor&lt;?&gt; constructor = aClass.getConstructor(String.class);</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> (File) constructor.newInstance(<span class=\"string\">&quot;doc.txt&quot;</span>);</span><br><span class=\"line\">        file.createNewFile();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"反射复习能干嘛​ 当我们创建一个对象时，需要事先在源码中进行编写，例如：new Object(),但如果未来发生变化，我就不得不在源码中进行修改，这也违反了开闭原则，我们能不能仅修改配置文件就可以调整系统中需要创建的类。比如说我在配置文件写: 12classPathName=or...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%8D%E5%B0%84%E5%A4%8D%E4%B9%A0\"><span class=\"toc-text\">反射复习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%83%BD%E5%B9%B2%E5%98%9B\"><span class=\"toc-text\">能干嘛</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">是什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E7%94%A8\"><span class=\"toc-text\">怎么用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Class%E7%B1%BB\"><span class=\"toc-text\">Class类</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%BB%88%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">最终测试</span></a></li></ol></li></ol>","author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"从 JDBC 到 ORM（例：Mybatis）的演化过程","uid":"bf110c25b189686e7bf0f2a9ddd106cd","slug":"数据库/从 JDBC 到 ORM（例：Mybatis）的演化过程","date":"2022-11-29T11:03:04.000Z","updated":"2022-11-29T11:45:34.570Z","comments":true,"path":"api/articles/数据库/从 JDBC 到 ORM（例：Mybatis）的演化过程.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"从 JDBC 到 ORM（例：Mybatis）的演化过程​ 下面我将介绍Java操作Mysql数据的方式的演化过程，从最基本的JDBC到ORM框架的实现，每一次演化都是为了解决现有存在的问题。 JDBC这里需要加入Mysql驱动包或者依赖. 12345&lt;dependency...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"18 mins."},"categories":[{"name":"数据库","slug":"数据库","count":2,"path":"api/categories/数据库.json"}],"tags":[{"name":"jdbc","slug":"jdbc","count":1,"path":"api/tags/jdbc.json"},{"name":"orm","slug":"orm","count":1,"path":"api/tags/orm.json"},{"name":"mysql","slug":"mysql","count":1,"path":"api/tags/mysql.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}