{"title":"Java基础","uid":"3316961ecf1671c6065b043220187c47","slug":"Java/Java基础","date":"2022-11-23T05:03:04.000Z","updated":"2022-12-02T07:43:54.382Z","comments":true,"path":"api/articles/Java/Java基础.json","keywords":null,"cover":"/img/default_top_img.jpg","content":"<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><blockquote>\n<p>如何将ArrayList变成同步操作？</p>\n</blockquote>\n<p><code>Collections.synchronizedList(arrayList);</code></p>\n<p>Collections.synchronizedList是一个包装类，会将arrayList的一些操作进行加锁，这里我们注意：<strong>读写加锁，迭代器不加锁</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> c.add(e);&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> E <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mutex) &#123;<span class=\"keyword\">return</span> list.get(index);&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title function_\">iterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.iterator(); <span class=\"comment\">// Must be manually synched by user!</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title function_\">listIterator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.listIterator(); <span class=\"comment\">// Must be manually synched by user</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> ListIterator&lt;E&gt; <span class=\"title function_\">listIterator</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.listIterator(index); <span class=\"comment\">// Must be manually synched by user</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h3><blockquote>\n<p>Collections.synchronizedList和Vector的区别?</p>\n</blockquote>\n<p>Vector底层维护的也是一个数组，每次扩容可以按照指定的数进行扩容，默认扩容两倍</p>\n<p>特点就是所有操作进行同步，导致效率比较低</p>\n<p>结论：Vector比较同步全面，Collections.synchronizedList在迭代时需要小心。</p>\n<h3 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h3><p>也是一个线程安全版的ArrayList，适用于读多写少的场景，其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的。所以频繁的写是消耗性能的。</p>\n<blockquote>\n<p>Collections.synchronizedList和CopyOnWriteArrayList怎么选择</p>\n</blockquote>\n<ol>\n<li>多读少写优先考虑CopyOnWriteArrayList; </li>\n<li>SyncList的’读写’都较为均衡，相比CopyOnWriterList其读操作更慢，写操作更快; </li>\n<li>Copy…List的’写时复制原理’会导致’写操作’中间多出来一个’table’备份，从而占用内存，所以要特别注意防止内存溢出。</li>\n</ol>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><blockquote>\n<p>HashMap存储的是Key,Value.也就是一个个小节点，所以内部封装了Node类来存储值，再通过Node数组来存放一个个Node，这里有意思的就是Node它也是一个链表结构，当对key求Hash值时，如果数组上这个位置已经有值了，则直接绑定到之前加入节点的后面，很方便。既能做到查询快，插入也快。</p>\n</blockquote>\n<blockquote>\n<p>HashMap中Put到底是怎么走的？</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//先对key求一个Hash值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent,</span></span><br><span class=\"line\"><span class=\"params\">                   <span class=\"type\">boolean</span> evict)</span> &#123;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//这里初始化一个Node数组，一个Node节点</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, i;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//判定Node数字有没有初始化过</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab = table) == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">          \t<span class=\"comment\">//如果没有，说明现在的Node数组是一个空数组，需要进行扩容后存放数据</span></span><br><span class=\"line\">            n = (tab = resize()).length;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//通过数组中Hash位置判定，是否之前插入过数据</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"literal\">null</span>)</span><br><span class=\"line\"> \t\t\t\t\t\t<span class=\"comment\">//如果没有直接在该节点上插入一个新的Node节点</span></span><br><span class=\"line\">          \ttab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          \t<span class=\"comment\">//这里就是如果之前插入过一个节点，那现在就需要将新来的节点和之前的连接</span></span><br><span class=\"line\">            Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp;</span><br><span class=\"line\">                ((k = p.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                e = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                            treeifyBin(tab, hash);</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                        ((k = e.key) == key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    p = e;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">                <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                    e.value = value;</span><br><span class=\"line\">                afterNodeAccess(e);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//统计有多少数据</span></span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//判定是否需要扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">            resize();</span><br><span class=\"line\">        afterNodeInsertion(evict);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//原来数组的大小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">oldCap</span> <span class=\"operator\">=</span> (oldTab == <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//老的临界点值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">oldThr</span> <span class=\"operator\">=</span> threshold;</span><br><span class=\"line\">        <span class=\"type\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">//这里一般就是第一次使用时，进行默认初始化 容量：16   边界值：12   加载因子：0.75</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (<span class=\"type\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">float</span> <span class=\"variable\">ft</span> <span class=\"operator\">=</span> (<span class=\"type\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"type\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (<span class=\"type\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        <span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">  \t\t\t<span class=\"comment\">// 一般是按照一倍扩容的</span></span><br><span class=\"line\">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>[newCap];</span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldTab != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    oldTab[j] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (e.next == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(<span class=\"built_in\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = <span class=\"literal\">null</span>, loTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = <span class=\"literal\">null</span>, hiTail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (loTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (hiTail == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                <span class=\"keyword\">else</span></span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"literal\">null</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                            loTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                            hiTail.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"put-⽅法原理\"><a href=\"#put-⽅法原理\" class=\"headerlink\" title=\"put() ⽅法原理\"></a>put() ⽅法原理</h4><ol>\n<li>先将Key，Value封装为一个Node。</li>\n<li>通过HashCode()得出Hash值</li>\n<li>通过哈希函数将Hash值装换为数组下标<ol>\n<li>如果这个位置没有任何元素，则直接插入Node</li>\n<li>如果已经有了Node链表，将当前Node的key与链表上每一个Key进行equals比较<ol>\n<li>如果都返回false，则插入链表末尾</li>\n<li>如果有true，则直接新的Node的value替代原来的。（保证不可重复）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>注意：HashMap中允许key，value为null，但只能有一个</p>\n<p>​     HashTable中key和value都不能为空</p>\n</blockquote>\n<h4 id=\"get-方法原理\"><a href=\"#get-方法原理\" class=\"headerlink\" title=\"get() 方法原理\"></a>get() 方法原理</h4><ol>\n<li>通过key的HashCode()方法求出Hash值</li>\n<li>通过哈希函数将hash值转为数组的下标</li>\n<li>通过下标定位到数组的某个位置<ol>\n<li>如果没有链表，直接返回Null</li>\n<li>如果有链表，以此进行匹配每个节点上的key通过equals进行比较<ol>\n<li>如果都为false，则返回null</li>\n<li>如果为true，则返回值</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>放在HashMap中的key元素需要同时重写hashCode()和equals()方法</p>\n</blockquote>\n<h4 id=\"重写HashCode-和equals-方法\"><a href=\"#重写HashCode-和equals-方法\" class=\"headerlink\" title=\"重写HashCode()和equals()方法\"></a>重写HashCode()和equals()方法</h4><blockquote>\n<p>一定要分布均匀</p>\n<ol>\n<li><p>如果hashCode()返回的一个值，就会变成单链表</p>\n</li>\n<li><p>如果hashCode()返回的都不一样值，HashMap就变成数组了</p>\n</li>\n</ol>\n<p>这也称为分布不均匀</p>\n<p>equals ，hashCode 需要同时重写，保证一个对象一旦相等，Hash值也应该相同</p>\n</blockquote>\n<h4 id=\"注意事项：\"><a href=\"#注意事项：\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h4><p>如果可以预测到容量最好，多设置一些，一方面避免频繁的扩容，一方面也需要考虑到加载因子的边界值</p>\n<h4 id=\"为什么Map需要有加载因子，0-75\"><a href=\"#为什么Map需要有加载因子，0-75\" class=\"headerlink\" title=\"为什么Map需要有加载因子，0.75\"></a>为什么Map需要有加载因子，0.75</h4><ol>\n<li>如果不设置边界值，Map的Hash碰撞概率到后面会越来越高，影响效率</li>\n<li>0.75是一个普遍值，需要用数学证明</li>\n</ol>\n<h3 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h3><ol>\n<li>自平衡二叉树，平衡二叉树是指：根节点的左子节点与右子树的高度相差不会超过1层，当超过时，会进行自旋翻转</li>\n<li>迭代器采用中序遍历</li>\n<li>无序，不可重复，可排序（这里需要注意如果key为自定义类型，需要实现<code>java.lang.Comparable</code>接口，重写compareTo方法，或者在TreeMap构造器中重新compare方法）<ol>\n<li>当我们规则固定时，建议使用实现<code>java.lang.Comparable</code>接口。</li>\n<li>当当我们规则需要修改时，使用Comparator接口</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Collection工具类\"><a href=\"#Collection工具类\" class=\"headerlink\" title=\"Collection工具类\"></a>Collection工具类</h2><ol>\n<li><code>Collections.sort(List list)</code></li>\n<li><code>Collections.sort(List list, Compataor cmp)</code></li>\n</ol>\n<h2 id=\"String存储原理\"><a href=\"#String存储原理\" class=\"headerlink\" title=\"String存储原理\"></a>String存储原理</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//这里是直接创建在方法区的字符串常量池</span></span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">       <span class=\"comment\">//这个是在堆中创建了一个String对象，但值是指向方法区的</span></span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abc&quot;</span>);</span><br><span class=\"line\">       <span class=\"comment\">//判断这个字符串在常量池是否存在，如果存在直接返回，如果不存在创建返回</span></span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> s1.intern();</span><br><span class=\"line\"></span><br><span class=\"line\">       System.out.println(s == s1);   <span class=\"comment\">//false</span></span><br><span class=\"line\">       System.out.println(s1 == s2);  <span class=\"comment\">//false</span></span><br><span class=\"line\">       System.out.println(s == s2);   <span class=\"comment\">//true</span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"String-StringBuilder-StringBuffer\"><a href=\"#String-StringBuilder-StringBuffer\" class=\"headerlink\" title=\"String,StringBuilder,StringBuffer\"></a>String,StringBuilder,StringBuffer</h4><ol>\n<li>String被final修饰，当你修改时是直接创建一个新的在方法区，所以当我们使用时，如果该值经常就修改，最好使用后面两个</li>\n<li>StringBuilder没有final修饰，可变，线程不安全，效率高</li>\n<li>StringBuffer没有final修饰，可变，线程安全，效率低</li>\n</ol>\n<h2 id=\"锁问题\"><a href=\"#锁问题\" class=\"headerlink\" title=\"锁问题\"></a>锁问题</h2><h3 id=\"Synchronize（重量级锁）\"><a href=\"#Synchronize（重量级锁）\" class=\"headerlink\" title=\"Synchronize（重量级锁）\"></a>Synchronize（重量级锁）</h3><blockquote>\n<p>加在方法上，对方法进行同步，也就是每次只能一个线程进入。默认为非公平锁</p>\n</blockquote>\n<ol>\n<li>优点：简单，直接，自动完成加锁，解锁操作</li>\n<li>缺点：在用户态和内核态进行切换，效率低。</li>\n</ol>\n<h3 id=\"ReenLock（手动锁）\"><a href=\"#ReenLock（手动锁）\" class=\"headerlink\" title=\"ReenLock（手动锁）\"></a>ReenLock（手动锁）</h3><blockquote>\n<p>通过创建锁对象，手动的进行加锁，和解锁</p>\n</blockquote>\n<ol>\n<li>优点：可以自己设置为公平或非公平锁</li>\n</ol>\n<blockquote>\n<p>非公平锁：假如有三个线程同时来，那最终哪个线程能够进入就看谁快，（不用排队）</p>\n<p>公平锁：三个线程进入，依次放入一个队列，（先到先得）</p>\n</blockquote>\n<ol start=\"2\">\n<li>缺点：需要自己注意解锁的过程，锁是可重入的，如果少释放一层就会出现死锁现象</li>\n</ol>\n<h3 id=\"CAS（Compare-And-Set：轻量级锁，乐观锁）\"><a href=\"#CAS（Compare-And-Set：轻量级锁，乐观锁）\" class=\"headerlink\" title=\"CAS（Compare And Set：轻量级锁，乐观锁）\"></a>CAS（Compare And Set：轻量级锁，乐观锁）</h3><blockquote>\n<p>通过<code>AtomicReference</code>进行创建自旋锁，每次线程操作前会检查自旋锁的值是否是预想值，如果不是需要进行自旋操作，知道当前值与预期值一致时，才可以操作。</p>\n</blockquote>\n<ol>\n<li>优点：不会进入内核态，减少切换的性能消耗</li>\n<li>缺点：自旋其实就是循环，如果一个线程一直无法进行操作，就会导致CPU空转，也会带来性能消耗</li>\n</ol>\n<blockquote>\n<p>CAS的经典问题：ABA问题 -&gt; 就是说我预期值为1，但是别的线程先改成2了，再一个线程又改成1了，那当我判断时并不知道这个值之前已经被人操作了，我会继续执行我自己的逻辑。那么该如何解决呢？</p>\n</blockquote>\n<p>使用<code>AtomicStampedReference</code>加上时间戳，通俗的说就是加上一个版本号，不仅要比较当前值，还要比较版本号。只有两者都相等，才执行更新操作。</p>\n<blockquote>\n<p>如果优化CAS?</p>\n</blockquote>\n<p>​    可在线程空转一定时间后，放入阻塞队列中等待。</p>\n<h3 id=\"LockSupport\"><a href=\"#LockSupport\" class=\"headerlink\" title=\"LockSupport\"></a>LockSupport</h3><ol>\n<li>是什么<ol>\n<li>对阻塞，唤醒的优化机制</li>\n<li>其实底层使用的是一个permit许可证，取值范围0-1</li>\n</ol>\n</li>\n<li>能干嘛<ol>\n<li>线程同步操作</li>\n</ol>\n</li>\n<li>去哪下<ol>\n<li>JUC包</li>\n</ol>\n</li>\n<li>怎么玩<ol>\n<li>LockSupport.port相当于需要消耗一个许可证，如果许可证=1，则直接-1返回，不会阻塞，</li>\n<li>LockSupport.unport相当于给出一个许可证，但是许可证上限是1，重复使用unport许可证还是等于1，所以执行两次LockSupport.unport 和 LockSupport.port，会导致最后一个port阻塞</li>\n</ol>\n</li>\n<li>AB法则<ol>\n<li>Object.wait() 和 Object.notify() 有哪些不足<ol>\n<li>wait 和 notify 必须在同步代码块中出现.</li>\n<li>无法先notify，再wait，会导致死锁问题</li>\n</ol>\n</li>\n<li>Lock.Condition.await()  和 signal() 有哪些不足<ol>\n<li>与wait,notify的问题一致</li>\n</ol>\n</li>\n<li>所以我们推出了LockSupport，看是如果解决上述方法了。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h3><p>我们通过对ReentrantLock的源码解读来学习</p>\n<blockquote>\n<p>创建锁</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个Reentrant锁</span></span><br><span class=\"line\"><span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\"><span class=\"comment\">// 通过构造器我们可以看到实际上创建的是一个Sync对象</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ReentrantLock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Sync</span> <span class=\"variable\">sync</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NonfairSync</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// Sync类是继承了AQS（抽象队列同步器）</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractQueuedSynchronizer</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>获取锁</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 底层还是sync对象调用lock方法</span></span><br><span class=\"line\">lock.lock();  -&gt;  sync.lock();</span><br><span class=\"line\"><span class=\"comment\">// lock方法是Sync的抽象模板方法，具体由NonfairSync进行实现，这里我们使用默认的非公平锁</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  \t\t\t\t\t<span class=\"comment\">// 尝试获取锁</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">                <span class=\"comment\">// 如果获取成功则，将当前线程设为所有者线程</span></span><br><span class=\"line\">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果没获取到，则再判断</span></span><br><span class=\"line\">                acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">acquire</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">  \t\t\t<span class=\"comment\">// 调用nonfairTryAcquire(int acquires) 再次尝试获取锁，判断是否为可重入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">            <span class=\"comment\">// 先将当前线程创建成一个节点，加入等待队列中，再进行最后的尝试</span></span><br><span class=\"line\">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">            selfInterrupt();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"type\">int</span> acquires)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当前线程</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 这里使用AQS方法，获取锁值，</span></span><br><span class=\"line\">  \t<span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果为0说明可以抢占锁了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断之前抢到锁的线程是否就是自己，保证锁的可重入性</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是，则计数器+1</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">nextc</span> <span class=\"operator\">=</span> c + acquires;</span><br><span class=\"line\">        <span class=\"comment\">// 这里怕计数器溢出了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"comment\">// 判断抢锁成功</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 抢锁失败</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Node <span class=\"title function_\">addWaiter</span><span class=\"params\">(Node mode)</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// 添加一个等待节点，并标记为渎职EXCLUSIVE独占模式</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取队列中的尾结点</span></span><br><span class=\"line\">    <span class=\"type\">Node</span> <span class=\"variable\">pred</span> <span class=\"operator\">=</span> tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尾结点不为空，说明前面还有等待的节点，则进行串联</span></span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果队列为空，则插入当前节点到队列中</span></span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"comment\">// 最后返回生成的节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Node <span class=\"title function_\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这是一个自旋结构</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 再次判断队列是否为空</span></span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> tail;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t == <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">                <span class=\"comment\">// 将该节点加入队列，这里注意头结点和尾结点是一个系统自建的一个节点，也是一个面试可能考的点，第一个进入等待队列的节点，其头指针指向的是哨兵节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>()))</span><br><span class=\"line\">                    tail = head;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 新来的节点连接尾结点或哨兵节点</span></span><br><span class=\"line\">                node.prev = t;</span><br><span class=\"line\">                <span class=\"comment\">// 将尾指针设置为新加入的节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                    t.next = node;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>开始准备将节点进行阻塞</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">failed</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 自旋结构</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 获取当前封装节点的前一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">Node</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> node.predecessor();</span><br><span class=\"line\">            <span class=\"comment\">// 如果p就是头结点，也就是哨兵节点，则再尝试去获取锁</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果获取成功了，将当前线程节点设置为头结点</span></span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                <span class=\"comment\">// 将之前的头结点进行垃圾回收，这里其实就是头结点的替换</span></span><br><span class=\"line\">                p.next = <span class=\"literal\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 返回线程是否被打断过</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// Park相当于wait进行阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            <span class=\"comment\">// 取消排队</span></span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 获取前一个节点可能是哨兵节点的状态值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> pred.waitStatus;</span><br><span class=\"line\">        <span class=\"comment\">// 如果status值=-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">            <span class=\"comment\">// 说明这个节点已经尝试过一次（因为调用结构为自旋），但是失败了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">             * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                node.prev = pred = pred.prev;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里如果是第一次来，则将前节点状态值设置为-1</span></span><br><span class=\"line\">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">parkAndCheckInterrupt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前节点直接被挂起，相当于阻塞，也就是不再去抢锁了</span></span><br><span class=\"line\">        LockSupport.park(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>解锁</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock.unlock();  -&gt;   sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">release</span><span class=\"params\">(<span class=\"type\">int</span> arg)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试解锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点解锁成功后，再看AQS头结点</span></span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">            <span class=\"comment\">// 如果头结点不为空，且只要status!=0,说明队列中肯定有阻塞的节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h != <span class=\"literal\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">tryRelease</span><span class=\"params\">(<span class=\"type\">int</span> releases)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将当前线程节点状态-1，</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> getState() - releases;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalMonitorStateException</span>();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">free</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// c=0表示已经锁解除干净了，没有重入了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                free = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 将占锁标记指向null，其他线程看到了。就可以直接去抢占了</span></span><br><span class=\"line\">                setExclusiveOwnerThread(<span class=\"literal\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 设置这个线程的状态值</span></span><br><span class=\"line\">            setState(c);</span><br><span class=\"line\">            <span class=\"comment\">// 返回解锁成功</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unparkSuccessor</span><span class=\"params\">(Node node)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class=\"line\"><span class=\"comment\">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class=\"line\"><span class=\"comment\">         * fails or if status is changed by waiting thread.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 注意这个的node是AQS的头结点，判断status值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ws</span> <span class=\"operator\">=</span> node.waitStatus;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 将头结点的值设置为0</span></span><br><span class=\"line\">            compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Thread to unpark is held in successor, which is normally</span></span><br><span class=\"line\"><span class=\"comment\">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class=\"line\"><span class=\"comment\">         * traverse backwards from tail to find the actual</span></span><br><span class=\"line\"><span class=\"comment\">         * non-cancelled successor.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取到哨兵节点后第一个阻塞节点</span></span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> node.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"literal\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            s = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">Node</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> tail; t != <span class=\"literal\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                    s = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 这里我们可以看到被阻塞的线程被唤醒了</span></span><br><span class=\"line\">            LockSupport.unpark(s.thread);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n","text":"ListArrayList 如何将ArrayList变成同步操作？ Collections.synchronizedList(arrayList); Collections.synchronizedList是一个包装类，会将arrayList的一些操作进行加锁，这里我们注意：读写...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"集合","slug":"集合","count":1,"path":"api/tags/集合.json"},{"name":"锁","slug":"锁","count":1,"path":"api/tags/锁.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#List\"><span class=\"toc-text\">List</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ArrayList\"><span class=\"toc-text\">ArrayList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Vector\"><span class=\"toc-text\">Vector</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CopyOnWriteArrayList\"><span class=\"toc-text\">CopyOnWriteArrayList</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HashMap\"><span class=\"toc-text\">HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#put-%E2%BD%85%E6%B3%95%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">put() ⽅法原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#get-%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">get() 方法原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%86%99HashCode-%E5%92%8Cequals-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">重写HashCode()和equals()方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A\"><span class=\"toc-text\">注意事项：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88Map%E9%9C%80%E8%A6%81%E6%9C%89%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%EF%BC%8C0-75\"><span class=\"toc-text\">为什么Map需要有加载因子，0.75</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TreeMap\"><span class=\"toc-text\">TreeMap</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Collection%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">Collection工具类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#String%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">String存储原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#String-StringBuilder-StringBuffer\"><span class=\"toc-text\">String,StringBuilder,StringBuffer</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%81%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">锁问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Synchronize%EF%BC%88%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%89\"><span class=\"toc-text\">Synchronize（重量级锁）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ReenLock%EF%BC%88%E6%89%8B%E5%8A%A8%E9%94%81%EF%BC%89\"><span class=\"toc-text\">ReenLock（手动锁）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CAS%EF%BC%88Compare-And-Set%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%89\"><span class=\"toc-text\">CAS（Compare And Set：轻量级锁，乐观锁）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#LockSupport\"><span class=\"toc-text\">LockSupport</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AQS\"><span class=\"toc-text\">AQS</span></a></li></ol></li></ol>","author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"IO流","uid":"eab0435802cc6e95f43c834dccfaf907","slug":"Java/IO流","date":"2022-11-24T05:03:04.000Z","updated":"2022-12-02T07:43:54.349Z","comments":true,"path":"api/articles/Java/IO流.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"今天面试的时候问了一道IO流的题，鉴于之前在java基础篇的时候学过一遍，后再无使用和复习，就再跟着韩顺平老师的课件复习一遍。 IO流IO流是什么？当我们使用程序读取或修改本地文件时， 文件是以流的形式加载在内存中的。 InputStream:输入流，从数据源加载至内存。 Out...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"IO流","slug":"IO流","count":1,"path":"api/tags/IO流.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}