{"title":"Spring如何解决循环依赖","uid":"2846594611fd32071ec8e1a72cd8f17d","slug":"Spring/Spring如何解决循环依赖","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T07:24:28.522Z","comments":true,"path":"api/articles/Spring/Spring如何解决循环依赖.json","keywords":null,"cover":"/img/default_top_img.jpg","content":"<h2 id=\"Spring循环依如何解决？\"><a href=\"#Spring循环依如何解决？\" class=\"headerlink\" title=\"Spring循环依如何解决？\"></a>Spring循环依如何解决？</h2><blockquote>\n<p>循环依赖是什么？</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">  A a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//简单来说就是A的创建依赖于B，B的创建依赖于A。</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在一般场景下，如何解决循环依赖的问题？</p>\n<p>我们知道对象的创建一般有：</p>\n<p>​    无参构造器+属性Set方法初始化对象</p>\n<p>​    有参构造器直接初始化对象</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过有参构造器初始化</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">A</span><span class=\"params\">(B b)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.b = b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">  A a;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"title function_\">B</span><span class=\"params\">(A a)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">client</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//我们发现会无限套娃下去，有参构造器方法不能使用</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">A</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">B</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">A</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">B</span>())))  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过无参参构造器初始化</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setB</span><span class=\"params\">(B b)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.b = b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">  A a;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setA</span><span class=\"params\">(A a)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">client</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//可以发现无参构造器+set方法可以完成任务</span></span><br><span class=\"line\">  <span class=\"type\">A</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">a</span>();</span><br><span class=\"line\">  <span class=\"type\">B</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">b</span>();</span><br><span class=\"line\">  a.setB(b);</span><br><span class=\"line\">  b.setA(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>通过上面的场景，我们就可以知道利用Set方法可以解决循环依赖，那在Spring中也是如此，但增加了亿丝细节</p>\n</blockquote>\n<blockquote>\n<p>我们在使用Spring时，常讲Spring容器，也就是我们不去new对象，而是从容器中取对象，那这个容器到底是什么？</p>\n</blockquote>\n<p>​    容器顾名思义，就是存放数据对象的地方，又是在内存中的，每次我们向容器里取对象时都会提供一个对象名，或者是类型信息，然后容器返回相应的数据，那在Java基础中，我们学习到的Map结构，就很符合这样要求，通过Key，Value来存储对象信息。所以其实Spring容器就是通过一个Map来实现的，也就是这个家伙<code>Map&lt;String, Object&gt; singletonObjects</code>,但更确切的来说它叫做一级缓存，专门存放已经完整经过生命周期的对象（对象初始化后，参数也赋值了）。那既然有一级缓存就可能有其他级缓存，确实Spring有三层缓存，而这三层缓存就是来解决循环依赖的关键！！！</p>\n<blockquote>\n<p>三级缓存为哪三级，分别是干嘛的？</p>\n</blockquote>\n<p><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8heivk5brj30wo0bz40a.jpg\" alt=\"image-20220705113930715\"></p>\n<p>上图就Spring中的源码，三个Map对象的就是三级缓存</p>\n<ol>\n<li><code>singletonObjects</code>:一级缓存存放完整生命周期的Bean，我们从容器中取对象，就从这里找的。</li>\n<li><code>earlySingletonObjects</code>:二级缓存存放半生命周期的Bean，可以理解为通过无参构造器向堆空间申请内存了，但是没有对属性赋值。</li>\n<li><code>singletonFactories</code>:三级缓存存放创建Bean的工厂。</li>\n</ol>\n<blockquote>\n<p>我们知道Spring容器中可以设置对象为多例模式和单例模式，每种模式都可以解决循环依赖问题吗？</p>\n</blockquote>\n<blockquote>\n<p>单例模式我们知道是存放在一级缓存中的，那<em>prototype</em>模式的对象是否也在一级缓存中？</p>\n</blockquote>\n<p>下面我们先来看看当创建prototype对象时，底层发生了什么</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(String name, Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.assertBeanFactoryActive();</span><br><span class=\"line\">  \t<span class=\"comment\">//获取目标bean</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.getBeanFactory().getBean(name, requiredType);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">getBean</span><span class=\"params\">(String name, Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">  <span class=\"comment\">//一般do开头的方法都是干实事儿的，重点关注</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> doGetBean(name, requiredType, <span class=\"literal\">null</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Eagerly check singleton cache for manually registered singletons.  </span></span><br><span class=\"line\"><span class=\"comment\">// 可以看到不管是不是单例模式都会来一级缓存寻找，但是这里没有找到</span></span><br><span class=\"line\"><span class=\"type\">Object</span> <span class=\"variable\">sharedInstance</span> <span class=\"operator\">=</span> getSingleton(beanName);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!typeCheckOnly) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//标记对象是否之前创建过了</span></span><br><span class=\"line\">   markBeanAsCreated(beanName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里只有第一次创建时会进来，标记为该类型对象已经创建，第二次获取bean实例时就知道之前已经创建了，直接退出</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">markBeanAsCreated</span><span class=\"params\">(String beanName)</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (<span class=\"built_in\">this</span>.mergedBeanDefinitions) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!<span class=\"built_in\">this</span>.alreadyCreated.contains(beanName)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Let the bean definition get re-merged now that we&#x27;re actually creating</span></span><br><span class=\"line\">            <span class=\"comment\">// the bean... just in case some of its metadata changed in the meantime.</span></span><br><span class=\"line\">            clearMergedBeanDefinition(beanName);</span><br><span class=\"line\">           <span class=\"comment\">//这里记录之前创建过的对象</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.alreadyCreated.add(beanName);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//判断是否为isPrototypel类型对象</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mbd.isPrototype()) &#123;</span><br><span class=\"line\">   <span class=\"comment\">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class=\"line\">   <span class=\"type\">Object</span> <span class=\"variable\">prototypeInstance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      beforePrototypeCreation(beanName);</span><br><span class=\"line\">     <span class=\"comment\">//这里就要创建prototypeInstance实例了</span></span><br><span class=\"line\">      prototypeInstance = createBean(beanName, mbd, args);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      afterPrototypeCreation(beanName);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  <span class=\"comment\">//重点</span></span><br><span class=\"line\">   bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">createBean</span><span class=\"params\">(String beanName, RootBeanDefinition mbd, <span class=\"meta\">@Nullable</span> Object[] args)</span></span><br><span class=\"line\">      <span class=\"keyword\">throws</span> BeanCreationException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">      logger.trace(<span class=\"string\">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class=\"string\">&quot;&#x27;&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"type\">RootBeanDefinition</span> <span class=\"variable\">mbdToUse</span> <span class=\"operator\">=</span> mbd;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Make sure bean class is actually resolved at this point, and</span></span><br><span class=\"line\">  \t<span class=\"comment\">//在动态解析类的情况下克隆bean定义</span></span><br><span class=\"line\">   <span class=\"comment\">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class=\"line\">   <span class=\"comment\">// which cannot be stored in the shared merged bean definition.</span></span><br><span class=\"line\">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (resolvedClass != <span class=\"literal\">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      mbdToUse = <span class=\"keyword\">new</span> <span class=\"title class_\">RootBeanDefinition</span>(mbd);</span><br><span class=\"line\">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Prepare method overrides.</span></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      mbdToUse.prepareMethodOverrides();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class=\"line\">            beanName, <span class=\"string\">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class=\"line\">      <span class=\"type\">Object</span> <span class=\"variable\">bean</span> <span class=\"operator\">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (bean != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class=\"line\">            <span class=\"string\">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//这里do开头，是重点</span></span><br><span class=\"line\">      <span class=\"type\">Object</span> <span class=\"variable\">beanInstance</span> <span class=\"operator\">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">         logger.trace(<span class=\"string\">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class=\"string\">&quot;&#x27;&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> beanInstance;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// No special handling: simply use no-arg constructor.</span></span><br><span class=\"line\"><span class=\"comment\">//要通过无参构造器创建了</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> instantiateBean(beanName, mbd);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取实例化策略，然后实例化对象</span></span><br><span class=\"line\">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return the instantiation strategy to use for creating bean instances.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> InstantiationStrategy <span class=\"title function_\">getInstantiationStrategy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.instantiationStrategy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//马上要创建了</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//利用反射要真正创建实例了</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> ctor.newInstance(argsWithDefaultValues);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> B <span class=\"title function_\">getB</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setB</span><span class=\"params\">(B b)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.b = b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//进入A的无参构造器，实例化对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">A</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---A created success&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Initialize the bean instance.</span></span><br><span class=\"line\">\t\t<span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//填充属性</span></span><br><span class=\"line\">\t\t\tpopulateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">\t\t\texposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上断点代码就是Spring中的源码显示，大家感兴趣，也可以自己打一遍。</p>\n<p><strong>小总结</strong>：</p>\n<ol>\n<li>我们可以看到为什么当变量设置为prototype时，每次返回的对象都不一样.<ul>\n<li>因为在Spring容器中根本没有缓存之前的对象，而是每次都反射一个新的对象进行返回。</li>\n<li>而在单例模式时，会将对象放到缓存中，这样你下次再要对象时，直接从一级缓存中找。</li>\n</ul>\n</li>\n<li>prototype也叫做原型，很多人以为是利用了原型设计模式，存第一次创建的实例，然后每次拷贝一个新的返回。<ul>\n<li>但根据源码阅读发现创建的实例根本没有存储在容器中，哪来的拷贝。<code>不看源码你就被坑了，但是也不要相信我的话，你最好自己再看一遍。</code></li>\n<li>推荐一个博主写的文章：<a href=\"https://blog.csdn.net/FanYien/article/details/117898188%E3%80%82\">https://blog.csdn.net/FanYien/article/details/117898188。</a></li>\n</ul>\n</li>\n<li>那prototype能解决循环依赖问题吗？<ul>\n<li>不能，因为假如说A类中有一个B属性需要注入，当实例化A时需要注入B，而B现在没有，需要先实例一个B对象，实例B的时候一个A注入，但容器中找不到之前创建的A，所以需要自己再实例一个A对象，循环往复，因为每次返回的对象都不同。Spring官网也明确禁止了。</li>\n<li>所以我们说Spring解决循环依赖的前提是对象是单例模式下的，并通过Set方法构建。</li>\n</ul>\n</li>\n<li>那单例模式下是如何解决循环依赖的？<ul>\n<li>这里推荐另一个博主写的，写的非常详细：<a href=\"https://blog.csdn.net/oneby1314/article/details/113789384\">https://blog.csdn.net/oneby1314/article/details/113789384</a></li>\n<li>其实总结下来就是，利用三层缓存来解决，现在容器需要注入一个A对象时，先去一级缓存中找，没有的话则容器直接实例化一个A（没有对属性赋值）并放入三级缓存，当需要注入A对象的B属性类时，也去容器找，没有的话再实例化一个B，当给B对象的A赋值时，也去一级缓存找，没有则去二级缓存找，再没有去三级缓存，这是发现找到了之前的A，则直接注入，B这就算完整了放在一级缓存，又回到A的初始化，去一级缓存找，发现有一个B，则对A也初始化。这样循环依赖就解决掉了。具体可以看上面博主的文章。</li>\n</ul>\n</li>\n<li>看完后突然感觉似乎一层缓存也可以解决循环依赖问题，为什么Spring要用三层？<ul>\n<li>这里我是看了<a href=\"https://juejin.cn/post/6930904292958142478%E8%BF%99%E4%BD%8D%E5%8D%9A%E4%B8%BB%E7%9A%84%E6%96%87%E7%AB%A0%E6%89%8D%E7%90%86%E8%A7%A3%E4%B8%80%E4%BA%9B\">https://juejin.cn/post/6930904292958142478这位博主的文章才理解一些</a></li>\n<li>大致是说三级缓存是Spring在结合<code>AOP</code>跟Bean的生命周期的设计，保证如果需要代理时，保证在Bean生命周期最后一步再完成代理。</li>\n<li><img src=\"https://tva1.sinaimg.cn/large/008vxvgGly1h8heirn3enj31xs0ekad1.jpg\" alt=\"image-20220902091424411\"></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>​    这算是我第一次自己读Spring源码，在之前一般遇到问题我都是看有没有别人的总结，觉的源码我肯定看不了，看别人的总结又方便又快捷。今天是因为当我再来回顾这些知识的时候，脑子里出现很多问题，感觉作者并没有说清楚，而且众说纷纭，那我们就自己做实验，自己去寻找答案吧，虽然开始做是耗时耗力，但能让你的心慢慢沉下来，浮躁是读不了源码的，感谢之前一位朋友的建议，<code>生活上我们很多事情不需要太较真，但学习必须较真!!!</code>,文笔有限，如果觉得哪里写的有问题，也欢迎提醒我进行修改。最后建议大家，全信书不如无书，自己去打断点看源码得到的才是最真实的。</p>\n","text":"Spring循环依如何解决？ 循环依赖是什么？ 1234567class A&#123; B b;&#125;class B&#123; A a;&#125;//简单来说就是A的创建依赖于B，B的创建依赖于A。 在一般场景下，如何解决循环依赖的问题？ 我们知道对象的创建一般有： ...","link":"","photos":[],"count_time":{"symbolsCount":"7.6k","symbolsTime":"7 mins."},"categories":[{"name":"Spring","slug":"Spring","count":2,"path":"api/categories/Spring.json"}],"tags":[{"name":"循环依赖","slug":"循环依赖","count":1,"path":"api/tags/循环依赖.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F\"><span class=\"toc-text\">Spring循环依如何解决？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"封装自己的SDK","uid":"fad787980031e756d8eadb6688777ddf","slug":"Spring/封装自己的SDK","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:48:35.827Z","comments":true,"path":"api/articles/Spring/封装自己的SDK.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"封装自己的SDK​ 我们在开发Spring项目时常常会引入各种xxx-spring-boot-starter的依赖包，然后在配置文件中填入必要的信息，就可以使用依赖提供好的容器。这里是在鱼皮新项目直播中学习到的，特此记录一下。可在未来封装自己的SDK进行封装与装逼。 SDK项目下...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"Spring","slug":"Spring","count":2,"path":"api/categories/Spring.json"}],"tags":[{"name":"SDK","slug":"SDK","count":1,"path":"api/tags/SDK.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"拦截器与过滤器的区别","uid":"2b2e8451f755e036c0af04fba68240df","slug":"Web/拦截器与过滤器的区别","date":"2022-11-25T05:03:04.000Z","updated":"2022-11-25T06:02:50.203Z","comments":true,"path":"api/articles/Web/拦截器与过滤器的区别.json","keywords":null,"cover":"/img/default_top_img.jpg","text":"拦截器与过滤器的区别 底层思想是什么？ 拦截器与过滤器都是基于AOP面向切面编程的思想来实现的。 两者有什么相同，有什么不同？ 相同点：都可以对请求做出统一的处理，例如在方法调用前进行一些操作，在方法调后后处理一些操作 不同点： 拦截器是Spring提供的（org.springf...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"Web","slug":"Web","count":1,"path":"api/categories/Web.json"}],"tags":[{"name":"Filter","slug":"Filter","count":1,"path":"api/tags/Filter.json"},{"name":"Interceptor","slug":"Interceptor","count":1,"path":"api/tags/Interceptor.json"}],"author":{"name":"秦思成","slug":"blog-author","avatar":"https://tva2.sinaimg.cn/large/9bd9b167ly1fzjxy660fij20b40b43yi.jpg","link":"/","description":"我的个人知识库","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}